/* automatically generated by rust-bindgen 0.64.0 */

pub const IO_SEPROXYHAL_BUFFER_SIZE_B: u32 = 300;
pub const BAGL_WIDTH: u32 = 128;
pub const BAGL_HEIGHT: u32 = 64;
pub const IO_USB_MAX_ENDPOINTS: u32 = 7;
pub const IO_HID_EP_LENGTH: u32 = 64;
pub const USB_SEGMENT_SIZE: u32 = 64;
pub const WEBUSB_URL_SIZE_B: u32 = 0;
pub const WEBUSB_URL: &[u8; 1usize] = b"\0";
pub const TARGET_ID: u32 = 857735172;
pub const _NEWLIB_VERSION_H__: u32 = 1;
pub const _NEWLIB_VERSION: &[u8; 6usize] = b"3.3.0\0";
pub const __NEWLIB__: u32 = 3;
pub const __NEWLIB_MINOR__: u32 = 3;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const __have_longlong64: u32 = 1;
pub const __have_long32: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const __int20: u32 = 2;
pub const __int20__: u32 = 2;
pub const __INT8: &[u8; 3usize] = b"hh\0";
pub const __INT16: &[u8; 2usize] = b"h\0";
pub const __INT64: &[u8; 3usize] = b"ll\0";
pub const __FAST8: &[u8; 3usize] = b"hh\0";
pub const __FAST16: &[u8; 2usize] = b"h\0";
pub const __FAST64: &[u8; 3usize] = b"ll\0";
pub const __LEAST8: &[u8; 3usize] = b"hh\0";
pub const __LEAST16: &[u8; 2usize] = b"h\0";
pub const __LEAST64: &[u8; 3usize] = b"ll\0";
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const CX_OK: u32 = 0;
pub const CX_CARRY: u32 = 4294967073;
pub const CX_LOCKED: u32 = 4294967169;
pub const CX_UNLOCKED: u32 = 4294967170;
pub const CX_NOT_LOCKED: u32 = 4294967171;
pub const CX_NOT_UNLOCKED: u32 = 4294967172;
pub const CX_INTERNAL_ERROR: u32 = 4294967173;
pub const CX_INVALID_PARAMETER_SIZE: u32 = 4294967174;
pub const CX_INVALID_PARAMETER_VALUE: u32 = 4294967175;
pub const CX_INVALID_PARAMETER: u32 = 4294967176;
pub const CX_NOT_INVERTIBLE: u32 = 4294967177;
pub const CX_OVERFLOW: u32 = 4294967178;
pub const CX_MEMORY_FULL: u32 = 4294967179;
pub const CX_NO_RESIDUE: u32 = 4294967180;
pub const CX_EC_INFINITE_POINT: u32 = 4294967105;
pub const CX_EC_INVALID_POINT: u32 = 4294967202;
pub const CX_EC_INVALID_CURVE: u32 = 4294967203;
pub const CX_AES_BLOCK_SIZE: u32 = 16;
pub const CX_AES_128_KEY_LEN: u32 = 16;
pub const CX_DES_BLOCK_SIZE: u32 = 8;
pub const CX_BN_WORD_ALIGNEMENT: u32 = 16;
pub const CX_BN_FLAG_UNSET: u32 = 128;
pub const CX_MAX_DOMAIN_LENGTH: u32 = 66;
pub const CX_ECCINFO_PARITY_ODD: u32 = 1;
pub const CX_ECCINFO_xGTn: u32 = 2;
pub const CX_LAST: u32 = 1;
pub const CX_SIG_MODE: u32 = 2;
pub const CX_MASK_SIGCRYPT: u32 = 6;
pub const CX_ENCRYPT: u32 = 4;
pub const CX_DECRYPT: u32 = 0;
pub const CX_SIGN: u32 = 6;
pub const CX_VERIFY: u32 = 2;
pub const CX_MASK_PAD: u32 = 56;
pub const CX_PAD_NONE: u32 = 0;
pub const CX_PAD_ISO9797M1: u32 = 8;
pub const CX_PAD_ISO9797M2: u32 = 16;
pub const CX_PAD_PKCS1_1o5: u32 = 24;
pub const CX_PAD_PKCS1_PSS: u32 = 32;
pub const CX_PAD_PKCS1_OAEP: u32 = 40;
pub const CX_MASK_CHAIN: u32 = 448;
pub const CX_CHAIN_ECB: u32 = 0;
pub const CX_CHAIN_CBC: u32 = 64;
pub const CX_CHAIN_CTR: u32 = 128;
pub const CX_CHAIN_CFB: u32 = 192;
pub const CX_CHAIN_OFB: u32 = 256;
pub const CX_MASK_ECC_VARIANT: u32 = 448;
pub const CX_NO_CANONICAL: u32 = 64;
pub const CX_MASK_RND: u32 = 3584;
pub const CX_RND_PRNG: u32 = 512;
pub const CX_RND_TRNG: u32 = 1024;
pub const CX_RND_RFC6979: u32 = 1536;
pub const CX_RND_PROVIDED: u32 = 2048;
pub const CX_MASK_EC: u32 = 28672;
pub const CX_ECSCHNORR_BIP0340: u32 = 0;
pub const CX_ECDH_POINT: u32 = 4096;
pub const CX_ECDH_X: u32 = 8192;
pub const CX_ECSCHNORR_ISO14888_XY: u32 = 12288;
pub const CX_ECSCHNORR_ISO14888_X: u32 = 16384;
pub const CX_ECSCHNORR_BSI03111: u32 = 20480;
pub const CX_ECSCHNORR_LIBSECP: u32 = 24576;
pub const CX_ECSCHNORR_Z: u32 = 28672;
pub const CX_NO_REINIT: u32 = 32768;
pub const APPLICATION_FLAG_MAIN: u32 = 1;
pub const APPLICATION_FLAG_BOLOS_UPGRADE: u32 = 2;
pub const APPLICATION_FLAG_SIGNED: u32 = 4;
pub const APPLICATION_FLAG_BOLOS_UX: u32 = 8;
pub const APPLICATION_FLAG_DERIVE_MASTER: u32 = 16;
pub const APPLICATION_FLAG_SHARED_NVRAM: u32 = 32;
pub const APPLICATION_FLAG_GLOBAL_PIN: u32 = 64;
pub const APPLICATION_FLAG_DEBUG: u32 = 128;
pub const APPLICATION_FLAG_AUTOBOOT: u32 = 256;
pub const APPLICATION_FLAG_BOLOS_SETTINGS: u32 = 512;
pub const APPLICATION_FLAG_CUSTOM_CA: u32 = 1024;
pub const APPLICATION_FLAG_LIBRARY: u32 = 2048;
pub const APPLICATION_FLAG_NO_RUN: u32 = 4096;
pub const APPLICATION_FLAG_ISSUER: u32 = 16384;
pub const APPLICATION_FLAG_ENABLED: u32 = 32768;
pub const APPLICATION_FLAG_BACKGROUND_IMG: u32 = 65536;
pub const APPLICATION_FLAG_AEM_PIN: u32 = 8;
pub const APPLICATION_FLAGS_MASK: u32 = 65535;
pub const APPLICATION_FLAG_NEG_MASK: u32 = 4294901760;
pub const APPLICATION_FLAGS_SHIFT: u32 = 16;
pub const ERR_IOL_RANGE: u32 = 4096;
pub const ERR_TSK_RANGE: u32 = 8192;
pub const ERR_CRY_RANGE: u32 = 12288;
pub const ERR_PAR_RANGE: u32 = 16384;
pub const ERR_SEC_RANGE: u32 = 20480;
pub const ERR_APD_RANGE: u32 = 24576;
pub const ERR_MUI_RANGE: u32 = 40960;
pub const ERR_APP_RANGE_01: u32 = 45056;
pub const ERR_APP_RANGE_02: u32 = 49152;
pub const ERR_APP_RANGE_03: u32 = 53248;
pub const ERR_APP_RANGE_04: u32 = 57344;
pub const ERR_GEN_SUB_01: u32 = 256;
pub const ERR_GEN_SUB_02: u32 = 512;
pub const ERR_GEN_SUB_03: u32 = 768;
pub const ERR_GEN_SUB_04: u32 = 1024;
pub const ERR_GEN_SUB_05: u32 = 1280;
pub const ERR_GEN_SUB_06: u32 = 1536;
pub const ERR_GEN_SUB_07: u32 = 1792;
pub const ERR_GEN_SUB_08: u32 = 2048;
pub const ERR_GEN_SUB_09: u32 = 2304;
pub const ERR_GEN_SUB_0D: u32 = 3328;
pub const ERR_GEN_SUB_0E: u32 = 3584;
pub const ERR_IOL_OFW: u32 = 4352;
pub const ERR_IOL_HDR: u32 = 4608;
pub const ERR_IOL_STA: u32 = 4864;
pub const ERR_IOL_RST: u32 = 5120;
pub const ERR_TSK_STC: u32 = 8448;
pub const ERR_TSK_OWN: u32 = 8704;
pub const ERR_TSK_OFW: u32 = 8960;
pub const ERR_CRY_LEN: u32 = 12544;
pub const ERR_CRY_VAL: u32 = 12800;
pub const ERR_PAR_LEN: u32 = 16640;
pub const ERR_PAR_VAL: u32 = 16896;
pub const ERR_SEC_APP: u32 = 20736;
pub const ERR_SEC_CRC: u32 = 20992;
pub const ERR_SEC_CHK: u32 = 21248;
pub const ERR_SEC_KEY: u32 = 21504;
pub const ERR_SEC_PIN: u32 = 21760;
pub const ERR_SEC_SCP: u32 = 22016;
pub const ERR_SEC_SIG: u32 = 22272;
pub const ERR_SEC_MEM: u32 = 22528;
pub const ERR_SEC_STA: u32 = 22784;
pub const ERR_APD_CLA: u32 = 28160;
pub const ERR_APD_INS: u32 = 27904;
pub const ERR_APD_HDR: u32 = 25856;
pub const ERR_APD_STA: u32 = 26112;
pub const ERR_APD_LEN: u32 = 26368;
pub const ERR_APD_DAT: u32 = 26624;
pub const SWO_SUCCESS: u32 = 36864;
pub const SWO_OK: u32 = 0;
pub const SWO_KO: u32 = 1;
pub const EXCEPTION: u32 = 1;
pub const INVALID_PARAMETER: u32 = 2;
pub const EXCEPTION_SECURITY: u32 = 3;
pub const INVALID_STATE: u32 = 4;
pub const EXCEPTION_IO_RESET: u32 = 5;
pub const NOT_ENOUGH_SPACE: u32 = 6;
pub const EXCEPTION_OVERFLOW: u32 = 7;
pub const INVALID_CRC: u32 = 8;
pub const INVALID_CHECKSUM: u32 = 9;
pub const INVALID_COUNTER: u32 = 10;
pub const NOT_SUPPORTED: u32 = 11;
pub const TIMEOUT: u32 = 12;
pub const EXCEPTION_PIC: u32 = 13;
pub const EXCEPTION_APPEXIT: u32 = 14;
pub const EXCEPTION_IO_OVERFLOW: u32 = 15;
pub const EXCEPTION_IO_HEADER: u32 = 16;
pub const EXCEPTION_IO_STATE: u32 = 17;
pub const EXCEPTION_CXPORT: u32 = 18;
pub const EXCEPTION_SYSTEM: u32 = 19;
pub const OS_PARSE_BERTLV_OFFSET_COMPARE_WITH_BUFFER: u32 = 2147483648;
pub const OS_PARSE_BERTLV_OFFSET_GET_LENGTH: u32 = 1073741824;
pub const CX_HASH_MAX_BLOCK_COUNT: u32 = 65535;
pub const CX_RIPEMD160_SIZE: u32 = 20;
pub const CX_SHA256_SIZE: u32 = 32;
pub const CX_SHA384_SIZE: u32 = 48;
pub const CX_SHA512_SIZE: u32 = 64;
pub const MAX_IV_LENGTH: u32 = 16;
pub const MAX_BLOCK_LENGTH: u32 = 16;
pub type __int8_t = cty::c_schar;
pub type __uint8_t = cty::c_uchar;
pub type __int16_t = cty::c_short;
pub type __uint16_t = cty::c_ushort;
pub type __int32_t = cty::c_int;
pub type __uint32_t = cty::c_uint;
pub type __int64_t = cty::c_longlong;
pub type __uint64_t = cty::c_ulonglong;
pub type __int_least8_t = cty::c_schar;
pub type __uint_least8_t = cty::c_uchar;
pub type __int_least16_t = cty::c_short;
pub type __uint_least16_t = cty::c_ushort;
pub type __int_least32_t = cty::c_int;
pub type __uint_least32_t = cty::c_uint;
pub type __int_least64_t = cty::c_longlong;
pub type __uint_least64_t = cty::c_ulonglong;
pub type __intmax_t = cty::c_longlong;
pub type __uintmax_t = cty::c_ulonglong;
pub type __intptr_t = cty::c_int;
pub type __uintptr_t = cty::c_uint;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = cty::c_schar;
pub type uint_fast8_t = cty::c_uchar;
pub type int_fast16_t = cty::c_short;
pub type uint_fast16_t = cty::c_ushort;
pub type int_fast32_t = cty::c_int;
pub type uint_fast32_t = cty::c_uint;
pub type int_fast64_t = cty::c_longlong;
pub type uint_fast64_t = cty::c_ulonglong;
pub type wchar_t = cty::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: cty::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::core::mem::MaybeUninit<max_align_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<max_align_t>(),
        16usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<max_align_t>(),
        8usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
#[doc = " Type of error code"]
pub type cx_err_t = u32;
#[doc = " @brief   AES key container.\n\n @details Such container should be initialized with #cx_aes_init_key_no_throw."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cx_aes_key_s {
    #[doc = "< key size"]
    pub size: usize,
    #[doc = "< key value"]
    pub keys: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_cx_aes_key_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_aes_key_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_aes_key_s>(),
        36usize,
        concat!("Size of: ", stringify!(cx_aes_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_aes_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_aes_key_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_aes_key_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keys) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_aes_key_s),
            "::",
            stringify!(keys)
        )
    );
}
#[doc = " @brief   AES key container.\n\n @details Such container should be initialized with #cx_aes_init_key_no_throw."]
pub type cx_aes_key_t = cx_aes_key_s;
extern "C" {
    #[doc = " @brief   Sets an AES key in hardware.\n\n @param[in] key AES key.\n\n @param[in] mode Operation for which the key will be used.\n\n @return         Error code:\n                 - CX_OK on success\n                 - CX_INVALID_PARAMETER"]
    pub fn cx_aes_set_key_hw(key: *const cx_aes_key_t, mode: u32) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Resets the AES context."]
    pub fn cx_aes_reset_hw();
}
extern "C" {
    #[doc = " @brief   Encrypts or decrypts a block with AES.\n\n @param[in]  inblock  Pointer to the block.\n\n @param[out] outblock Buffer for the output.\n\n @return              Error code:\n                      - CX_OK on success\n                      - INVALID_PARAMETER"]
    pub fn cx_aes_block_hw(inblock: *const cty::c_uchar, outblock: *mut cty::c_uchar) -> cx_err_t;
}
#[doc = " @brief   DES key container.\n\n  @details DES key container.\n           Such container should be initialized with **cx_des_init_key_no_throw**.\n           8 bytes (simple DES), 16 bytes (triple DES with 2 keys) and 24 bytes\n           (triple DES with 3 keys) are supported."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cx_des_key_s {
    #[doc = "< key size"]
    pub size: u8,
    #[doc = "< key value"]
    pub keys: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_cx_des_key_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_des_key_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_des_key_s>(),
        25usize,
        concat!("Size of: ", stringify!(cx_des_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_des_key_s>(),
        1usize,
        concat!("Alignment of ", stringify!(cx_des_key_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_des_key_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keys) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_des_key_s),
            "::",
            stringify!(keys)
        )
    );
}
#[doc = " @brief   DES key container.\n\n  @details DES key container.\n           Such container should be initialized with **cx_des_init_key_no_throw**.\n           8 bytes (simple DES), 16 bytes (triple DES with 2 keys) and 24 bytes\n           (triple DES with 3 keys) are supported."]
pub type cx_des_key_t = cx_des_key_s;
extern "C" {
    #[doc = " @brief   Sets a DES key in hardware.\n\n @param[in] keys DES key.\n\n @param[in] mode Operation for which the key will be used.\n\n @return         Error code:\n                 - CX_OK on success\n                 - INVALID_PARAMETER"]
    pub fn cx_des_set_key_hw(keys: *const cx_des_key_t, mode: u32) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Resets the DES context."]
    pub fn cx_des_reset_hw();
}
extern "C" {
    #[doc = " @brief   Encrypts or decrypts a block with DES.\n\n @param[in]  inblock  Pointer to the block.\n\n @param[out] outblock Buffer for the output."]
    pub fn cx_des_block_hw(inblock: *const cty::c_uchar, outblock: *mut cty::c_uchar);
}
#[doc = " Index of a big number."]
pub type cx_bn_t = u32;
#[doc = " @brief Montgomery context."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cx_bn_mont_ctx_t {
    #[doc = "< @private Modulus"]
    pub n: cx_bn_t,
    #[doc = "< @private Second Montgomery constant"]
    pub h: cx_bn_t,
}
#[test]
fn bindgen_test_layout_cx_bn_mont_ctx_t() {
    const UNINIT: ::core::mem::MaybeUninit<cx_bn_mont_ctx_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_bn_mont_ctx_t>(),
        8usize,
        concat!("Size of: ", stringify!(cx_bn_mont_ctx_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_bn_mont_ctx_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_bn_mont_ctx_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_bn_mont_ctx_t),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_bn_mont_ctx_t),
            "::",
            stringify!(h)
        )
    );
}
extern "C" {
    #[doc = " @brief   Locks the BN processor.\n\n @details The memory is reset then the word size is set.\n          Once locked the memory can be used.\n\n @param[in] word_nbytes  Word size in byte, the size of the parameters will be a multiple\n                         of *word_nbytes*.\n                         This size must be a multiple of CX_BN_WORD_ALIGNEMENT.\n @param[in] flags        Flags.\n\n @return                 Error code:\n                         - CX_OK on success\n                         - CX_BN_LOCKED if already locked."]
    pub fn cx_bn_lock(word_nbytes: usize, flags: u32) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Releases the BN lock.\n\n @details It erases all content data.\n          Once unlocked the memory cannot be used anymore.\n\n @return  Error code:\n          - CX_OK on success\n          - CX_BN_NOT_LOCKED if not locked"]
    pub fn cx_bn_unlock() -> u32;
}
extern "C" {
    #[doc = " @brief   Checks whether the BN processor is currently locked.\n\n @details The memory can be used only if the BN processor is locked.\n\n @return  1 if locked, 0 otherwise."]
    pub fn cx_bn_is_locked() -> bool;
}
extern "C" {
    #[doc = " @brief   Ascertains whether the BN processor is currently locked.\n\n @details If the BN processor is not locked the memory\n          cannot be used.\n\n @return  Error code:\n         - CX_OK on success\n         - CX_NOT_LOCKED"]
    pub fn cx_bn_locked() -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Allocates memory for a new BN.\n\n @details The specified number of bytes is the minimal required bytes,\n          the number of words allocated will be automatically a multiple\n          of the configured word size. At this moment the BN value is set\n          to 0.\n\n @param[in] x        Pointer to a BN.\n\n @param[in] nbytes   Number of bytes of x.\n\n @return             Error code:\n                     - CX_OK on success\n                     - CX_BN_MEMORY_FULL\n                     - CX_BN_INVALID_PARAMETER_SIZE"]
    pub fn cx_bn_alloc(x: *mut cx_bn_t, nbytes: usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Allocates memory for a new BN and\n          initializes it with the specified value.\n\n @details The specified number of bytes is the minimal required bytes,\n          the number of words allocated will be automatically a multiple\n          of the configured word size.\n\n @param[in] x            Pointer to a BN.\n\n @param[in] nbytes       Number of bytes of x.\n\n @param[in] value        Pointer to the value used to initialize the BN.\n\n @param[in] value_nbytes Number of bytes of value.\n\n @return                 Error code:\n                         - CX_OK on success\n                         - CX_BN_MEMORY_FULL\n                         - CX_BN_INVALID_PARAMETER_SIZE"]
    pub fn cx_bn_alloc_init(
        x: *mut cx_bn_t,
        nbytes: usize,
        value: *const u8,
        value_nbytes: usize,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Releases a BN and gives back its attached memory to the system.\n\n @param[in] x BN to release. If NULL, nothing is done.\n\n @return      Error code:\n              - CX_OK on success\n              - CX_BN_INVALID_PARAMETER_SIZE\n              - CX_BN_INVALID_PARAMETER_VALUE"]
    pub fn cx_bn_destroy(x: *mut cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Gets the size in bytes of a BN.\n\n @param[in]  x      BN index.\n\n @param[out] nbytes Returned number of bytes.\n\n @return            Error code:\n                    - CX_OK on success\n                    - CX_BN_INVALID_PARAMETER"]
    pub fn cx_bn_nbytes(x: cx_bn_t, nbytes: *mut usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Iinitializes a BN with an unsigned value.\n\n @param[in] x              BN index.\n\n @param[in] value          Pointer to the value in big-endian order.\n\n @param[in] value_nbytes   Number of bytes of the value.\n\n @return                   Error code:\n                           - CX_OK on success\n                           - CX_BN_INVALID_PARAMETER_SIZE\n                           - CX_BN_INVALID_PARAMETER_VALUE"]
    pub fn cx_bn_init(x: cx_bn_t, value: *const u8, value_nbytes: usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Generates a random number and\n          stores it in the given index.\n\n @param[in] x BN index.\n\n @return      Error code:\n              - CX_OK on success\n              - CX_BN_INVALID_PARAMETER_VALUE"]
    pub fn cx_bn_rand(x: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Copies the BN value.\n\n @param[out] a BN destination index.\n\n @param[in]  b BN source index.\n\n @return       Error code:\n               - CX_OK on success\n               - CX_BN_INVALID_PARAMETER_SIZE\n               - CX_BN_INVALID_PARAMETER_VALUE"]
    pub fn cx_bn_copy(a: cx_bn_t, b: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Sets the value of a BN with a 32-bit unsigned value.\n\n @param[in] x BN index.\n\n @param[in] n 32-bit value to be assigned.\n\n @return      Error code:\n              - CX_OK on success\n              - CX_NOT_LOCKED\n              - CX_INVALID_PARAMETER"]
    pub fn cx_bn_set_u32(x: cx_bn_t, n: u32) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Gets the 32-bit value corresponding to a BN.\n\n @param[in]  x BN index.\n\n @param[out] n Stored 32-bit unsigned value.\n\n @return       Error code:\n               - CX_OK on success\n               - CX_NOT_LOCKED\n               - CX_INVALID_PARAMETER"]
    pub fn cx_bn_get_u32(x: cx_bn_t, n: *mut u32) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Stores (serializes) a BN value as\n          unsigned raw bytes in big-endian order.\n\n @details Only the least significant *nbytes* bytes of the BN are serialized\n          If *nbytes* is greater than the BN size, *x* is serialized right aligned\n          and zero left-padded.\n\n @param[in]  x       BN index.\n\n @param[out] bytes   Buffer where to store the serialized number.\n\n @param[in]  nbytes  Number of bytes to store into the buffer.\n\n @return             Error code:\n                     - CX_OK on success\n                     - CX_BN_INVALID_PARAMETER_SIZE\n                     - CX_BN_INVALID_PARAMETER_VALUE"]
    pub fn cx_bn_export(x: cx_bn_t, bytes: *mut u8, nbytes: usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Compares two BN values.\n\n @param[in]  a    BN index to the first value to be compared.\n\n @param[in]  b    BN index to the second value to be compared.\n\n @param[out] diff Result of the comparison:\n                  - 0 if the numbers are equal.\n                  - > 0 if the first number is greater than the second\n                  - < 0 if the first number is smaller than the second\n\n @return          Error code:\n                  - CX_OK on success\n                  - CX_NOT_LOCKED\n                  - CX_INVALID_PARAMETER"]
    pub fn cx_bn_cmp(a: cx_bn_t, b: cx_bn_t, diff: *mut cty::c_int) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Compares a BN value with an unsigned integer.\n\n @param[in]  a    BN index to the value to be compared.\n\n @param[in]  b    Integer to be compared.\n\n @param[out] diff Result of the comparison:\n                  - 0 if the numbers are equal.\n                  - > 0 if the BN value is greater\n                  - < 0 if the BN value is smaller\n\n @return          Error code:\n                  - CX_OK on success\n                  - CX_NOT_LOCKED\n                  - CX_INVALID_PARAMETER"]
    pub fn cx_bn_cmp_u32(a: cx_bn_t, b: u32, diff: *mut cty::c_int) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Tests whether a BN value is odd.\n\n @param[in]  n    BN index.\n\n @param[out] odd  Boolean which indicates the parity of the BN value:\n                  - 1 if odd\n                  - 0 if even\n\n @return          Error code:\n                  - CX_OK on success\n                  - CX_NOT_LOCKED\n                  - CX_INVALID_PARAMETER"]
    pub fn cx_bn_is_odd(n: cx_bn_t, odd: *mut bool) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Performs the bitwise 'exclusive-OR' of two BN values.\n\n @details *r* must be distinct from *a* and *b*.\n\n @param[out] r BN index for the result.\n\n @param[in]  a BN index of the first operand.\n\n @param[in]  b BN index of the second operand.\n\n @return       Error code:\n               - CX_OK on success\n               - CX_NOT_LOCKED\n               - CX_INVALID_PARAMETER"]
    pub fn cx_bn_xor(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Performs the bitwise 'OR' of two BN values.\n\n @details *r* must be distinct from *a* and *b*.\n\n @param[out] r BN index for the result.\n\n @param[in]  a BN index of the first operand.\n\n @param[in]  b BN index of the second operand.\n\n @return       Error code:\n               - CX_OK on success\n               - CX_NOT_LOCKED\n               - CX_INVALID_PARAMETER"]
    pub fn cx_bn_or(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Performs the bitwise 'AND' of two BN values.\n\n @details *r* must be distinct from *a* and *b*.\n\n @param[out] r BN index for the result.\n\n @param[in]  a BN index of the first operand.\n\n @param[in]  b BN index of the second operand.\n\n @return       Error code:\n               - CX_OK on success\n               - CX_NOT_LOCKED\n               - CX_INVALID_PARAMETER"]
    pub fn cx_bn_and(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Tests the bit value at the specified index.\n\n @details The BN value is in big endian order, thus the\n          position 0 corresponds to the least significant bit.\n\n @param[in]  x    BN index.\n\n @param[in]  pos  Position of the bit.\n\n @param[out] set  Boolean which indicates the bit value\n                  - 1 if the bit is set\n                  - 0 otherwise\n\n @return          Error code:\n                  - CX_OK on success\n                  - CX_NOT_LOCKED\n                  - CX_INVALID_PARAMETER"]
    pub fn cx_bn_tst_bit(x: cx_bn_t, pos: u32, set: *mut bool) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Sets the bit value at the specified index.\n\n @details The BN value is in big endian order, thus the\n          position 0 corresponds to the least significant bit.\n\n @param[in]  x    BN index.\n\n @param[in]  pos  Position of the bit.\n\n @return          Error code:\n                  - CX_OK on success\n                  - CX_NOT_LOCKED\n                  - CX_INVALID_PARAMETER"]
    pub fn cx_bn_set_bit(x: cx_bn_t, pos: u32) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Clears the bit value at the specified index.\n\n @details The BN value is in big endian order, thus the\n          position 0 corresponds to the least significant bit.\n\n @param[in]  x    BN index.\n\n @param[in]  pos  Position of the bit.\n\n @return          Error code:\n                  - CX_OK on success\n                  - CX_NOT_LOCKED\n                  - CX_INVALID_PARAMETER"]
    pub fn cx_bn_clr_bit(x: cx_bn_t, pos: u32) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Performs a right shift.\n\n @param[in]  x  BN index.\n\n @param[in]  n  Number of bits to shift.\n\n @return        Error code:\n                - CX_OK on success\n                - CX_NOT_LOCKED\n                - CX_INVALID_PARAMETER"]
    pub fn cx_bn_shr(x: cx_bn_t, n: u32) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Performs a left shift.\n\n @param[in]  x  BN index.\n\n @param[in]  n  Number of bits to shift.\n\n @return        Error code:\n                - CX_OK on success\n                - CX_NOT_LOCKED\n                - CX_INVALID_PARAMETER"]
    pub fn cx_bn_shl(x: cx_bn_t, n: u32) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Counts the number of bits set to 1 of the BN value.\n\n @param[in]  n      BN index.\n\n @param[out] nbits  Number of bits set.\n\n @return            Error code:\n                    - CX_OK on success\n                    - CX_NOT_LOCKED\n                    - CX_INVALID_PARAMETER"]
    pub fn cx_bn_cnt_bits(n: cx_bn_t, nbits: *mut u32) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Performs an addition **r = a + b**.\n\n @details *r*, *a* and *b* shall have the same BN size.\n\n @param[out] r BN index for the result.\n\n @param[in]  a BN index of the first operand.\n\n @param[in]  b BN index of the second operand.\n\n @return       Error code:\n               - CX_OK or CX_CARRY on success\n               - CX_NOT_LOCKED\n               - CX_INVALID_PARAMETER"]
    pub fn cx_bn_add(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Performs a subtraction **r = a - b**.\n\n @details *r*, *a* and *b* shall have the same BN size.\n\n @param[out] r BN index for the result.\n\n @param[in]  a BN index of the first operand.\n\n @param[in]  b BN index of the second operand.\n\n @return       Error code:\n               - CX_OK or CX_CARRY on success\n               - CX_NOT_LOCKED\n               - CX_INVALID_PARAMETER"]
    pub fn cx_bn_sub(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Performs a multiplication **r = a * b**.\n\n @details *a* and *b* shall have the same BN size.\n          The size of *r* must be the size of *a*\n          + the size of *b*.\n\n @param[out] r BN index for the result.\n\n @param[in]  a BN index of the first operand.\n\n @param[in]  b BN index of the second operand.\n\n @return       Error code:\n               - CX_OK on success\n               - CX_NOT_LOCKED\n               - CX_INVALID_PARAMETER"]
    pub fn cx_bn_mul(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Performs a modular addition **r = a + b mod n**.\n\n @details *r*, *a*, *b* and *n* shall have the same BN size.\n          The values of *a* and *b* must be strictly smaller\n          than modulus value.\n\n @param[out] r BN index for the result.\n\n @param[in]  a BN index of the first operand.\n\n @param[in]  b BN index of the second operand.\n\n @param[in]  n BN index of the modulus.\n\n @return       Error code:\n               - CX_OK on success\n               - CX_NOT_LOCKED\n               - CX_INVALID_PARAMETER\n               - CX_MEMORY_FULL"]
    pub fn cx_bn_mod_add(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Performs a modular subtraction **r = a - b mod n**.\n\n @details *r*, *a*, *b* and *n* shall have the same BN size.\n          The values of *a* and *b* must be strictly smaller\n          than modulus value.\n\n @param[out] r BN index for the result.\n\n @param[in]  a BN index of the first operand.\n\n @param[in]  b BN index of the second operand.\n\n @param[in]  n BN index of the modulus.\n\n @return       Error code:\n               - CX_OK on success\n               - CX_NOT_LOCKED\n               - CX_INVALID_PARAMETER\n               - CX_MEMORY_FULL"]
    pub fn cx_bn_mod_sub(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Performs a modular multiplication **r = a * b mod n**.\n\n @details *r*, *a*, *b* and *n* shall have the same BN size.\n          The value of b must be strictly smaller\n          than modulus value.\n\n @param[out] r BN index for the result.\n\n @param[in]  a BN index of the first operand.\n\n @param[in]  b BN index of the second operand.\n\n @param[in]  n BN index of the modulus.\n\n @return       Error code:\n               - CX_OK on success\n               - CX_NOT_LOCKED\n               - CX_INVALID_PARAMETER\n               - CX_INVALID_PARAMETER_VALUE\n               - CX_MEMORY_FULL"]
    pub fn cx_bn_mod_mul(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Performs a reduction **r = d mod n**.\n\n @details *r* and *n* shall have the same BN size.\n\n @param[out] r BN index for the result.\n\n @param[in]  d BN index of the value to be reduced.\n\n @param[in]  n BN index of the modulus.\n\n @return       Error code:\n               - CX_OK on success\n               - CX_NOT_LOCKED\n               - CX_INVALID_PARAMETER\n               - CX_MEMORY_FULL"]
    pub fn cx_bn_reduce(r: cx_bn_t, d: cx_bn_t, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Computes *r* such that **r² = a mod n** if *a* is a quadratic residue.\n\n @details This returns an error if the given number is not a quadratic residue.\n          *r*, *a* and *n* shall have the same BN size.\n\n @param[out] r    BN index for the result.\n\n @param[in]  a    BN index of the quadratic residue or quadratic non residue.\n\n @param[in]  n    BN index of the modulus.\n\n @param[in]  sign Sign of the result.\n\n @return          Error code:\n                  - CX_OK on success\n                  - CX_NOT_LOCKED\n                  - CX_INVALID_PARAMETER\n                  - CX_MEMORY_FULL\n                  - CX_NO_RESIDUE"]
    pub fn cx_bn_mod_sqrt(r: cx_bn_t, a: cx_bn_t, n: cx_bn_t, sign: u32) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Performs a modular exponentiation **r = a^e mod n**.\n\n @details *r*, *a* and *n* shall have the same BN size.\n          *r*, *a* and *n* must be different.\n\n @param[out] r BN index for the result.\n\n @param[in]  a BN index of the base of the exponentiation.\n\n @param[in]  e BN index of the exponent.\n\n @param[in]  n BN index of the modulus.\n\n @return       Error code:\n               - CX_OK on success\n               - CX_NOT_LOCKED\n               - CX_INVALID_PARAMETER\n               - CX_MEMORY_FULL"]
    pub fn cx_bn_mod_pow_bn(r: cx_bn_t, a: cx_bn_t, e: cx_bn_t, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Performs a modular exponentiation **r = a^e mod n**.\n\n @details *r*, *a* and *n* shall have the same BN size.\n          *r*, *a* and *n* must be different.\n\n @param[out] r     BN index for the result.\n\n @param[in]  a     BN index of the base of the exponentiation.\n\n @param[in]  e     Pointer to the exponent.\n\n @param[in]  e_len Length of the exponent buffer.\n\n @param[in]  n     BN index of the modulus.\n\n @return           Error code:\n                   - CX_OK on success\n                   - CX_NOT_LOCKED\n                   - CX_INVALID_PARAMETER\n                   - CX_MEMORY_FULL"]
    pub fn cx_bn_mod_pow(r: cx_bn_t, a: cx_bn_t, e: *const u8, e_len: u32, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Performs a modular exponentiation **r = a^e mod n**.\n\n @details This function reuses the parameter *a* for intermediate computations,\n          hence requires less memory.\n          *r*, *a* and *n* shall have the same BN size.\n          *r*, *a* and *n* must be different.\n\n @param[out] r     BN index for the result.\n\n @param[in]  a     BN index of the base of the exponentiation.\n                   The BN value is modified during the\n                   computations.\n\n @param[in]  e     Pointer to the exponent.\n\n @param[in]  e_len Length of the exponent buffer.\n\n @param[in]  n     BN index of the modulus.\n\n @return           Error code:\n                   - CX_OK on success\n                   - CX_NOT_LOCKED\n                   - CX_INVALID_PARAMETER\n                   - CX_MEMORY_FULL"]
    pub fn cx_bn_mod_pow2(r: cx_bn_t, a: cx_bn_t, e: *const u8, e_len: u32, n: cx_bn_t)
        -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Computes the modular inverse **r = a^(-1) mod n**,\n          for a prime *n*.\n\n @details *r*, *a* and *n* shall have the same BN size. *n* must be prime.\n\n @param[out] r BN index for the result.\n\n @param[in]  a BN index of the value to be inverted.\n\n @param[in]  n BN index of the modulus.\n\n @return       Error code:\n               - CX_OK on success\n               - CX_NOT_LOCKED\n               - CX_INVALID_PARAMETER\n               - CX_MEMORY_FULL"]
    pub fn cx_bn_mod_invert_nprime(r: cx_bn_t, a: cx_bn_t, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Computes the modular inverse **r = a^(-1) mod n**,\n          of a 32-bit value.\n\n @details *r* and *n* shall have the same BN size.\n          The parameter *n* is destroyed and contains zero\n          after the function returns.\n\n @param[out] r BN index for the result.\n\n @param[in]  a 32-bit value to be inverted.\n\n @param[in]  n BN index of the modulus.\n\n @return       Error code:\n               - CX_OK on success\n               - CX_NOT_LOCKED\n               - CX_INVALID_PARAMETER\n               - CX_MEMORY_FULL\n               - CX_INTERNAL_ERROR\n               - CX_NOT_INVERTIBLE"]
    pub fn cx_bn_mod_u32_invert(r: cx_bn_t, a: u32, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Allocates memory for the Montgomery context.\n\n @param[in] ctx    Pointer to the Montgomery context.\n\n @param[in] length BN size for the context fields.\n\n @return           Error code:\n                   - CX_OK on success\n                   - CX_NOT_LOCKED\n                   - CX_MEMORY_FULL"]
    pub fn cx_mont_alloc(ctx: *mut cx_bn_mont_ctx_t, length: usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Initializes a Montgomery context with the modulus.\n\n @details Calculate and set up the second Montgomery constant.\n\n @param[in] ctx Pointer to a Montgomery context.\n\n @param[in] n   BN index of the modulus.\n\n @return        Error code:\n                - CX_OK on success\n                - CX_NOT_LOCKED\n                - CX_INVALID_PARAMETER\n                - CX_MEMORY_FULL"]
    pub fn cx_mont_init(ctx: *mut cx_bn_mont_ctx_t, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Initializes a Montgomery context with the modulus and\n          the second Montgomery constant.\n\n @details Set up the second Montgomery constant with the given\n          parameter.\n          The caller should make sure that the given\n          second Montgomery constant is correct.\n\n @param[in] ctx Pointer to a Montgomery context.\n\n @param[in] n   BN index of the modulus.\n\n @param[in] h   BN index of the pre calculated second Montgomery constant.\n\n @return        Error code:\n                - CX_OK on success\n                - CX_NOT_LOCKED\n                - CX_INVALID_PARAMETER"]
    pub fn cx_mont_init2(ctx: *mut cx_bn_mont_ctx_t, n: cx_bn_t, h: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Computes the Montgomery representation of a BN value.\n\n @details The context must be initialized.\n\n @param[out] x   BN index for the result.\n\n @param[in]  z   BN index of the value to convert into Montgomery representation.\n\n @param[in]  ctx Pointer to the Montgomery context, initialized\n                 with the modulus and the second Montgomery constant.\n\n @return         Error code:\n                 - CX_OK on success\n                 - CX_NOT_LOCKED\n                 - CX_INVALID_PARAMETER\n                 - CX_MEMORY_FULL"]
    pub fn cx_mont_to_montgomery(x: cx_bn_t, z: cx_bn_t, ctx: *const cx_bn_mont_ctx_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Computes the normal representation of a BN value\n          given a Montgomery representation.\n\n @details The context must be initialized.\n\n @param[out] x   BN index for the result.\n\n @param[in]  z   BN index of the value to be converted.\n                 The value should be in Montgomery representation.\n\n @param[in]  ctx Pointer to the Montgomery context, initialized\n                 with the modulus and the second Montgomery constant.\n\n @return         Error code:\n                 - CX_OK on success\n                 - CX_NOT_LOCKED\n                 - CX_INVALID_PARAMETER\n                 - CX_MEMORY_FULL"]
    pub fn cx_mont_from_montgomery(
        z: cx_bn_t,
        x: cx_bn_t,
        ctx: *const cx_bn_mont_ctx_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Performs a Montgomery multiplication.\n\n @details The context must be initialized.\n\n @param[out] r   BN index for the result.\n\n @param[in]  a   BN index of the first operand in Montgomery representation.\n\n @param[in]  b   BN index of the second operand in Montgomery representation.\n\n @param[in]  ctx Pointer to the Montgomery context, initialized\n                 with the modulus and the second Montgomery constant.\n\n @return         Error code:\n                 - CX_OK on success\n                 - CX_NOT_LOCKED\n                 - CX_INVALID_PARAMETER"]
    pub fn cx_mont_mul(
        r: cx_bn_t,
        a: cx_bn_t,
        b: cx_bn_t,
        ctx: *const cx_bn_mont_ctx_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Performs a modular exponentiation **r = a^e mod n**.\n\n @details The context must be initialized. The BN value *a*\n          is in Montgomery representation.\n\n @param[out] r     BN index for the result. The result is in\n                   Montgomery representation.\n\n @param[in]  a     BN index of the exponentiation base in Montgomery\n                   representation.\n\n @param[in]  e     Pointer to the exponent.\n\n @param[in]  e_len Length of the exponent in bytes.\n\n @param[in]  ctx   Pointer to the Montgomery context, initialized\n                   with the modulus and the second Montgomery constant.\n\n @return           Error code:\n                   - CX_OK on success\n                   - CX_NOT_LOCKED\n                   - CX_INVALID_PARAMETER\n                   - CX_MEMORY_FULL"]
    pub fn cx_mont_pow(
        r: cx_bn_t,
        a: cx_bn_t,
        e: *const u8,
        e_len: u32,
        ctx: *const cx_bn_mont_ctx_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Performs a modular exponentiation **r = a^e mod n**.\n\n @details The context must be initialized. The BN value *a*\n          is in Montgomery representation.\n\n @param[out] r     BN index for the result. The result is in\n                   Montgomery representation.\n\n @param[in]  a     BN index of the exponentiation base in Montgomery\n                   representation.\n\n @param[in]  e     BN index of the exponent.\n\n @param[in]  ctx   Pointer to the Montgomery context, initialized\n                   with the modulus and the second Montgomery constant.\n\n @return           Error code:\n                   - CX_OK on success\n                   - CX_NOT_LOCKED\n                   - CX_INVALID_PARAMETER\n                   - CX_MEMORY_FULL"]
    pub fn cx_mont_pow_bn(
        r: cx_bn_t,
        a: cx_bn_t,
        e: cx_bn_t,
        ctx: *const cx_bn_mont_ctx_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Computes the modular inverse **r = a^(-1) mod n** for\n          a prime number *n*.\n\n @details The context must be initialized.\n\n @param[out] r   BN index for the result. The result is in\n                 Montgomery representation.\n\n @param[in]  a   BN index of the value to be inverted. The value\n                 is in Montgomery representation.\n\n @param[in]  ctx Pointer to the Montgomery context, initialized\n                 with the modulus and the second Montgomery constant\n\n @return         Error code:\n                 - CX_OK on success\n                 - CX_NOT_LOCKED\n                 - CX_INVALID_PARAMETER\n                 - CX_MEMORY_FULL"]
    pub fn cx_mont_invert_nprime(r: cx_bn_t, a: cx_bn_t, ctx: *const cx_bn_mont_ctx_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Tests whether a BN value is a probable prime.\n\n @param[in] n      BN index of the value.\n\n @param[out] prime Boolean which indicates whether the number is a prime:\n                   - 1 if it is a prime\n                   - 0 otherwise\n\n @return           Error code:\n                   - CX_OK on success\n                   - CX_NOT_LOCKED\n                   - CX_INVALID_PARAMETER\n                   - CX_MEMORY_FULL"]
    pub fn cx_bn_is_prime(n: cx_bn_t, prime: *mut bool) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Gets the first prime number after a\n          given BN value.\n\n @param[in, out] n BN index of the value and the result.\n\n @return           Error code:\n                   - CX_OK on success\n                   - CX_NOT_LOCKED\n                   - CX_INVALID_PARAMETER\n                   - CX_MEMORY_FULL\n                   - CX_OVERFLOW"]
    pub fn cx_bn_next_prime(n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief Generates a random number *r* in the range ]0,n[.\n\n @details *r* is such that: **0 < r < n**.\n\n @param[out] r BN index for the result.\n\n @param[in]  n BN index of the upper bound.\n\n @return       Error code:\n               - CX_OK on success\n               - CX_NOT_LOCKED\n               - CX_INVALID_PARAMETER\n               - CX_MEMORY_FULL"]
    pub fn cx_bn_rng(r: cx_bn_t, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief Performs a multiplication over GF(2^n).\n\n @param[out] bn_r BN index for the result.\n\n @param[in]  bn_a BN index of the first operand.\n\n @param[in]  bn_b BN index of the second operand.\n\n @param[in]  bn_n BN index of the modulus.\n                  The modulus must be an irreducible polynomial over GF(2)\n                  of degree n.\n\n @param[in]  bn_h BN index of the second montgomery constant.\n\n @return          Error code:\n                  - CX_OK on success\n                  - CX_NOT_LOCKED\n                  - CX_INVALID_PARAMETER\n                  - CX_MEMORY_FULL"]
    pub fn cx_bn_gf2_n_mul(
        bn_r: cx_bn_t,
        bn_a: cx_bn_t,
        bn_b: cx_bn_t,
        bn_n: cx_bn_t,
        bn_h: cx_bn_t,
    ) -> cx_err_t;
}
#[doc = " Undefined curve"]
pub const cx_curve_e_CX_CURVE_NONE: cx_curve_e = 0;
#[doc = " Low limit (not included) of Weierstrass curve ID"]
pub const cx_curve_e_CX_CURVE_WEIERSTRASS_START: cx_curve_e = 32;
#[doc = " Secp256k1"]
pub const cx_curve_e_CX_CURVE_SECP256K1: cx_curve_e = 33;
#[doc = " Secp256r1"]
pub const cx_curve_e_CX_CURVE_SECP256R1: cx_curve_e = 34;
#[doc = " Secp384r1"]
pub const cx_curve_e_CX_CURVE_SECP384R1: cx_curve_e = 35;
#[doc = " Secp521r1"]
pub const cx_curve_e_CX_CURVE_SECP521R1: cx_curve_e = 36;
#[doc = " BrainpoolP256t1"]
pub const cx_curve_e_CX_CURVE_BrainPoolP256T1: cx_curve_e = 49;
#[doc = " BrainpoolP256r1"]
pub const cx_curve_e_CX_CURVE_BrainPoolP256R1: cx_curve_e = 50;
#[doc = " BrainpoolP320t1"]
pub const cx_curve_e_CX_CURVE_BrainPoolP320T1: cx_curve_e = 51;
#[doc = " BrainpoolP320r1"]
pub const cx_curve_e_CX_CURVE_BrainPoolP320R1: cx_curve_e = 52;
#[doc = " BrainpoolP384t1"]
pub const cx_curve_e_CX_CURVE_BrainPoolP384T1: cx_curve_e = 53;
#[doc = " Brainpool384r1"]
pub const cx_curve_e_CX_CURVE_BrainPoolP384R1: cx_curve_e = 54;
#[doc = " BrainpoolP512t1"]
pub const cx_curve_e_CX_CURVE_BrainPoolP512T1: cx_curve_e = 55;
#[doc = " BrainpoolP512r1"]
pub const cx_curve_e_CX_CURVE_BrainPoolP512R1: cx_curve_e = 56;
#[doc = " BLS12-381 G1"]
pub const cx_curve_e_CX_CURVE_BLS12_381_G1: cx_curve_e = 57;
#[doc = " ANSSI FRP256"]
pub const cx_curve_e_CX_CURVE_FRP256V1: cx_curve_e = 65;
#[doc = " Stark"]
pub const cx_curve_e_CX_CURVE_Stark256: cx_curve_e = 81;
#[doc = " High limit (not included) of Weierstrass curve ID"]
pub const cx_curve_e_CX_CURVE_WEIERSTRASS_END: cx_curve_e = 111;
#[doc = " Low limit (not included) of  Twisted Edwards curve ID"]
pub const cx_curve_e_CX_CURVE_TWISTED_EDWARDS_START: cx_curve_e = 112;
#[doc = " Ed25519"]
pub const cx_curve_e_CX_CURVE_Ed25519: cx_curve_e = 113;
#[doc = " Ed448"]
pub const cx_curve_e_CX_CURVE_Ed448: cx_curve_e = 114;
#[doc = " High limit (not included) of Twisted Edwards curve ID"]
pub const cx_curve_e_CX_CURVE_TWISTED_EDWARDS_END: cx_curve_e = 127;
#[doc = " Low limit (not included) of Montgomery curve ID"]
pub const cx_curve_e_CX_CURVE_MONTGOMERY_START: cx_curve_e = 128;
#[doc = " Curve25519"]
pub const cx_curve_e_CX_CURVE_Curve25519: cx_curve_e = 129;
#[doc = " Curve448"]
pub const cx_curve_e_CX_CURVE_Curve448: cx_curve_e = 130;
#[doc = " High limit (not included) of Montgomery curve ID"]
pub const cx_curve_e_CX_CURVE_MONTGOMERY_END: cx_curve_e = 143;
#[doc = " List of supported elliptic curves"]
pub type cx_curve_e = cty::c_uint;
#[doc = " List of supported elliptic curves"]
pub use self::cx_curve_e as cx_curve_t;
#[doc = " @brief   Weierstrass curve defined by **y^3 = x^2 + a*x + b over GF(p)**.\n\n @details See #CX_CURVE_HEADER for the structure members."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_curve_weierstrass_s {
    pub curve: cx_curve_t,
    pub bit_size: cty::c_uint,
    pub length: cty::c_uint,
    pub a: *const u8,
    pub b: *const u8,
    pub p: *const u8,
    pub Gx: *const u8,
    pub Gy: *const u8,
    pub n: *const u8,
    pub h: *const u8,
    pub Hn: *const u8,
    pub Hp: *const u8,
}
#[test]
fn bindgen_test_layout_cx_curve_weierstrass_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_curve_weierstrass_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_curve_weierstrass_s>(),
        48usize,
        concat!("Size of: ", stringify!(cx_curve_weierstrass_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_curve_weierstrass_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_curve_weierstrass_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(bit_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Gx) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(Gx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Gy) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(Gy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Hn) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(Hn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Hp) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(Hp)
        )
    );
}
impl Default for cx_curve_weierstrass_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief   Weierstrass curve defined by **y^3 = x^2 + a*x + b over GF(p)**.\n\n @details See #CX_CURVE_HEADER for the structure members."]
pub type cx_curve_weierstrass_t = cx_curve_weierstrass_s;
#[doc = " @brief   Twisted Edwards curve defined by **a*x^2 + y^2 = 1 + d*x2*y2 over GF(q)**.\n\n @details See #CX_CURVE_HEADER for the structure members."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_curve_twisted_edwards_s {
    pub curve: cx_curve_t,
    pub bit_size: cty::c_uint,
    pub length: cty::c_uint,
    pub a: *const u8,
    pub b: *const u8,
    pub p: *const u8,
    pub Gx: *const u8,
    pub Gy: *const u8,
    pub n: *const u8,
    pub h: *const u8,
    pub Hn: *const u8,
    pub Hp: *const u8,
}
#[test]
fn bindgen_test_layout_cx_curve_twisted_edwards_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_curve_twisted_edwards_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_curve_twisted_edwards_s>(),
        48usize,
        concat!("Size of: ", stringify!(cx_curve_twisted_edwards_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_curve_twisted_edwards_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_curve_twisted_edwards_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(bit_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Gx) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(Gx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Gy) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(Gy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Hn) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(Hn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Hp) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(Hp)
        )
    );
}
impl Default for cx_curve_twisted_edwards_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief   Twisted Edwards curve defined by **a*x^2 + y^2 = 1 + d*x2*y2 over GF(q)**.\n\n @details See #CX_CURVE_HEADER for the structure members."]
pub type cx_curve_twisted_edwards_t = cx_curve_twisted_edwards_s;
#[doc = " @brief   Montgomery curve defined by **B*y^2= x^3 + A*x^2 + x over GF(q)**.\n\n @details See #CX_CURVE_HEADER for the structure members."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_curve_montgomery_s {
    pub curve: cx_curve_t,
    pub bit_size: cty::c_uint,
    pub length: cty::c_uint,
    pub a: *const u8,
    pub b: *const u8,
    pub p: *const u8,
    pub Gx: *const u8,
    pub Gy: *const u8,
    pub n: *const u8,
    pub h: *const u8,
    pub Hn: *const u8,
    pub Hp: *const u8,
}
#[test]
fn bindgen_test_layout_cx_curve_montgomery_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_curve_montgomery_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_curve_montgomery_s>(),
        48usize,
        concat!("Size of: ", stringify!(cx_curve_montgomery_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_curve_montgomery_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_curve_montgomery_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(bit_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Gx) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(Gx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Gy) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(Gy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Hn) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(Hn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Hp) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(Hp)
        )
    );
}
impl Default for cx_curve_montgomery_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief   Montgomery curve defined by **B*y^2= x^3 + A*x^2 + x over GF(q)**.\n\n @details See #CX_CURVE_HEADER for the structure members."]
pub type cx_curve_montgomery_t = cx_curve_montgomery_s;
#[doc = " @brief   Abstract type for elliptic curve domain.\n\n @details See #CX_CURVE_HEADER for the structure members."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_curve_domain_s {
    pub curve: cx_curve_t,
    pub bit_size: cty::c_uint,
    pub length: cty::c_uint,
    pub a: *const u8,
    pub b: *const u8,
    pub p: *const u8,
    pub Gx: *const u8,
    pub Gy: *const u8,
    pub n: *const u8,
    pub h: *const u8,
    pub Hn: *const u8,
    pub Hp: *const u8,
}
#[test]
fn bindgen_test_layout_cx_curve_domain_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_curve_domain_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_curve_domain_s>(),
        48usize,
        concat!("Size of: ", stringify!(cx_curve_domain_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_curve_domain_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_curve_domain_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(bit_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Gx) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(Gx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Gy) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(Gy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Hn) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(Hn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Hp) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(Hp)
        )
    );
}
impl Default for cx_curve_domain_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief   Abstract type for elliptic curve domain.\n\n @details See #CX_CURVE_HEADER for the structure members."]
pub type cx_curve_domain_t = cx_curve_domain_s;
#[doc = " @brief Elliptic curve point."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ec_point_s {
    #[doc = "< Point's curve"]
    pub curve: cx_curve_t,
    #[doc = "< x-coordinate in affine representation"]
    pub x: cx_bn_t,
    #[doc = "< y-coordinate in affine representation"]
    pub y: cx_bn_t,
    #[doc = "< z-coordinate = 1 in affine representation"]
    pub z: cx_bn_t,
}
#[test]
fn bindgen_test_layout_cx_ec_point_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_ec_point_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_ec_point_s>(),
        16usize,
        concat!("Size of: ", stringify!(cx_ec_point_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ec_point_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ec_point_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ec_point_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ec_point_s),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ec_point_s),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ec_point_s),
            "::",
            stringify!(z)
        )
    );
}
impl Default for cx_ec_point_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Elliptic curve point."]
pub type cx_ecpoint_t = cx_ec_point_s;
#[doc = "< No parameter"]
pub const cx_curve_dom_param_s_CX_CURVE_PARAM_NONE: cx_curve_dom_param_s = 0;
#[doc = "< First coefficient of the curve"]
pub const cx_curve_dom_param_s_CX_CURVE_PARAM_A: cx_curve_dom_param_s = 1;
#[doc = "< Second coefficient of the curve"]
pub const cx_curve_dom_param_s_CX_CURVE_PARAM_B: cx_curve_dom_param_s = 2;
#[doc = "< Curve field"]
pub const cx_curve_dom_param_s_CX_CURVE_PARAM_Field: cx_curve_dom_param_s = 3;
#[doc = "< x-coordinate of the curve's generator"]
pub const cx_curve_dom_param_s_CX_CURVE_PARAM_Gx: cx_curve_dom_param_s = 4;
#[doc = "< y-coordinate of the curve's generator"]
pub const cx_curve_dom_param_s_CX_CURVE_PARAM_Gy: cx_curve_dom_param_s = 5;
#[doc = "< Order of the generator"]
pub const cx_curve_dom_param_s_CX_CURVE_PARAM_Order: cx_curve_dom_param_s = 6;
#[doc = "< Cofactor"]
pub const cx_curve_dom_param_s_CX_CURVE_PARAM_Cofactor: cx_curve_dom_param_s = 7;
#[doc = " @brief Identifiers of the domain parameters."]
pub type cx_curve_dom_param_s = cty::c_uint;
#[doc = " @brief Identifiers of the domain parameters."]
pub use self::cx_curve_dom_param_s as cx_curve_dom_param_t;
extern "C" {
    #[doc = " @brief   Gets the bit length of each parameter of the curve.\n\n @param[in] curve   Curve identifier.\n\n @param[out] length Bit length of each parameter.\n\n @return            Error code:\n                    - CX_OK on success\n                    - CX_EC_INVALID_CURVE"]
    pub fn cx_ecdomain_size(curve: cx_curve_t, length: *mut usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Gets the byte length of each parameter of the curve.\n\n @param[in]  cv     Curve identifier.\n\n @param[out] length Byte length of each parameter.\n\n @return            Error code:\n                    - CX_OK on success\n                    - CX_EC_INVALID_CURVE"]
    pub fn cx_ecdomain_parameters_length(cv: cx_curve_t, length: *mut usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Gets a specific parameter of the curve.\n\n @param[in]  cv    Curve identifier.\n\n @param[in]  id    Parameter identifier.\n\n @param[out] p     Buffer where to store the parameter.\n\n @param[in]  p_len Length of the buffer.\n\n @return           Error code:\n                   - CX_OK on success\n                   - CX_EC_INVALID_CURVE\n                   - CX_INVALID_PARAMETER"]
    pub fn cx_ecdomain_parameter(
        cv: cx_curve_t,
        id: cx_curve_dom_param_t,
        p: *mut u8,
        p_len: u32,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Stores a specific parameter of the curve as a BN.\n\n @param[in]  cv Curve identifier.\n\n @param[in]  id Parameter identifier.\n\n @param[out] p  BN where to store the parameter.\n\n @return        Error code:\n                - CX_OK on success\n                - CX_EC_INVALID_CURVE\n                - CX_NOT_LOCKED\n                - CX_INVALID_PARAMETER\n                - CX_INVALID_PARAMETER_SIZE"]
    pub fn cx_ecdomain_parameter_bn(
        cv: cx_curve_t,
        id: cx_curve_dom_param_t,
        p: cx_bn_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Gets the generator of the curve.\n\n @param[in] cv   Curve identifier.\n\n @param[out] Gx  Buffer to store the x-coordinate of the generator.\n\n @param[out] Gy  Buffer to store the y-coordinate of the generator.\n\n @param[in]  len Byte length of each coordinate.\n\n @return         Error code:\n                 - CX_OK on success\n                 - CX_EC_INVALID_CURVE\n                 - CX_INVALID_PARAMETER"]
    pub fn cx_ecdomain_generator(cv: cx_curve_t, Gx: *mut u8, Gy: *mut u8, len: usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Gets the generator of the curve and stores it in the point structure.\n\n @param[in]  cv Curve identifier.\n\n @param[out] P  Pointer to the structure where to store the generator.\n\n @return        Error code:\n                - CX_OK on success\n                - CX_EC_INVALID_CURVE\n                - CX_NOT_LOCKED\n                - CX_INVALID_PARAMETER\n                - CX_INVALID_PARAMETER_SIZE\n                - CX_EC_INVALID_POINT"]
    pub fn cx_ecdomain_generator_bn(cv: cx_curve_t, P: *mut cx_ecpoint_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Allocates memory for a point on the curve.\n\n @param[in] P  Pointer to a point.\n\n @param[in] cv Curve on which the point is defined.\n\n @return       Error code:\n               - CX_OK on success\n               - CX_EC_INVALID_CURVE\n               - CX_NOT_LOCKED\n               - CX_INVALID_PARAMETER\n               - CX_MEMORY_FULL"]
    pub fn cx_ecpoint_alloc(P: *mut cx_ecpoint_t, cv: cx_curve_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Destroys a point on the curve.\n\n @param[in] P Pointer to the point to destroy. If the pointer is NULL,\n              nothing is done.\n\n @return      Error code:\n              - CX_OK on success\n              - CX_NOT_LOCKED\n              - CX_INVALID_PARAMETER\n              - CX_INTERNAL_ERROR"]
    pub fn cx_ecpoint_destroy(P: *mut cx_ecpoint_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Initializes a point on the curve.\n\n @param[in] P     Pointer to the point to initialize.\n\n @param[in] x     x-coordinate of the point. This must belong to the curve field.\n\n @param[in] x_len Length of the x-coordinate. This must be at most equal to the\n                  curve's domain number of bytes.\n\n @param[in] y     y-coordinate of the point. This must belong to the curve field.\n\n @param[in] y_len Length of the y-coordinate. This must be at most equal to the\n                  curve's domain number of bytes.\n\n @return          Error code:\n                  - CX_OK on success\n                  - CX_NOT_LOCKED\n                  - CX_INVALID_PARAMETER\n                  - CX_EC_INVALID_CURVE"]
    pub fn cx_ecpoint_init(
        P: *mut cx_ecpoint_t,
        x: *const u8,
        x_len: usize,
        y: *const u8,
        y_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Initializes a point on the curve with the BN indexes of the coordinates.\n\n @param[in] P Pointer to the point to initialize.\n\n @param[in] x BN index of the x-coordinate. The coordinate must\n              belong to the base field.\n\n @param[in] y BN index of the y-coordinate. The coordinate must\n              belong to the base field.\n\n @return      Error code:\n              - CX_OK on success\n              - CX_NOT_LOCKED\n              - CX_INVALID_PARAMETER\n              - CX_EC_INVALID_CURVE"]
    pub fn cx_ecpoint_init_bn(P: *mut cx_ecpoint_t, x: cx_bn_t, y: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Exports a point.\n\n @details Fills two distinct buffers with the x-coordinate and the y-coordinate\n          of the point. If the point is not in affine representation, it will\n          be normalized first.\n\n @param[in]  P     Pointer to the point to export.\n\n @param[out] x     Buffer for the x-coordinate.\n\n @param[in]  x_len Length of the *x* buffer.\n\n @param[out] y     Buffer for the y-coordinate.\n\n @param[in]  y_len Length of the *y* buffer.\n\n @return           Error code:\n                   - CX_OK on success\n                   - CX_NOT_LOCKED\n                   - CX_INVALID_PARAMETER\n                   - CX_EC_INVALID_CURVE\n                   - CX_EC_INFINITE_POINT\n                   - CX_MEMORY_FULL"]
    pub fn cx_ecpoint_export(
        P: *const cx_ecpoint_t,
        x: *mut u8,
        x_len: usize,
        y: *mut u8,
        y_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Exports a point using BN indexes of the coordinates.\n\n @param[in]  P Pointer to the point to export.\n\n @param[out] x Pointer to the BN index of the x-coordinate.\n\n @param[out] y Pointer to the BN index of the y-coordinate.\n\n @return       Error code:\n               - CX_OK on success\n               - CX_NOT_LOCKED\n               - CX_INVALID_PARAMETER\n               - CX_EC_INVALID_CURVE\n               - CX_EC_INFINITE_POINT\n               - CX_MEMORY_FULL"]
    pub fn cx_ecpoint_export_bn(
        P: *const cx_ecpoint_t,
        x: *mut cx_bn_t,
        y: *mut cx_bn_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Computes the compressed form of a point.\n\n @details The compressed form depends on the curve type.\n          For a Weierstrass or a Montgomery curve, the\n          compressed form consists of the x-coordinate and\n          a prefix. For a Twisted Edwards curve the compressed\n          form consists of a y-coordinate and a prefix.\n\n @param[in]  P                 Pointer to the point to be compressed.\n\n @param[out] xy_compressed     Buffer to hold the compressed\n                               coordinate.\n\n @param[in]  xy_compressed_len Length of the compressed coordinate in bytes.\n                               This should be equal to the length of one coordinate.\n\n @param[out] sign              Pointer to the sign of the hidden coordinate:\n                               correspond to the least significant bit of the\n                               y-coordinate for a Weierstrass or Montgomery curve\n                               and of the x-coordinate for a Twisted Edwards curve.\n\n @return                       Error code:\n                               - CX_OK on success\n                               - CX_NOT_LOCKED\n                               - CX_INVALID_PARAMETER\n                               - CX_EC_INVALID_CURVE\n                               - CX_EC_INFINITE_POINT\n                               - CX_MEMORY_FULL"]
    pub fn cx_ecpoint_compress(
        P: *const cx_ecpoint_t,
        xy_compressed: *mut u8,
        xy_compressed_len: usize,
        sign: *mut u32,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Computes the affine coordinates of a point given its compressed form.\n\n @param[out] P                 Pointer to the point.\n\n @param[in]  xy_compressed     Pointer to the buffer holding the compressed\n                               coordinate.\n\n @param[in]  xy_compressed_len Length of the compressed coordinate in bytes.\n                               This should be equal to the length of one coordinate.\n\n @param[in]  sign              Sign of the coordinate to recover.\n\n @return                       Error code:\n                               - CX_OK on success\n                               - CX_NOT_LOCKED\n                               - CX_INVALID_PARAMETER\n                               - CX_EC_INVALID_CURVE\n                               - CX_MEMORY_FULL\n                               - CX_NO_RESIDUE\n"]
    pub fn cx_ecpoint_decompress(
        P: *mut cx_ecpoint_t,
        xy_compressed: *const u8,
        xy_compressed_len: usize,
        sign: u32,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Adds two points on a curve.\n\n @details Each point should not be the point at infinity.\n          If one of the point is the point at infinity then\n          the function returns a CX_EC_INFINITE_POINT error.\n\n @param[out] R Pointer to the result point.\n\n @param[in]  P Pointer to the first point to add.\n               The point must be on the curve.\n\n @param[in]  Q Pointer to the second point to add.\n               The point must be on the curve.\n\n @return       Error code:\n               - CX_OK on success\n               - CX_NOT_LOCKED\n               - CX_INVALID_PARAMETER\n               - CX_EC_INVALID_CURVE\n               - CX_EC_INVALID_POINT\n               - CX_EC_INFINITE_POINT\n               - CX_MEMORY_FULL"]
    pub fn cx_ecpoint_add(
        R: *mut cx_ecpoint_t,
        P: *const cx_ecpoint_t,
        Q: *const cx_ecpoint_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Computes the opposite of a point.\n\n @details The point should not be the point at infinity,\n          otherwise the function returns a CX_EC_INFINITE_POINT\n          error.\n\n @param[in, out] P Pointer to a point of the curve.\n                   This will hold the result.\n\n @return           Error code:\n                   - CX_OK on success\n                   - CX_NOT_LOCKED\n                   - CX_INVALID_PARAMETER\n                   - CX_EC_INVALID_CURVE\n                   - CX_EC_INVALID_POINT\n                   - CX_MEMORY_FULL\n                   - CX_EC_INFINITE_POINT"]
    pub fn cx_ecpoint_neg(P: *mut cx_ecpoint_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Performs a secure scalar multiplication.\n\n @param[in, out] P     Pointer to a point on a curve. This will hold the result.\n\n @param[in]      k     Pointer to the scalar. The scalar is an integer at least equal to 0\n                       and at most equal to the order of the curve minus 1.\n\n @param[in]      k_len Length of the scalar. This should be equal to the domain length.\n\n @return               Error code:\n                       - CX_OK on success\n                       - CX_NOT_LOCKED\n                       - CX_INVALID_PARAMETER\n                       - CX_EC_INVALID_POINT\n                       - CX_EC_INVALID_CURVE\n                       - CX_EC_INFINITE_POINT\n                       - CX_MEMORY_FULL"]
    pub fn cx_ecpoint_rnd_scalarmul(P: *mut cx_ecpoint_t, k: *const u8, k_len: usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Performs a secure scalar multiplication given the BN index of the scalar.\n\n @param[in, out] P    Pointer to a point on a curve. This will hold the result.\n\n @param[in]      bn_k BN index of the scalar. The scalar is an integer at least equal to 0\n                      and at most equal to the order of the curve minus 1.\n\n @return           Error code:\n                   - CX_OK on success\n                   - CX_NOT_LOCKED\n                   - CX_INVALID_PARAMETER\n                   - CX_EC_INVALID_POINT\n                   - CX_EC_INVALID_CURVE\n                   - CX_EC_INFINITE_POINT\n                   - CX_MEMORY_FULL"]
    pub fn cx_ecpoint_rnd_scalarmul_bn(P: *mut cx_ecpoint_t, bn_k: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Performs a secure scalar multiplication with a fixed scalar length.\n\n @param[in, out] P     Pointer to a point on a curve. This will hold the result.\n\n @param[in]      k     Pointer to the scalar. The scalar is an integer at least equal to 0\n                       and at most equal to the order of the curve minus 1.\n\n @param[in]      k_len Length of the scalar. This should be equal to the domain length.\n\n @return               Error code:\n                       - CX_OK on success\n                       - CX_NOT_LOCKED\n                       - CX_INVALID_PARAMETER\n                       - CX_EC_INVALID_POINT\n                       - CX_EC_INVALID_CURVE\n                       - CX_EC_INFINITE_POINT\n                       - CX_MEMORY_FULL"]
    pub fn cx_ecpoint_rnd_fixed_scalarmul(
        P: *mut cx_ecpoint_t,
        k: *const u8,
        k_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Performs a scalar multiplication.\n\n @warning This should be called only for non critical purposes.\n          It is recommended to use #cx_ecpoint_rnd_scalarmul or\n          #cx_ecpoint_rnd_fixed_scalarmul rather than this function.\n\n @param[in, out] P      Pointer to a point on a curve. This will hold the result.\n\n @param[in]      k      Pointer to the scalar. The scalar is an integer at least equal to 0\n                        and at most equal to the order of the curve minus 1.\n\n @param[in]      k_len  Length of the scalar.\n\n @return                Error code:\n                        - CX_OK on success\n                        - CX_NOT_LOCKED\n                        - CX_INVALID_PARAMETER\n                        - CX_EC_INVALID_POINT\n                        - CX_EC_INVALID_CURVE\n                        - CX_EC_INFINITE_POINT\n                        - CX_MEMORY_FULL"]
    pub fn cx_ecpoint_scalarmul(P: *mut cx_ecpoint_t, k: *const u8, k_len: usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Performs a scalar multiplication given the BN index of the scalar.\n\n @warning This should be called only for non critical purposes.\n          It is recommended to use #cx_ecpoint_rnd_scalarmul_bn\n          rather than this function.\n\n @param[in, out] P    Pointer to a point on a curve. This will hold the result.\n\n @param[in]      bn_k BN index of the scalar. The scalar is an integer at least equal to 0\n                      and at most equal to the order of the curve minus 1.\n\n @return              Error code:\n                      - CX_OK on success\n                      - CX_NOT_LOCKED\n                      - CX_INVALID_PARAMETER\n                      - CX_EC_INVALID_POINT\n                      - CX_EC_INVALID_CURVE\n                      - CX_EC_INFINITE_POINT\n                      - CX_MEMORY_FULL"]
    pub fn cx_ecpoint_scalarmul_bn(P: *mut cx_ecpoint_t, bn_k: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Performs a double scalar multiplication.\n\n @details This implements the Straus-Shamir algorithm for computing **R = [k]P + [r]Q**.\n          This should be used only for non-secret computations.\n\n @param[out] R     Pointer to the result.\n\n @param[in]  P     Pointer to the first point.\n\n @param[in]  Q     Pointer to the second point.\n\n @param[in]  k     Pointer to the first scalar.\n\n @param[in]  k_len Length of the first scalar.\n\n @param[in]  r     Pointer to the second scalar.\n\n @param[in]  r_len Length of the second scalar.\n\n @return           Error code:\n                   - CX_OK on success\n                   - CX_NOT_LOCKED\n                   - CX_INVALID_PARAMETER\n                   - CX_EC_INVALID_POINT\n                   - CX_EC_INVALID_CURVE\n                   - CX_MEMORY_FULL\n                   - CX_EC_INFINITE_POINT"]
    pub fn cx_ecpoint_double_scalarmul(
        R: *mut cx_ecpoint_t,
        P: *mut cx_ecpoint_t,
        Q: *mut cx_ecpoint_t,
        k: *const u8,
        k_len: usize,
        r: *const u8,
        r_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Performs a double scalar multiplication\n          given the BN indexes of the scalars.\n\n @details This implements the Straus-Shamir algorithm for computing **R = [k]P + [r]Q**.\n          This should be used only for non-secret computations.\n\n @param[out] R     Pointer to the result.\n\n @param[in]  P     Pointer to the first point.\n\n @param[in]  Q     Pointer to the second point.\n\n @param[in]  bn_k  BN index of the first scalar.\n\n @param[in]  bn_r  BN index of the second scalar.\n\n @return           Error code:\n                  - CX_OK on success\n                  - CX_NOT_LOCKED\n                  - CX_INVALID_PARAMETER\n                  - CX_EC_INVALID_POINT\n                  - CX_EC_INVALID_CURVE\n                  - CX_MEMORY_FULL\n                  - CX_EC_INFINITE_POINT"]
    pub fn cx_ecpoint_double_scalarmul_bn(
        R: *mut cx_ecpoint_t,
        P: *mut cx_ecpoint_t,
        Q: *mut cx_ecpoint_t,
        bn_k: cx_bn_t,
        bn_r: cx_bn_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Compares two points on the same curve.\n\n @param[in]  P        First point to compare.\n\n @param[in]  Q        Second point to compare.\n\n @param[out] is_equal Boolean which indicates whether the two points are equal or not:\n                      - 1 if the points are equal\n                      - 0 otherwise\n\n @return              Error code:\n                      - CX_OK on success\n                      - CX_NOT_LOCKED\n                      - CX_INVALID_PARAMETER\n                      - CX_EC_INVALID_CURVE\n                      - CX_EC_INFINITE_POINT\n                      - CX_MEMORY_FULL"]
    pub fn cx_ecpoint_cmp(
        P: *const cx_ecpoint_t,
        Q: *const cx_ecpoint_t,
        is_equal: *mut bool,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Checks whether a given point is on the curve.\n\n @param[in]  R           Pointer to the point to check.\n\n @param[out] is_on_curve Boolean which indicates whether the point is on the curve or not:\n                         - 1 if the point is on the curve\n                         - 0 otherwise\n\n @return                 Error code:\n                         - CX_OK on success\n                         - CX_NOT_LOCKED\n                         - CX_INVALID_PARAMETER\n                         - CX_EC_INVALID_CURVE\n                         - CX_EC_INFINITE_POINT\n                         - CX_MEMORY_FULL"]
    pub fn cx_ecpoint_is_on_curve(R: *const cx_ecpoint_t, is_on_curve: *mut bool) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Checks whether a given point is the point at infinity.\n\n @details The point at infinity has a z-coordinate equal to 0.\n\n @param[in]  R              Pointer to the point to check.\n\n @param[out] is_at_infinity Boolean which indicates whether the point is at infinity or not:\n                            - 1 if the point is at infinity\n                            - 0 otherwise\n\n @return                    Error code:\n                            - CX_OK on success\n                            - CX_NOT_LOCKED\n                            - CX_INVALID_PARAMETER\n                            - CX_EC_INVALID_CURVE"]
    pub fn cx_ecpoint_is_at_infinity(R: *const cx_ecpoint_t, is_at_infinity: *mut bool)
        -> cx_err_t;
}
extern "C" {
    #[doc = " @brief Calculates a 32-bit cyclic redundancy check.\n\n @param[in] buf Pointer to the buffer to check.\n\n @param[in] len Length of the buffer.\n\n @return        Result of the 32-bit CRC calculation.\n"]
    pub fn cx_crc32_hw(buf: *const cty::c_void, len: usize) -> u32;
}
extern "C" {
    #[doc = " @brief   Gets random data from the True Random Number Generation.\n\n @param[out] buf  Buffer where to store the random data.\n\n @param[in]  size Size of the random data in bytes.\n"]
    pub fn cx_trng_get_random_data(buf: *mut u8, size: usize);
}
extern "C" {
    pub fn cx_trng_selftest();
}
extern "C" {
    pub fn cx_trng_init();
}
pub type uint64bits_t = u64;
pub const generic_identifiers_ERR_GEN_ID_01: generic_identifiers = 1;
pub const generic_identifiers_ERR_GEN_ID_02: generic_identifiers = 2;
pub const generic_identifiers_ERR_GEN_ID_03: generic_identifiers = 3;
pub const generic_identifiers_ERR_GEN_ID_04: generic_identifiers = 4;
pub const generic_identifiers_ERR_GEN_ID_05: generic_identifiers = 5;
pub const generic_identifiers_ERR_GEN_ID_06: generic_identifiers = 6;
pub const generic_identifiers_ERR_GEN_ID_07: generic_identifiers = 7;
pub const generic_identifiers_ERR_GEN_ID_08: generic_identifiers = 8;
pub const generic_identifiers_ERR_GEN_ID_09: generic_identifiers = 9;
pub const generic_identifiers_ERR_GEN_ID_0A: generic_identifiers = 10;
pub const generic_identifiers_ERR_GEN_ID_0B: generic_identifiers = 11;
pub const generic_identifiers_ERR_GEN_ID_0C: generic_identifiers = 12;
pub const generic_identifiers_ERR_GEN_ID_0D: generic_identifiers = 13;
pub const generic_identifiers_ERR_GEN_ID_0E: generic_identifiers = 14;
pub const generic_identifiers_ERR_GEN_ID_0F: generic_identifiers = 15;
pub const generic_identifiers_ERR_GEN_ID_10: generic_identifiers = 16;
pub const generic_identifiers_ERR_GEN_ID_11: generic_identifiers = 17;
pub const generic_identifiers_ERR_GEN_ID_12: generic_identifiers = 18;
pub const generic_identifiers_ERR_GEN_ID_13: generic_identifiers = 19;
pub const generic_identifiers_ERR_GEN_ID_14: generic_identifiers = 20;
pub const generic_identifiers_ERR_GEN_ID_15: generic_identifiers = 21;
pub const generic_identifiers_ERR_GEN_ID_16: generic_identifiers = 22;
pub const generic_identifiers_ERR_GEN_ID_17: generic_identifiers = 23;
pub const generic_identifiers_ERR_GEN_ID_18: generic_identifiers = 24;
pub const generic_identifiers_ERR_GEN_ID_19: generic_identifiers = 25;
pub const generic_identifiers_ERR_GEN_ID_1A: generic_identifiers = 26;
pub const generic_identifiers_ERR_GEN_ID_1B: generic_identifiers = 27;
pub const generic_identifiers_ERR_GEN_ID_1C: generic_identifiers = 28;
pub const generic_identifiers_ERR_GEN_ID_1D: generic_identifiers = 29;
pub const generic_identifiers_ERR_GEN_ID_1E: generic_identifiers = 30;
pub const generic_identifiers_ERR_GEN_ID_1F: generic_identifiers = 31;
pub const generic_identifiers_ERR_GEN_ID_20: generic_identifiers = 32;
pub const generic_identifiers_ERR_GEN_ID_21: generic_identifiers = 33;
pub const generic_identifiers_ERR_GEN_ID_22: generic_identifiers = 34;
pub const generic_identifiers_ERR_GEN_ID_23: generic_identifiers = 35;
pub const generic_identifiers_ERR_GEN_ID_24: generic_identifiers = 36;
pub const generic_identifiers_ERR_GEN_ID_25: generic_identifiers = 37;
pub const generic_identifiers_ERR_GEN_ID_26: generic_identifiers = 38;
pub const generic_identifiers_ERR_GEN_ID_27: generic_identifiers = 39;
pub const generic_identifiers_ERR_GEN_ID_28: generic_identifiers = 40;
pub const generic_identifiers_ERR_GEN_ID_29: generic_identifiers = 41;
pub const generic_identifiers_ERR_GEN_ID_2A: generic_identifiers = 42;
pub const generic_identifiers_ERR_GEN_ID_2B: generic_identifiers = 43;
pub const generic_identifiers_ERR_GEN_ID_2C: generic_identifiers = 44;
pub const generic_identifiers_ERR_GEN_ID_2D: generic_identifiers = 45;
pub const generic_identifiers_ERR_GEN_ID_2E: generic_identifiers = 46;
pub const generic_identifiers_ERR_GEN_ID_2F: generic_identifiers = 47;
pub const generic_identifiers_ERR_GEN_ID_30: generic_identifiers = 48;
pub const generic_identifiers_ERR_GEN_ID_31: generic_identifiers = 49;
pub const generic_identifiers_ERR_GEN_ID_32: generic_identifiers = 50;
pub const generic_identifiers_ERR_GEN_ID_33: generic_identifiers = 51;
pub const generic_identifiers_ERR_GEN_ID_34: generic_identifiers = 52;
pub const generic_identifiers_ERR_GEN_ID_35: generic_identifiers = 53;
pub const generic_identifiers_ERR_GEN_ID_36: generic_identifiers = 54;
pub const generic_identifiers_ERR_GEN_ID_37: generic_identifiers = 55;
pub type generic_identifiers = cty::c_uint;
pub type bolos_err_t = u32;
pub type exception_t = cty::c_ushort;
pub type try_context_t = try_context_s;
pub type jmp_buf = [cty::c_uint; 10usize];
extern "C" {
    pub fn longjmp(__jmpb: *mut cty::c_uint, __retval: cty::c_int) -> !;
}
extern "C" {
    pub fn setjmp(__jmpb: *mut cty::c_uint) -> cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct try_context_s {
    pub jmp_buf: jmp_buf,
    pub previous: *mut try_context_t,
    pub ex: exception_t,
}
#[test]
fn bindgen_test_layout_try_context_s() {
    const UNINIT: ::core::mem::MaybeUninit<try_context_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<try_context_s>(),
        48usize,
        concat!("Size of: ", stringify!(try_context_s))
    );
    assert_eq!(
        ::core::mem::align_of::<try_context_s>(),
        4usize,
        concat!("Alignment of ", stringify!(try_context_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).jmp_buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(try_context_s),
            "::",
            stringify!(jmp_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).previous) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(try_context_s),
            "::",
            stringify!(previous)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ex) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(try_context_s),
            "::",
            stringify!(ex)
        )
    );
}
impl Default for try_context_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn try_context_get() -> *mut try_context_t;
}
extern "C" {
    pub fn try_context_set(context: *mut try_context_t) -> *mut try_context_t;
}
extern "C" {
    pub fn os_longjmp(exception: cty::c_uint) -> !;
}
extern "C" {
    pub fn os_parse_bertlv(
        mem: *mut cty::c_uchar,
        mem_len: cty::c_uint,
        tlv_instance_offset: *mut cty::c_uint,
        tag: cty::c_uint,
        offset: cty::c_uint,
        buffer: *mut *mut cty::c_void,
        maxlength: cty::c_uint,
    ) -> cty::c_uint;
}
#[doc = "< No message digest algorithm"]
pub const cx_md_e_CX_NONE: cx_md_e = 0;
#[doc = "< RIPEMD160 digest"]
pub const cx_md_e_CX_RIPEMD160: cx_md_e = 1;
#[doc = "< SHA224 digest"]
pub const cx_md_e_CX_SHA224: cx_md_e = 2;
#[doc = "< SHA256 digest"]
pub const cx_md_e_CX_SHA256: cx_md_e = 3;
#[doc = "< SHA384 digest"]
pub const cx_md_e_CX_SHA384: cx_md_e = 4;
#[doc = "< SHA512 digest"]
pub const cx_md_e_CX_SHA512: cx_md_e = 5;
#[doc = "< Keccak (pre-SHA3) digest"]
pub const cx_md_e_CX_KECCAK: cx_md_e = 6;
#[doc = "< SHA3 Digest"]
pub const cx_md_e_CX_SHA3: cx_md_e = 7;
#[doc = "< Keep compatibility"]
pub const cx_md_e_DEPRECATED_0: cx_md_e = 8;
#[doc = "< Blake digest"]
pub const cx_md_e_CX_BLAKE2B: cx_md_e = 9;
#[doc = "< SHAKE-128 digest"]
pub const cx_md_e_CX_SHAKE128: cx_md_e = 10;
#[doc = "< SHAKE-256 digest"]
pub const cx_md_e_CX_SHAKE256: cx_md_e = 11;
#[doc = "< SHA3-256 digest"]
pub const cx_md_e_CX_SHA3_256: cx_md_e = 12;
#[doc = "< SHA3-512 digest"]
pub const cx_md_e_CX_SHA3_512: cx_md_e = 13;
#[doc = " Message digest algorithm identifiers."]
pub type cx_md_e = cty::c_uint;
#[doc = " Message digest algorithm identifiers."]
pub use self::cx_md_e as cx_md_t;
#[doc = " @brief Common message digest context, used as abstract type."]
pub type cx_hash_t = cx_hash_header_s;
#[doc = " @brief Hash description."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_hash_info_t {
    #[doc = "< Message digest algorithm identifier"]
    pub md_type: cx_md_t,
    #[doc = "< Output size"]
    pub output_size: usize,
    #[doc = "< Block size"]
    pub block_size: usize,
    #[doc = "< Related size of the context hash"]
    pub ctx_size: usize,
    #[doc = "< Pointer to the initialization function"]
    pub init_func: ::core::option::Option<unsafe extern "C" fn(ctx: *mut cx_hash_t) -> cx_err_t>,
    #[doc = "< Pointer to the update function"]
    pub update_func: ::core::option::Option<
        unsafe extern "C" fn(ctx: *mut cx_hash_t, data: *const u8, len: usize) -> cx_err_t,
    >,
    #[doc = "< Pointer to the final function"]
    pub finish_func: ::core::option::Option<
        unsafe extern "C" fn(ctx: *mut cx_hash_t, digest: *mut u8) -> cx_err_t,
    >,
    #[doc = "< Pointer to the initialization function for extendable output"]
    pub init_ex_func: ::core::option::Option<
        unsafe extern "C" fn(ctx: *mut cx_hash_t, output_size: usize) -> cx_err_t,
    >,
    #[doc = "< Pointer to the output size function"]
    pub output_size_func:
        ::core::option::Option<unsafe extern "C" fn(ctx: *const cx_hash_t) -> usize>,
}
#[test]
fn bindgen_test_layout_cx_hash_info_t() {
    const UNINIT: ::core::mem::MaybeUninit<cx_hash_info_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_hash_info_t>(),
        36usize,
        concat!("Size of: ", stringify!(cx_hash_info_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_hash_info_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_hash_info_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).md_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_info_t),
            "::",
            stringify!(md_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).output_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_info_t),
            "::",
            stringify!(output_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_info_t),
            "::",
            stringify!(block_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ctx_size) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_info_t),
            "::",
            stringify!(ctx_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init_func) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_info_t),
            "::",
            stringify!(init_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).update_func) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_info_t),
            "::",
            stringify!(update_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).finish_func) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_info_t),
            "::",
            stringify!(finish_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init_ex_func) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_info_t),
            "::",
            stringify!(init_ex_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).output_size_func) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_info_t),
            "::",
            stringify!(output_size_func)
        )
    );
}
impl Default for cx_hash_info_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Common message digest context, used as abstract type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_hash_header_s {
    #[doc = "< Hash description"]
    pub info: *const cx_hash_info_t,
    #[doc = "< Number of already processed blocks"]
    pub counter: u32,
}
#[test]
fn bindgen_test_layout_cx_hash_header_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_hash_header_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_hash_header_s>(),
        8usize,
        concat!("Size of: ", stringify!(cx_hash_header_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_hash_header_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_hash_header_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_header_s),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).counter) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_header_s),
            "::",
            stringify!(counter)
        )
    );
}
impl Default for cx_hash_header_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn cx_hash_get_size(ctx: *const cx_hash_t) -> usize;
}
extern "C" {
    #[doc = " @brief   Hashes data according to the specified algorithm.\n\n @param[in]  hash    Pointer to the hash context.\n                     Shall be in RAM.\n                     Should be called with a cast.\n\n @param[in]  mode    Crypto flag. Supported flag: CX_LAST. If set:\n                       - the structure is not modified after finishing\n                       - if out is not NULL, the message digest is stored in out\n                       - the context is NOT automatically re-initialized.\n\n @param[in]  in      Input data to be hashed.\n\n @param[in]  len     Length of the input data.\n\n @param[out] out     Buffer where to store the message digest:\n                       - NULL (ignored) if CX_LAST is NOT set\n                       - message digest if CX_LAST is set\n\n @param[out] out_len The size of the output buffer or 0 if out is NULL.\n                     If buffer is too small to store the hash an error is returned.\n\n @return             Error code:\n                     - CX_OK on success\n                     - INVALID_PARAMETER\n                     - CX_INVALID_PARAMETER"]
    pub fn cx_hash_no_throw(
        hash: *mut cx_hash_t,
        mode: u32,
        in_: *const u8,
        len: usize,
        out: *mut u8,
        out_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Initializes a hash context.\n\n @param[out] hash    Pointer to the context to be initialized.\n                     The context shall be in RAM.\n\n @param[in]  hash_id Message digest algorithm identifier.\n\n @return             Error code:\n                     - CX_OK on success\n                     - CX_INVALID_PARAMETER"]
    pub fn cx_hash_init(hash: *mut cx_hash_t, hash_id: cx_md_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Initializes a hash context.\n\n @details It initializes a hash context with a chosen output length\n          (typically for eXtendable Output Functions (XOF)).\n\n @param[out] hash        Pointer to the context to be initialized.\n                         The context shall be in RAM.\n\n @param [in] hash_id     Hash algorithm identifier. Typically:\n                           - CX_BLAKE2B\n                           - CX_SHAKE128\n                           - CX_SHAKE256\n\n @param [in] output_size Length of the output.\n\n @return                 Error code:\n                         - CX_OK on success\n                         - CX_INVALID_PARAMETER"]
    pub fn cx_hash_init_ex(hash: *mut cx_hash_t, hash_id: cx_md_t, output_size: usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Adds more data to hash.\n\n @details A call to this function is equivalent to:\n          *cx_hash_no_throw(hash, 0, in, in_len, NULL, 0)*.\n\n @param[out] hash   Pointer to the hash context.\n\n @param[in]  in     Input data to add to the context.\n\n @param[in]  in_len Length of the input data.\n\n @return            Error code:\n                    - CX_OK on success\n                    - CX_INVALID_PARAMETER\n                    - INVALID_PARAMETER"]
    pub fn cx_hash_update(hash: *mut cx_hash_t, in_: *const u8, in_len: usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Finalizes the hash.\n\n @details A call to this function is equivalent to:\n          *cx_hash_no_throw(hash, CX_LAST, NULL, 0, out, out_len)*.\n\n @param[in]  hash   Pointer to the hash context.\n\n @param[out] digest The message digest.\n\n @return            Error code:\n                    - CX_OK on success"]
    pub fn cx_hash_final(hash: *mut cx_hash_t, digest: *mut u8) -> cx_err_t;
}
#[doc = " @brief RIPEMD-160 context."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ripemd160_s {
    #[doc = "< See #cx_hash_header_s"]
    pub header: cx_hash_header_s,
    #[doc = "< Pending partial block length"]
    pub blen: usize,
    #[doc = "< Pending partial block"]
    pub block: [u8; 64usize],
    #[doc = "< Current digest state"]
    pub acc: [u8; 20usize],
}
#[test]
fn bindgen_test_layout_cx_ripemd160_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_ripemd160_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_ripemd160_s>(),
        96usize,
        concat!("Size of: ", stringify!(cx_ripemd160_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ripemd160_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ripemd160_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ripemd160_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blen) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ripemd160_s),
            "::",
            stringify!(blen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ripemd160_s),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).acc) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ripemd160_s),
            "::",
            stringify!(acc)
        )
    );
}
impl Default for cx_ripemd160_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief RIPEMD-160 context."]
pub type cx_ripemd160_t = cx_ripemd160_s;
extern "C" {
    #[doc = " @brief   Initializes a RIPEMD-160 context.\n\n @param[out] hash Pointer to the context.\n                  The context shall be in RAM.\n\n @return          Error code:\n                  - CX_OK on success"]
    pub fn cx_ripemd160_init_no_throw(hash: *mut cx_ripemd160_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Computes a one shot Ripemd-160 digest.\n\n @param[in]  in      Input data.\n\n @param[in]  in_len  Length of the input data.\n\n @param[out] out     Buffer where to store the digest.\n\n @param[in]  out_len Length of the output.\n\n @return             Size of a Ripemd-160 digest, i.e. 20 bytes."]
    pub fn cx_hash_ripemd160(in_: *const u8, in_len: usize, out: *mut u8, out_len: usize) -> usize;
}
#[doc = " @brief SHA-224 and SHA-256 context"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_sha256_s {
    #[doc = "< @copydoc cx_ripemd160_s::header"]
    pub header: cx_hash_header_s,
    #[doc = "< @copydoc cx_ripemd160_s::blen"]
    pub blen: usize,
    #[doc = "< @copydoc cx_ripemd160_s::block"]
    pub block: [u8; 64usize],
    #[doc = "< @copydoc cx_ripemd160_s::acc"]
    pub acc: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_cx_sha256_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_sha256_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_sha256_s>(),
        108usize,
        concat!("Size of: ", stringify!(cx_sha256_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_sha256_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_sha256_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha256_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blen) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha256_s),
            "::",
            stringify!(blen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha256_s),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).acc) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha256_s),
            "::",
            stringify!(acc)
        )
    );
}
impl Default for cx_sha256_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief SHA-224 and SHA-256 context"]
pub type cx_sha256_t = cx_sha256_s;
extern "C" {
    #[doc = " @brief   Initializes a SHA-256 context.\n\n @param[out] hash Pointer to the context.\n                  The context shall be in RAM.\n\n @return          Error code:\n                  - CX_OK on success"]
    pub fn cx_sha256_init_no_throw(hash: *mut cx_sha256_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Computes a one shot SHA-256 digest.\n\n @param[in]  in      Input data.\n\n @param[in]  len     Length of the input data.\n\n @param[out] out     Buffer where to store the digest.\n\n @param[in]  out_len Length of the output.\n                     This is actually 256 bits.\n"]
    pub fn cx_hash_sha256(in_: *const u8, len: usize, out: *mut u8, out_len: usize) -> usize;
}
#[doc = " @brief SHA-384 and SHA-512 context"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_sha512_s {
    #[doc = "< @copydoc cx_ripemd160_s::header"]
    pub header: cx_hash_header_s,
    #[doc = "< @copydoc cx_ripemd160_s::blen"]
    pub blen: usize,
    #[doc = "< @copydoc cx_ripemd160_s::block"]
    pub block: [u8; 128usize],
    #[doc = "< @copydoc cx_ripemd160_s::acc"]
    pub acc: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_cx_sha512_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_sha512_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_sha512_s>(),
        204usize,
        concat!("Size of: ", stringify!(cx_sha512_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_sha512_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_sha512_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha512_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blen) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha512_s),
            "::",
            stringify!(blen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha512_s),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).acc) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha512_s),
            "::",
            stringify!(acc)
        )
    );
}
impl Default for cx_sha512_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief SHA-384 and SHA-512 context"]
pub type cx_sha512_t = cx_sha512_s;
extern "C" {
    #[doc = " @brief   Initializes a SHA-384 context.\n\n @param[out] hash Pointer to the context.\n                  The context shall be in RAM.\n\n @return          Error code:\n                  - CX_OK on success"]
    pub fn cx_sha384_init_no_throw(hash: *mut cx_sha512_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Initializes a SHA-512 context.\n\n @param[out] hash Pointer to the context.\n                  The context shall be in RAM.\n\n @return          Error code:\n                  - CX_OK on success"]
    pub fn cx_sha512_init_no_throw(hash: *mut cx_sha512_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Computes a one shot SHA-512 digest.\n\n @param[in]  in      Input data.\n\n @param[in]  in_len  Length of the input data.\n\n @param[out] out     Buffer where to store the output.\n\n @param[out] out_len Length of the output.\n                     This is actually 512 bits."]
    pub fn cx_hash_sha512(in_: *const u8, in_len: usize, out: *mut u8, out_len: usize) -> usize;
}
#[doc = " @brief KECCAK, SHA3 and SHA3-XOF context"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_sha3_s {
    #[doc = "< @copydoc cx_ripemd160_s::header"]
    pub header: cx_hash_header_s,
    #[doc = "< Output digest size"]
    pub output_size: usize,
    #[doc = "< Input block size"]
    pub block_size: usize,
    #[doc = "< @copydoc cx_ripemd160_s::blen"]
    pub blen: usize,
    #[doc = "< @copydoc cx_ripemd160_s::block"]
    pub block: [u8; 200usize],
    #[doc = "< @copydoc cx_ripemd160_s::acc"]
    pub acc: [uint64bits_t; 25usize],
}
#[test]
fn bindgen_test_layout_cx_sha3_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_sha3_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_sha3_s>(),
        424usize,
        concat!("Size of: ", stringify!(cx_sha3_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_sha3_s>(),
        8usize,
        concat!("Alignment of ", stringify!(cx_sha3_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha3_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).output_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha3_s),
            "::",
            stringify!(output_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block_size) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha3_s),
            "::",
            stringify!(block_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blen) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha3_s),
            "::",
            stringify!(blen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha3_s),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).acc) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha3_s),
            "::",
            stringify!(acc)
        )
    );
}
impl Default for cx_sha3_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief KECCAK, SHA3 and SHA3-XOF context"]
pub type cx_sha3_t = cx_sha3_s;
extern "C" {
    #[doc = " @brief   Initializes a SHA3 context.\n\n @details Supported output sizes in bits:\n            - 224\n            - 256\n            - 384\n            - 512\n\n @param[out] hash Pointer to the SHA3 context.\n                  The context shall be in RAM.\n\n @param[in]  size Length of the hash output in bits.\n\n @return          Error code:\n                  - CX_OK on success\n                  - CX_INVALID_PARAMETER"]
    pub fn cx_sha3_init_no_throw(hash: *mut cx_sha3_t, size: usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief Initializes a KECCAK context.\n\n @details Supported output sizes in bits:\n            - 224\n            - 256\n            - 384\n            - 512\n\n\n @param[out] hash  Pointer to the KECCAK context.\n                   The context shall be in RAM.\n\n @param[in]  size  Length of the hash output in bits.\n\n @return           Error code:\n                   - CX_OK on success\n                   - CX_INVALID_PARAMETER"]
    pub fn cx_keccak_init_no_throw(hash: *mut cx_sha3_t, size: usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Initializes a SHA3-XOF context.\n\n @details SHAKE128 is a SHA3-XOF (Extendable Output Function\n          based on SHA3) with a 128-bit security.\n          Supported output sizes in bits:\n            - 256\n            - 512\n\n @param[out] hash      Pointer to the context.\n                       The context shall be in RAM.\n\n @param[in]  out_size  Length of the output in bits.\n\n @return               Error code:\n                       - CX_OK on success\n                       - CX_INVALID_PARAMETER"]
    pub fn cx_shake128_init_no_throw(hash: *mut cx_sha3_t, out_size: usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Initializes a SHA3-XOF context.\n\n @details SHAKE256 is a SHA3-XOF (Extendable Output Function\n          based on SHA3) with a 256-bit security.\n          Supported output sizes in bits:\n            - 256\n            - 512\n\n @param[out] hash      Pointer to the context.\n                       The context shall be in RAM.\n\n @param[in]  out_size  Length of the output in bits.\n\n @return               Error code:\n                       - CX_OK on success\n                       - CX_INVALID_PARAMETER"]
    pub fn cx_shake256_init_no_throw(hash: *mut cx_sha3_t, out_size: usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Initializes a SHA3-XOF context.\n\n @details This can be used to initialize either SHAKE128\n          or SHAKE256.\n          Supported output sizes in bits:\n            - 256\n            - 512\n\n @param[out] hash         Pointer to the context.\n                          The context shall be in RAM.\n\n @param[in]  size         Length of SHA3 digest in bits.\n\n @param[in]  out_length   Length of the output in bytes.\n\n @return                  Error code:\n                          - CX_OK on success\n                          - CX_INVALID_PARAMETER"]
    pub fn cx_sha3_xof_init_no_throw(
        hash: *mut cx_sha3_t,
        size: usize,
        out_length: usize,
    ) -> cx_err_t;
}
#[doc = "< Size of a block"]
pub const blake2b_constant_BLAKE2B_BLOCKBYTES: blake2b_constant = 128;
#[doc = "< Size of the output"]
pub const blake2b_constant_BLAKE2B_OUTBYTES: blake2b_constant = 64;
#[doc = "< Size of the key"]
pub const blake2b_constant_BLAKE2B_KEYBYTES: blake2b_constant = 64;
#[doc = "< Size of the salt"]
pub const blake2b_constant_BLAKE2B_SALTBYTES: blake2b_constant = 16;
#[doc = "< Size of the personalization string"]
pub const blake2b_constant_BLAKE2B_PERSONALBYTES: blake2b_constant = 16;
#[doc = "  @private BLAKE2b constants"]
pub type blake2b_constant = cty::c_uint;
#[doc = "  @private BLAKE2b state members"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blake2b_state__ {
    #[doc = "< Internal state of the hash"]
    pub h: [u64; 8usize],
    #[doc = "< Message byte offset at the end of the current block"]
    pub t: [u64; 2usize],
    #[doc = "< Flag indicating the last block"]
    pub f: [u64; 2usize],
    #[doc = "< Buffer for the processed data"]
    pub buf: [u8; 128usize],
    #[doc = "< Length of the buffer"]
    pub buflen: usize,
    #[doc = "< Length of the output"]
    pub outlen: usize,
    #[doc = "< Last node"]
    pub last_node: u8,
}
#[test]
fn bindgen_test_layout_blake2b_state__() {
    const UNINIT: ::core::mem::MaybeUninit<blake2b_state__> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<blake2b_state__>(),
        240usize,
        concat!("Size of: ", stringify!(blake2b_state__))
    );
    assert_eq!(
        ::core::mem::align_of::<blake2b_state__>(),
        8usize,
        concat!("Alignment of ", stringify!(blake2b_state__))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state__),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).t) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state__),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state__),
            "::",
            stringify!(f)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state__),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buflen) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state__),
            "::",
            stringify!(buflen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).outlen) as usize - ptr as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state__),
            "::",
            stringify!(outlen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).last_node) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state__),
            "::",
            stringify!(last_node)
        )
    );
}
impl Default for blake2b_state__ {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "  @private BLAKE2b state members"]
pub type blake2b_state = blake2b_state__;
#[doc = " @brief BLAKE2b context"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_blake2b_s {
    #[doc = "< @copydoc cx_ripemd160_s::header"]
    pub header: cx_hash_header_s,
    #[doc = "< Output digest size"]
    pub output_size: usize,
    #[doc = "< BLAKE2B state"]
    pub ctx: blake2b_state__,
}
#[test]
fn bindgen_test_layout_cx_blake2b_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_blake2b_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_blake2b_s>(),
        256usize,
        concat!("Size of: ", stringify!(cx_blake2b_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_blake2b_s>(),
        8usize,
        concat!("Alignment of ", stringify!(cx_blake2b_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_blake2b_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).output_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_blake2b_s),
            "::",
            stringify!(output_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_blake2b_s),
            "::",
            stringify!(ctx)
        )
    );
}
impl Default for cx_blake2b_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief BLAKE2b context"]
pub type cx_blake2b_t = cx_blake2b_s;
extern "C" {
    #[doc = " @brief   Initializes BLAKE2b message digest context.\n\n @param[out] hash    Pointer to the BLAKE2b context to initialize.\n                     The context shall be in RAM.\n\n @param[in]  out_len Digest size in bits.\n\n @return             Error code:\n                     - CX_OK\n                     - CX_INVALID_PARAMETER"]
    pub fn cx_blake2b_init_no_throw(hash: *mut cx_blake2b_t, out_len: usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Initializes BLAKE2b message digest context with\n          salt and personnalization string.\n\n @param[out] hash     Pointer to the BLAKE2b context to initialize.\n                      The context shall be in RAM.\n\n @param[in] out_len   Digest size in bits.\n\n @param[in] salt      Pointer to a salt (optional).\n\n @param[in] salt_len  Length of the salt.\n\n @param[in] perso     Pointer to a personalization string (optional).\n\n @param[in] perso_len Length of the personalization string.\n\n @return              Error code:\n                      - CX_OK on success\n                      - CX_INVALID_PARAMETER"]
    pub fn cx_blake2b_init2_no_throw(
        hash: *mut cx_blake2b_t,
        out_len: usize,
        salt: *mut u8,
        salt_len: usize,
        perso: *mut u8,
        perso_len: usize,
    ) -> cx_err_t;
}
#[doc = " @brief HMAC context, abstract type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_hmac_t {
    #[doc = "< Key"]
    pub key: [u8; 128usize],
    #[doc = "< Hash context"]
    pub hash_ctx: cx_hash_t,
}
#[test]
fn bindgen_test_layout_cx_hmac_t() {
    const UNINIT: ::core::mem::MaybeUninit<cx_hmac_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_hmac_t>(),
        136usize,
        concat!("Size of: ", stringify!(cx_hmac_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_hmac_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_hmac_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hmac_t),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hash_ctx) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hmac_t),
            "::",
            stringify!(hash_ctx)
        )
    );
}
impl Default for cx_hmac_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief HMAC context, concrete type for RIPEMD160"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_hmac_ripemd160_t {
    #[doc = "< Key"]
    pub key: [u8; 128usize],
    #[doc = "< Hash context"]
    pub hash_ctx: cx_ripemd160_t,
}
#[test]
fn bindgen_test_layout_cx_hmac_ripemd160_t() {
    const UNINIT: ::core::mem::MaybeUninit<cx_hmac_ripemd160_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_hmac_ripemd160_t>(),
        224usize,
        concat!("Size of: ", stringify!(cx_hmac_ripemd160_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_hmac_ripemd160_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_hmac_ripemd160_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hmac_ripemd160_t),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hash_ctx) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hmac_ripemd160_t),
            "::",
            stringify!(hash_ctx)
        )
    );
}
impl Default for cx_hmac_ripemd160_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief   Initializes a HMAC-RIPEMD160 context.\n\n @param[out] hmac    Pointer to the HMAC context.\n                     The context shall be in RAM.\n\n @param[in]  key     Pointer to the HMAC key value.\n                     If a key has been set, passing\n                     NULL pointer will reinitialize\n                     the context with the previously set key.\n\n @param [in] key_len Length of the key.\n                     The key length shall be less than 64 bytes.\n\n @return             Error code:\n                     - CX_OK on success\n                     - CX_INVALID_PARAMETER"]
    pub fn cx_hmac_ripemd160_init_no_throw(
        hmac: *mut cx_hmac_ripemd160_t,
        key: *const u8,
        key_len: usize,
    ) -> cx_err_t;
}
#[doc = " @brief HMAC context, concrete type for SHA-224/SHA-256"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_hmac_sha256_t {
    #[doc = "< Key"]
    pub key: [u8; 128usize],
    #[doc = "< Hash context"]
    pub hash_ctx: cx_sha256_t,
}
#[test]
fn bindgen_test_layout_cx_hmac_sha256_t() {
    const UNINIT: ::core::mem::MaybeUninit<cx_hmac_sha256_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_hmac_sha256_t>(),
        236usize,
        concat!("Size of: ", stringify!(cx_hmac_sha256_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_hmac_sha256_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_hmac_sha256_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hmac_sha256_t),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hash_ctx) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hmac_sha256_t),
            "::",
            stringify!(hash_ctx)
        )
    );
}
impl Default for cx_hmac_sha256_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief   Initializes a HMAC-SHA256 context.\n\n @param[out] hmac    Pointer to the HMAC context.\n                     The context shall be in RAM.\n\n @param[in]  key     Pointer to the HMAC key value.\n                     If a key has been set, passing\n                     NULL pointer will reinitialize\n                     the context with the previously set key.\n\n @param [in] key_len Length of the key.\n                     The key length shall be less than 64 bytes.\n\n @return             Error code:\n                     - CX_OK on success\n                     - CX_INVALID_PARAMETER"]
    pub fn cx_hmac_sha256_init_no_throw(
        hmac: *mut cx_hmac_sha256_t,
        key: *const u8,
        key_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Computes a HMAC value using SHA256.\n\n @param[in]  key     HMAC key value.\n\n @param[in]  key_len Length of the HMAC key.\n\n @param[in]  in      Input data.\n\n @param[in]  len     Length of the input data.\n\n @param[out] mac     Computed HMAC value.\n\n @param[in]  mac_len Size of the output buffer.\n                     The buffer size must be larger\n                     than the length of the HMAC value.\n\n @return             Length of the HMAC value."]
    pub fn cx_hmac_sha256(
        key: *const u8,
        key_len: usize,
        in_: *const u8,
        len: usize,
        mac: *mut u8,
        mac_len: usize,
    ) -> usize;
}
#[doc = " @brief HMAC context, concrete type for SHA-384/SHA-512"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_hmac_sha512_t {
    #[doc = "< Key"]
    pub key: [u8; 128usize],
    #[doc = "< Hash context"]
    pub hash_ctx: cx_sha512_t,
}
#[test]
fn bindgen_test_layout_cx_hmac_sha512_t() {
    const UNINIT: ::core::mem::MaybeUninit<cx_hmac_sha512_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_hmac_sha512_t>(),
        332usize,
        concat!("Size of: ", stringify!(cx_hmac_sha512_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_hmac_sha512_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_hmac_sha512_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hmac_sha512_t),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hash_ctx) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hmac_sha512_t),
            "::",
            stringify!(hash_ctx)
        )
    );
}
impl Default for cx_hmac_sha512_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief   Initializes a HMAC-SHA512 context.\n\n @param[out] hmac    Pointer to the context.\n                     The context shall be in RAM.\n\n @param[in]  key     Pointer to the HMAC key value.\n                     If a key has been set, passing\n                     NULL pointer will reinitialize\n                     the context with the previously set key.\n\n @param[in]  key_len Length of the key.\n                     The key length shall be less than 128 bytes.\n\n @return             Error code:\n                     - CX_OK on success\n                     - CX_INVALID_PARAMETER"]
    pub fn cx_hmac_sha512_init_no_throw(
        hmac: *mut cx_hmac_sha512_t,
        key: *const u8,
        key_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Computes a HMAC value using SHA512.\n\n @param[in]  key     HMAC key value.\n\n @param[in]  key_len Length of the HMAC key.\n\n @param[in]  in      Input data.\n\n @param[in]  len     Length of the input data.\n\n @param[out] mac     Computed HMAC value.\n\n @param[in]  mac_len Size of the output buffer.\n                     The buffer size must be larger\n                     than the length of the HMAC value.\n\n @return             Length of the HMAC value."]
    pub fn cx_hmac_sha512(
        key: *const u8,
        key_len: usize,
        in_: *const u8,
        len: usize,
        mac: *mut u8,
        mac_len: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " @brief   Computes a HMAC value according to the specified\n          hash function.\n\n @param[in]  hmac    Pointer to the HMAC context.\n                     The context shall be initialized with\n                     one of the initialization functions.\n                     The context shall be in RAM.\n                     The function shall be called with the cast\n                     (cx_hmac_t *).\n\n @param[in]  mode    Crypto mode flags. Supported flags:\n                       - CX_LAST\n                       - CX_NO_REINIT\n                     If CX_LAST is set and CX_NO_REINIT is not set, the context is\n                     reinitialized.\n\n @param[in]  in      Input data to add to the context.\n\n @param[in]  len     Length of the input data.\n\n @param[out] mac     Pointer to the computed HMAC or NULL pointer (if CX_LAST is not set).\n\n @param[in]  mac_len Length of the output buffer if not NULL, 0 otherwise.\n                     The buffer size must be larger\n                     than the length of the HMAC value.\n\n @return             Error code:\n                     - CX_OK on success\n                     - CX_INVALID_PARAMETER"]
    pub fn cx_hmac_no_throw(
        hmac: *mut cx_hmac_t,
        mode: u32,
        in_: *const u8,
        len: usize,
        mac: *mut u8,
        mac_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Initializes a HMAC context.\n\n @param[out] hmac    Pointer to the context.\n                     The context shall be in RAM.\n\n @param[in]  hash_id The message digest algorithm identifier.\n\n @param[in]  key     Pointer to the HMAC key value.\n                     If a key has been set, passing\n                     NULL pointer will reinitialize\n                     the context with the previously set key.\n\n @param[in]  key_len Length of the key.\n                     The key length shall be less than 128 bytes.\n\n @return             Error code:\n                     - CX_OK on success\n                     - CX_INVALID_PARAMETER"]
    pub fn cx_hmac_init(
        hmac: *mut cx_hmac_t,
        hash_id: cx_md_t,
        key: *const u8,
        key_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Adds more data to compute the HMAC.\n\n @details A call to this function is equivalent to:\n          *cx_hmac_no_throw(hmac, 0, in, in_len, NULL, 0)*.\n\n @param[out] hmac   Pointer to the HMAC context.\n\n @param[in]  in     Input data to add to the context.\n\n @param[in]  in_len Length of the input data.\n\n @return            Error code:\n                    - CX_OK on success\n                    - CX_INVALID_PARAMETER\n                    - INVALID_PARAMETER"]
    pub fn cx_hmac_update(hmac: *mut cx_hmac_t, in_: *const u8, in_len: usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Finalizes the HMAC algorithm.\n\n @details A call to this function is\n          equivalent to *cx_hmac_no_throw(hash, CX_LAST, NULL, 0, out, out_len)*.\n\n @param[in]  ctx     Pointer to the HMAC context.\n\n @param[out] out     Computed HMAC value is CX_LAST is set.\n\n @param[in]  out_len Length of the output (the most significant bytes).\n\n @return             Error code:\n                     - CX_OK on success"]
    pub fn cx_hmac_final(ctx: *mut cx_hmac_t, out: *mut u8, out_len: *mut usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief Compares two integers represented as byte arrays.\n\n @param[in]  a      Pointer to the first integer.\n\n @param[in]  b      Pointer to the second integer.\n\n @param[in]  length Number of bytes taken into account for the comparison.\n\n @param[out] diff   Result of the comparison:\n                    - 0 if a and b are identical\n                    - < 0 if a is less than b\n                    - > 0 if a is greater than b\n\n @return            Error code:\n                    - CX_OK on success\n                    - CX_NOT_UNLOCKED\n                    - CX_INVALID_PARAMETER_SIZE\n                    - CX_NOT_LOCKED\n                    - CX_MEMORY_FULL\n                    - CX_INVALID_PARAMETER"]
    pub fn cx_math_cmp_no_throw(
        a: *const u8,
        b: *const u8,
        length: usize,
        diff: *mut cty::c_int,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief Adds two integers represented as byte arrays.\n\n @param[out] r   Buffer for the result.\n\n @param[in]  a   Pointer to the first integer.\n\n @param[in]  b   Pointer to the second integer.\n\n @param[in]  len Number of bytes taken into account for the addition.\n\n @return         Error code:\n                 - CX_OK on success\n                 - CX_NOT_UNLOCKED\n                 - CX_INVALID_PARAMETER_SIZE\n                 - CX_NOT_LOCKED\n                 - CX_MEMORY_FULL\n                 - CX_INVALID_PARAMETER"]
    pub fn cx_math_add_no_throw(r: *mut u8, a: *const u8, b: *const u8, len: usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief Subtracts two integers represented as byte arrays.\n\n @param[out] r   Buffer for the result.\n\n @param[in]  a   Pointer to the first integer.\n\n @param[in]  b   Pointer to the second integer.\n\n @param[in]  len Number of bytes taken into account for the subtraction.\n\n @return         Error code:\n                 - CX_OK on success\n                 - CX_NOT_UNLOCKED\n                 - CX_INVALID_PARAMETER_SIZE\n                 - CX_NOT_LOCKED\n                 - CX_MEMORY_FULL\n                 - CX_INVALID_PARAMETER"]
    pub fn cx_math_sub_no_throw(r: *mut u8, a: *const u8, b: *const u8, len: usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief Multiplies two integers represented as byte arrays.\n\n @param[out] r   Buffer for the result.\n\n @param[in]  a   Pointer to the first integer.\n\n @param[in]  b   Pointer to the second integer.\n\n @param[in]  len Number of bytes taken into account for the multiplication.\n\n @return         Error code:\n                 - CX_OK on success\n                 - CX_NOT_UNLOCKED\n                 - CX_INVALID_PARAMETER_SIZE\n                 - CX_NOT_LOCKED\n                 - CX_MEMORY_FULL\n                 - CX_INVALID_PARAMETER"]
    pub fn cx_math_mult_no_throw(r: *mut u8, a: *const u8, b: *const u8, len: usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief Performs a modular addition\n        of two integers represented as byte arrays.\n\n @param[out] r   Buffer for the result.\n\n @param[in]  a   Pointer to the first integer.\n                 This must be strictly smaller than the modulus.\n\n @param[in]  b   Pointer to the second integer.\n                 This must be strictly smaller than the modulus.\n\n @param[in]  m   Modulus\n\n @param[in]  len Number of bytes taken into account for the operation.\n\n @return         Error code:\n                 - CX_OK on success\n                 - CX_NOT_UNLOCKED\n                 - CX_INVALID_PARAMETER_SIZE\n                 - CX_NOT_LOCKED\n                 - CX_MEMORY_FULL\n                 - CX_INVALID_PARAMETER"]
    pub fn cx_math_addm_no_throw(
        r: *mut u8,
        a: *const u8,
        b: *const u8,
        m: *const u8,
        len: usize,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief Performs a modular subtraction of\n        two integers represented as byte arrays.\n\n @param[out] r   Buffer for the result.\n\n @param[in]  a   Pointer to the first integer.\n                 This must be strictly smaller than the modulus.\n\n @param[in]  b   Pointer to the second integer.\n                 This must be strictly smaller than the modulus.\n\n @param[in]  m   Modulus\n\n @param[in]  len Number of bytes taken into account for the operation.\n\n @return         Error code:\n                 - CX_OK on success\n                 - CX_NOT_UNLOCKED\n                 - CX_INVALID_PARAMETER_SIZE\n                 - CX_NOT_LOCKED\n                 - CX_MEMORY_FULL\n                 - CX_INVALID_PARAMETER"]
    pub fn cx_math_subm_no_throw(
        r: *mut u8,
        a: *const u8,
        b: *const u8,
        m: *const u8,
        len: usize,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief Performs a modular multiplication of\n        two integers represented as byte arrays.\n\n @param[out] r   Buffer for the result.\n\n @param[in]  a   Pointer to the first integer.\n\n @param[in]  b   Pointer to the second integer.\n                 This must be strictly smaller than the modulus.\n\n @param[in]  m   Modulus\n\n @param[in]  len Number of bytes taken into account for the operation.\n\n @return         Error code:\n                 - CX_OK on success\n                 - CX_NOT_UNLOCKED\n                 - CX_INVALID_PARAMETER_SIZE\n                 - CX_NOT_LOCKED\n                 - CX_MEMORY_FULL\n                 - CX_INVALID_PARAMETER\n                 - CX_INVALID_PARAMETER_VALUE"]
    pub fn cx_math_multm_no_throw(
        r: *mut u8,
        a: *const u8,
        b: *const u8,
        m: *const u8,
        len: usize,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Performs a modular reduction.\n\n @details Computes the remainder of the division of v by m. Store the result in v.\n\n @param[in,out] v     Pointer to the dividend and buffer for the result.\n\n @param[in]     len_v Number of bytes of the dividend.\n\n @param[in]     m     Modulus.\n\n @param[in]     len_m Number of bytes of the modulus.\n\n @return              Error code:\n                      - CX_OK on success\n                      - CX_NOT_UNLOCKED\n                      - CX_INVALID_PARAMETER_SIZE\n                      - CX_NOT_LOCKED\n                      - CX_MEMORY_FULL\n                      - CX_INVALID_PARAMETER"]
    pub fn cx_math_modm_no_throw(v: *mut u8, len_v: usize, m: *const u8, len_m: usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Performs a modular exponentiation.\n\n @details Computes the result of **a^e mod m**.\n\n @param[out] r     Buffer for the result.\n\n @param[in]  a     Pointer to an integer.\n\n @param[in]  e     Pointer to the exponent.\n\n @param[in]  len_e Number of bytes of the exponent.\n\n @param[in]  m     Modulus\n\n @param[in]  len   Number of bytes of the result.\n\n @return           Error code:\n                   - CX_OK on success\n                   - CX_NOT_UNLOCKED\n                   - CX_INVALID_PARAMETER_SIZE\n                   - CX_NOT_LOCKED\n                   - CX_MEMORY_FULL\n                   - CX_INVALID_PARAMETER"]
    pub fn cx_math_powm_no_throw(
        r: *mut u8,
        a: *const u8,
        e: *const u8,
        len_e: usize,
        m: *const u8,
        len: usize,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Computes the modular inverse with a prime modulus.\n\n @details It computes the result of **a^(-1) mod m**, for a prime *m*.\n\n @param[out] r   Buffer for the result.\n\n @param[in]  a   Pointer to the integer.\n\n @param[in]  m   Modulus. Must be a prime number.\n\n @param[in]  len Number of bytes of the result.\n\n @return         Error code:\n                 - CX_OK on success\n                 - CX_NOT_UNLOCKED\n                 - CX_INVALID_PARAMETER_SIZE\n                 - CX_NOT_LOCKED\n                 - CX_MEMORY_FULL\n                 - CX_INVALID_PARAMETER"]
    pub fn cx_math_invprimem_no_throw(
        r: *mut u8,
        a: *const u8,
        m: *const u8,
        len: usize,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Computes the modular inverse.\n\n @details It computes the result of **a^(-1) mod m**. *a* must be invertible modulo *m*,\n          i.e. the greatest common divisor of *a* and *m* is 1.\n\n @param[out] r   Buffer for the result.\n\n @param[in]  a   Pointer to the integer.\n\n @param[in]  m   Modulus.\n\n @param[in]  len Number of bytes of the result.\n\n @return         Error code:\n                 - CX_OK on success\n                 - CX_NOT_UNLOCKED\n                 - CX_INVALID_PARAMETER_SIZE\n                 - CX_NOT_LOCKED\n                 - CX_MEMORY_FULL\n                 - CX_INVALID_PARAMETER"]
    pub fn cx_math_invintm_no_throw(r: *mut u8, a: u32, m: *const u8, len: usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief Checks whether a number is probably prime.\n\n @param[in]  r     Pointer to an integer.\n\n @param[in]  len   Number of bytes of the integer.\n\n @param[out] prime Bool indicating whether r is prime or not:\n                   - 0 : not prime\n                   - 1 : prime\n\n @return           Error code:\n                   - CX_OK on success\n                   - CX_NOT_UNLOCKED\n                   - CX_INVALID_PARAMETER_SIZE\n                   - CX_NOT_LOCKED\n                   - CX_MEMORY_FULL\n                   - CX_INVALID_PARAMETER"]
    pub fn cx_math_is_prime_no_throw(r: *const u8, len: usize, prime: *mut bool) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief Computes the next prime after a given number.\n\n @param[in, out] r   Pointer to the integer and buffer for the result.\n\n @param[in]      len Number of bytes of the integer.\n\n @return             Error code:\n                     - CX_OK on success\n                     - CX_NOT_UNLOCKED\n                     - CX_INVALID_PARAMETER_SIZE\n                     - CX_MEMORY_FULL\n                     - CX_NOT_LOCKED\n                     - CX_INVALID_PARAMETER\n                     - CX_INTERNAL_ERROR\n                     - CX_OVERFLOW"]
    pub fn cx_math_next_prime_no_throw(r: *mut u8, len: u32) -> cx_err_t;
}
#[doc = "< No cipher"]
pub const cx_cipher_id_t_CX_CIPHER_NONE: cx_cipher_id_t = 0;
#[doc = "< AES with a 128-bit key"]
pub const cx_cipher_id_t_CX_CIPHER_AES_128: cx_cipher_id_t = 1;
#[doc = "< AES with a 192-bit key"]
pub const cx_cipher_id_t_CX_CIPHER_AES_192: cx_cipher_id_t = 2;
#[doc = "< AES with a 256-bit key"]
pub const cx_cipher_id_t_CX_CIPHER_AES_256: cx_cipher_id_t = 3;
#[doc = "< DES with a 64-bit key"]
pub const cx_cipher_id_t_CX_CIPHER_DES_64: cx_cipher_id_t = 4;
#[doc = "< 3DES with two keys"]
pub const cx_cipher_id_t_CX_CIPHER_3DES_128: cx_cipher_id_t = 5;
#[doc = "< 3DES with three keys"]
pub const cx_cipher_id_t_CX_CIPHER_3DES_192: cx_cipher_id_t = 6;
#[doc = " Supported cipher identifiers"]
pub type cx_cipher_id_t = cty::c_uint;
#[doc = " Generic key structure"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cipher_key_t {
    pub size: cty::c_uint,
    pub keys: [cty::c_uchar; 32usize],
}
#[test]
fn bindgen_test_layout_cipher_key_t() {
    const UNINIT: ::core::mem::MaybeUninit<cipher_key_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cipher_key_t>(),
        36usize,
        concat!("Size of: ", stringify!(cipher_key_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cipher_key_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cipher_key_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_key_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keys) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_key_t),
            "::",
            stringify!(keys)
        )
    );
}
#[doc = " Base cipher information"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cx_cipher_base_t {
    #[doc = "< Encryption function"]
    pub enc_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx_key: *const cipher_key_t,
            in_block: *const u8,
            out_block: *mut u8,
        ) -> cx_err_t,
    >,
    #[doc = "< Decryption function"]
    pub dec_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx_key: *const cipher_key_t,
            in_block: *const u8,
            out_block: *mut u8,
        ) -> cx_err_t,
    >,
    pub ctr_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx_key: *const cipher_key_t,
            len: usize,
            nc_off: *mut usize,
            nonce_counter: *mut u8,
            stream_block: *mut u8,
            input: *const u8,
            output: *mut u8,
        ) -> cx_err_t,
    >,
    pub setkey_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx_key: *const cipher_key_t,
            operation: u32,
            key: *const u8,
            key_bitlen: u32,
        ) -> cx_err_t,
    >,
    #[doc = "< Reset"]
    pub ctx_reset: ::core::option::Option<unsafe extern "C" fn() -> cx_err_t>,
}
#[test]
fn bindgen_test_layout_cx_cipher_base_t() {
    const UNINIT: ::core::mem::MaybeUninit<cx_cipher_base_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_cipher_base_t>(),
        20usize,
        concat!("Size of: ", stringify!(cx_cipher_base_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_cipher_base_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_cipher_base_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).enc_func) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cipher_base_t),
            "::",
            stringify!(enc_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).dec_func) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cipher_base_t),
            "::",
            stringify!(dec_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ctr_func) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cipher_base_t),
            "::",
            stringify!(ctr_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).setkey_func) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cipher_base_t),
            "::",
            stringify!(setkey_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ctx_reset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cipher_base_t),
            "::",
            stringify!(ctx_reset)
        )
    );
}
#[doc = " Cipher information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_cipher_info_t {
    #[doc = "< Key size"]
    pub key_bitlen: u32,
    #[doc = "< Initialization vector size"]
    pub iv_size: u32,
    #[doc = "< Block size"]
    pub block_size: u32,
    pub base: *const cx_cipher_base_t,
}
#[test]
fn bindgen_test_layout_cx_cipher_info_t() {
    const UNINIT: ::core::mem::MaybeUninit<cx_cipher_info_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_cipher_info_t>(),
        16usize,
        concat!("Size of: ", stringify!(cx_cipher_info_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_cipher_info_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_cipher_info_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_bitlen) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cipher_info_t),
            "::",
            stringify!(key_bitlen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iv_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cipher_info_t),
            "::",
            stringify!(iv_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cipher_info_t),
            "::",
            stringify!(block_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).base) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cipher_info_t),
            "::",
            stringify!(base)
        )
    );
}
impl Default for cx_cipher_info_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Generic cipher context"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_cipher_context_t {
    #[doc = "< Cipher information"]
    pub cipher_info: *const cx_cipher_info_t,
    #[doc = "< Key size in bits"]
    pub key_bitlen: u32,
    #[doc = "< Operation: encryption or decryption"]
    pub operation: u32,
    #[doc = "< Padding function"]
    pub add_padding: ::core::option::Option<
        unsafe extern "C" fn(output: *mut u8, out_len: usize, data_len: usize),
    >,
    #[doc = "< Check the padding"]
    pub get_padding: ::core::option::Option<
        unsafe extern "C" fn(input: *mut u8, in_len: usize, data_len: *mut usize) -> cx_err_t,
    >,
    #[doc = "< Data to process"]
    pub unprocessed_data: [u8; 16usize],
    #[doc = "< Length of data to process"]
    pub unprocessed_len: usize,
    #[doc = "< Initiaization vector"]
    pub iv: [u8; 16usize],
    #[doc = "< Length of the initialization vector"]
    pub iv_size: usize,
    #[doc = "< Mode of operation: ECB, CBC, CTR"]
    pub mode: u32,
    #[doc = "< Last block to be verified"]
    pub sig: [u8; 16usize],
    #[doc = "< Cipher-specific context"]
    pub cipher_key: *const cipher_key_t,
}
#[test]
fn bindgen_test_layout_cx_cipher_context_t() {
    const UNINIT: ::core::mem::MaybeUninit<cx_cipher_context_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_cipher_context_t>(),
        84usize,
        concat!("Size of: ", stringify!(cx_cipher_context_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_cipher_context_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_cipher_context_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cipher_info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cipher_context_t),
            "::",
            stringify!(cipher_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key_bitlen) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cipher_context_t),
            "::",
            stringify!(key_bitlen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).operation) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cipher_context_t),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).add_padding) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cipher_context_t),
            "::",
            stringify!(add_padding)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).get_padding) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cipher_context_t),
            "::",
            stringify!(get_padding)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unprocessed_data) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cipher_context_t),
            "::",
            stringify!(unprocessed_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).unprocessed_len) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cipher_context_t),
            "::",
            stringify!(unprocessed_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iv) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cipher_context_t),
            "::",
            stringify!(iv)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).iv_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cipher_context_t),
            "::",
            stringify!(iv_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cipher_context_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sig) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cipher_context_t),
            "::",
            stringify!(sig)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cipher_key) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_cipher_context_t),
            "::",
            stringify!(cipher_key)
        )
    );
}
impl Default for cx_cipher_context_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief   Initialize a cipher context as NONE.\n\n @details This function must be called first.\n\n @param[in] ctx Pointer to the context. This must not be NULL.\n\n @return        Error code:\n                - CX_OK on success\n                - CX_INVALID_PARAMETER"]
    pub fn cx_cipher_init(ctx: *mut cx_cipher_context_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Initialize and fill the context structure given the cipher info.\n\n @param[in] ctx  Pointer to the context.\n\n @param[in] type Cipher to use:\n                 - CX_CIPHER_AES_128\n                 - CX_CIPHER_AES_192\n                 - CX_CIPHER_AES_256\n                 - CX_CIPHER_DES_64\n                 - CX_CIPHER_3DES_128\n                 - CX_CIPHER_3DES_192\n\n @param[in] mode Mode of operation:\n                 - ECB\n                 - CBC\n                 - CTR\n\n @return         Error code:\n                 - CX_OK on success\n                 - CX_INVALID_PARAMETER\n                 - CX_INVALID_PARAMETER_VALUE"]
    pub fn cx_cipher_setup(
        ctx: *mut cx_cipher_context_t,
        type_: cx_cipher_id_t,
        mode: u32,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Set the key to use.\n\n @details This function must be called after the cipher context is initialized with\n          #cx_cipher_init.\n\n @param[in] ctx        Pointer to the context.\n\n @param[in] key        Key to use: a buffer of at least *key_bitlen* bits.\n\n @param[in] key_bitlen Length of key in bits.\n\n @param[in] operation  The operation that the key will be used for: encryption or decryption.\n\n @return               Error code:\n                       - CX_OK on success\n                       - CX_INVALID_PARAMETER\n                       - CX_INVALID_PARAMETER_SIZE\n                       - CX_INVALID_PARAMETER_VALUE"]
    pub fn cx_cipher_setkey(
        ctx: *mut cx_cipher_context_t,
        key: *const u8,
        key_bitlen: u32,
        operation: u32,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Set the initialization vector.\n\n @details This function must be called after the cipher context is initialized with\n          #cx_cipher_init.\n\n @param[in] ctx    Pointer to the context.\n\n @param[in] iv     Initialization vector: a buffer of at least *iv_len* bytes.\n\n @param[in] iv_len Length of the initialization vector in bytes.\n\n @return           Error code:\n                   - CX_OK on success\n                   - CX_INVALID_PARAMETER\n                   - CX_INVALID_PARAMETER_VALUE"]
    pub fn cx_cipher_setiv(ctx: *mut cx_cipher_context_t, iv: *const u8, iv_len: usize)
        -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Set the padding type.\n\n @details This function must be called after the cipher context is initialized with\n          #cx_cipher_init.\n\n @param[in] ctx Pointer to the context.\n\n @param[in] padding Type of padding:\n                    - CX_PAD_NONE: no padding\n                    - CX_PAD_ISO9797M1: pad with zeros only\n                    - CX_PAD_ISO9797M2: pad with a single one and several zeros.\n\n @return            Error code:\n                    - CX_OK on success\n                    - CX_INVALID_PARAMETER\n                    - CX_INVALID_PARAMETER_VALUE"]
    pub fn cx_cipher_set_padding(ctx: *mut cx_cipher_context_t, padding: u32) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Encrypt or decrypt with the given context.\n\n @details This function must be called after the cipher context is initialized with\n          #cx_cipher_init and set with #cx_cipher_setup. The key must be set with\n          #cx_cipher_setkey, the padding method to use must be set with\n          #cx_cipher_set_padding and the Initialization Vector must be set with\n          #cx_cipher_setiv.\n          One can call this function multiple times depending on the length of the data\n          that needed to be processed.\n\n @param[in]  ctx     Pointer to the context.\n\n @param[in]  input   Input data: buffer of at least *in_len* bytes.\n\n @param[in]  in_len  Length of the input in bytes.\n\n @param[out] output  Output data: a buffer of at least *in_len + block_size* bytes.\n\n @param[out] out_len Length of the data written to the output.\n\n @return             Error code:\n                     - CX_OK on success\n                     - CX_INTERNAL_ERROR\n                     - CX_INVALID_PARAMETER\n                     - CX_INVALID_PARAMETER_VALUE"]
    pub fn cx_cipher_update(
        ctx: *mut cx_cipher_context_t,
        input: *const u8,
        in_len: usize,
        output: *mut u8,
        out_len: *mut usize,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Finalize the operation.\n\n @details This function must be called after the cipher context is initialized with\n          #cx_cipher_init and set with #cx_cipher_setup. The key must be set with\n          #cx_cipher_setkey, the padding method to use must be set with\n          #cx_cipher_set_padding and the Initialization Vector must be set with\n          #cx_cipher_setiv.\n          This function must be called after the last #cx_cipher_update.\n\n @param[in]  ctx     Pointer to the context.\n\n @param[out] output  Output data: buffer of at least *block_size* bytes.\n\n @param[out] out_len Length of the data written to the output.\n\n @return             Error code:\n                     - CX_Ok on success\n                     - CX_INTERNAL_ERROR\n                     - CX_INVALID_PARAMETER\n                     - CX_INVALID_PARAMETER_VALUE"]
    pub fn cx_cipher_finish(
        ctx: *mut cx_cipher_context_t,
        output: *mut u8,
        out_len: *mut usize,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   All-in-one encryption or decryption.\n\n @details This function must be called after the cipher context is initialized with\n          #cx_cipher_init and set with #cx_cipher_setup. The key must be set with\n          #cx_cipher_setkey, the padding method to use must be set with\n          #cx_cipher_set_padding.\n\n @param[in] ctx      Pointer to the context.\n\n @param[in] iv       Initialization vector: a buffer of at least *iv_len* bytes.\n\n @param[in] iv_len   Length of the initialization vector in bytes.\n\n @param[in] input    Input data: a buffer of at least *in_len* bytes.\n\n @param[in] in_len   Length of the input in bytes.\n\n @param[out] output  Output data: a buffer of at least *in_len + block_size* bytes.\n\n @param[out] out_len Length of the output.\n\n @return             Error code:\n                     - CX_OK on success\n                     - CX_INTERNAL_ERROR\n                     - CX_INVALID_PARAMETER\n                     - CX_INVALID_PARAMETER_VALUE"]
    pub fn cx_cipher_enc_dec(
        ctx: *mut cx_cipher_context_t,
        iv: *const u8,
        iv_len: usize,
        input: *const u8,
        in_len: usize,
        output: *mut u8,
        out_len: *mut usize,
    ) -> cx_err_t;
}
extern "C" {
    pub fn cx_cipher_reset(ctx: *mut cx_cipher_context_t);
}
extern "C" {
    pub fn add_one_and_zeros_padding(output: *mut u8, out_len: usize, data_len: usize);
}
#[doc = " Elliptic Curve public key"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_public_key_s {
    #[doc = "< Curve identifier"]
    pub curve: cx_curve_t,
    #[doc = "< Public key length in bytes"]
    pub W_len: usize,
    #[doc = "< Public key value"]
    pub W: [u8; 1usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_public_key_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_ecfp_public_key_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_public_key_s>(),
        12usize,
        concat!("Size of: ", stringify!(cx_ecfp_public_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_public_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_public_key_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_public_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).W_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_public_key_s),
            "::",
            stringify!(W_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).W) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_public_key_s),
            "::",
            stringify!(W)
        )
    );
}
impl Default for cx_ecfp_public_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Elliptic Curve private key"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_private_key_s {
    #[doc = "< Curve identifier"]
    pub curve: cx_curve_t,
    #[doc = "< Private key length in bytes"]
    pub d_len: usize,
    #[doc = "< Private key value"]
    pub d: [u8; 1usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_private_key_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_ecfp_private_key_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_private_key_s>(),
        12usize,
        concat!("Size of: ", stringify!(cx_ecfp_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_private_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_private_key_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_private_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_private_key_s),
            "::",
            stringify!(d_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_private_key_s),
            "::",
            stringify!(d)
        )
    );
}
impl Default for cx_ecfp_private_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Up to 256-bit Elliptic Curve public key"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_256_public_key_s {
    #[doc = "< Curve identifier"]
    pub curve: cx_curve_t,
    #[doc = "< Public key length in bytes"]
    pub W_len: usize,
    #[doc = "< Public key value"]
    pub W: [u8; 65usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_256_public_key_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_ecfp_256_public_key_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_256_public_key_s>(),
        76usize,
        concat!("Size of: ", stringify!(cx_ecfp_256_public_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_256_public_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_256_public_key_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_public_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).W_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_public_key_s),
            "::",
            stringify!(W_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).W) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_public_key_s),
            "::",
            stringify!(W)
        )
    );
}
impl Default for cx_ecfp_256_public_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Up to 256-bit Elliptic Curve private key"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_256_private_key_s {
    #[doc = "< Curve identifier"]
    pub curve: cx_curve_t,
    #[doc = "< Private key length in bytes"]
    pub d_len: usize,
    #[doc = "< Private key value"]
    pub d: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_256_private_key_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_ecfp_256_private_key_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_256_private_key_s>(),
        40usize,
        concat!("Size of: ", stringify!(cx_ecfp_256_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_256_private_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_256_private_key_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_private_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_private_key_s),
            "::",
            stringify!(d_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_private_key_s),
            "::",
            stringify!(d)
        )
    );
}
impl Default for cx_ecfp_256_private_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Up to 256-bit Elliptic Curve extended private key"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_256_extended_private_key_s {
    #[doc = "< Curve identifier"]
    pub curve: cx_curve_t,
    #[doc = "< Public key length in bytes"]
    pub d_len: usize,
    #[doc = "< Public key value"]
    pub d: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_256_extended_private_key_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_ecfp_256_extended_private_key_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_256_extended_private_key_s>(),
        72usize,
        concat!("Size of: ", stringify!(cx_ecfp_256_extended_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_256_extended_private_key_s>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cx_ecfp_256_extended_private_key_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_extended_private_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_extended_private_key_s),
            "::",
            stringify!(d_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_extended_private_key_s),
            "::",
            stringify!(d)
        )
    );
}
impl Default for cx_ecfp_256_extended_private_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Up to 256-bit Elliptic Curve public key"]
pub type cx_ecfp_256_public_key_t = cx_ecfp_256_public_key_s;
#[doc = " Up to 256-bit Elliptic Curve private key"]
pub type cx_ecfp_256_private_key_t = cx_ecfp_256_private_key_s;
#[doc = " Up to 256-bit Elliptic Curve extended private key"]
pub type cx_ecfp_256_extended_private_key_t = cx_ecfp_256_extended_private_key_s;
#[doc = " Up to 256-bit Elliptic Curve public key"]
pub type cx_ecfp_public_key_t = cx_ecfp_256_public_key_s;
#[doc = " Up to 256-bit Elliptic Curve private key"]
pub type cx_ecfp_private_key_t = cx_ecfp_256_private_key_s;
#[doc = " Up to 384-bit Elliptic Curve public key"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_384_public_key_s {
    #[doc = "< Curve identifier"]
    pub curve: cx_curve_t,
    #[doc = "< Public key length in bytes"]
    pub W_len: usize,
    #[doc = "< Public key value"]
    pub W: [u8; 97usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_384_public_key_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_ecfp_384_public_key_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_384_public_key_s>(),
        108usize,
        concat!("Size of: ", stringify!(cx_ecfp_384_public_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_384_public_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_384_public_key_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_384_public_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).W_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_384_public_key_s),
            "::",
            stringify!(W_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).W) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_384_public_key_s),
            "::",
            stringify!(W)
        )
    );
}
impl Default for cx_ecfp_384_public_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Up to 384-bit Elliptic Curve private key"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_384_private_key_s {
    #[doc = "< Curve identifier"]
    pub curve: cx_curve_t,
    #[doc = "< Private key length in bytes"]
    pub d_len: usize,
    #[doc = "< Private key value"]
    pub d: [u8; 48usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_384_private_key_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_ecfp_384_private_key_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_384_private_key_s>(),
        56usize,
        concat!("Size of: ", stringify!(cx_ecfp_384_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_384_private_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_384_private_key_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_384_private_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_384_private_key_s),
            "::",
            stringify!(d_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_384_private_key_s),
            "::",
            stringify!(d)
        )
    );
}
impl Default for cx_ecfp_384_private_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Up to 384-bit Elliptic Curve private key"]
pub type cx_ecfp_384_private_key_t = cx_ecfp_384_private_key_s;
#[doc = " Up to 384-bit Elliptic Curve public key"]
pub type cx_ecfp_384_public_key_t = cx_ecfp_384_public_key_s;
#[doc = " Up to 512-bit Elliptic Curve public key"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_512_public_key_s {
    #[doc = "< Curve identifier"]
    pub curve: cx_curve_t,
    #[doc = "< Public key length in bytes"]
    pub W_len: usize,
    #[doc = "< Public key value"]
    pub W: [u8; 129usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_512_public_key_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_ecfp_512_public_key_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_512_public_key_s>(),
        140usize,
        concat!("Size of: ", stringify!(cx_ecfp_512_public_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_512_public_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_512_public_key_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_public_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).W_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_public_key_s),
            "::",
            stringify!(W_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).W) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_public_key_s),
            "::",
            stringify!(W)
        )
    );
}
impl Default for cx_ecfp_512_public_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Up to 512-bit Elliptic Curve private key"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_512_private_key_s {
    #[doc = "< Curve identifier"]
    pub curve: cx_curve_t,
    #[doc = "< Private key length in bytes"]
    pub d_len: usize,
    #[doc = "< Private key value"]
    pub d: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_512_private_key_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_ecfp_512_private_key_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_512_private_key_s>(),
        72usize,
        concat!("Size of: ", stringify!(cx_ecfp_512_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_512_private_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_512_private_key_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_private_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_private_key_s),
            "::",
            stringify!(d_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_private_key_s),
            "::",
            stringify!(d)
        )
    );
}
impl Default for cx_ecfp_512_private_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Up to 512-bit Elliptic Curve extended private key"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_512_extented_private_key_s {
    #[doc = "< Curve identifier"]
    pub curve: cx_curve_t,
    #[doc = "< Private key length in bytes"]
    pub d_len: usize,
    #[doc = "< Private key value"]
    pub d: [u8; 128usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_512_extented_private_key_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_ecfp_512_extented_private_key_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_512_extented_private_key_s>(),
        136usize,
        concat!("Size of: ", stringify!(cx_ecfp_512_extented_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_512_extented_private_key_s>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cx_ecfp_512_extented_private_key_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_extented_private_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_extented_private_key_s),
            "::",
            stringify!(d_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_extented_private_key_s),
            "::",
            stringify!(d)
        )
    );
}
impl Default for cx_ecfp_512_extented_private_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Up to 512-bit Elliptic Curve public key"]
pub type cx_ecfp_512_public_key_t = cx_ecfp_512_public_key_s;
#[doc = " Up to 512-bit Elliptic Curve private key"]
pub type cx_ecfp_512_private_key_t = cx_ecfp_512_private_key_s;
#[doc = " Up to 512-bit Elliptic Curve extended private key"]
pub type cx_ecfp_512_extented_private_key_t = cx_ecfp_512_extented_private_key_s;
#[doc = " Up to 640-bit Elliptic Curve public key"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_640_public_key_s {
    #[doc = "< Curve identifier"]
    pub curve: cx_curve_t,
    #[doc = "< Public key length in bytes"]
    pub W_len: usize,
    #[doc = "< Public key value"]
    pub W: [u8; 161usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_640_public_key_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_ecfp_640_public_key_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_640_public_key_s>(),
        172usize,
        concat!("Size of: ", stringify!(cx_ecfp_640_public_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_640_public_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_640_public_key_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_640_public_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).W_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_640_public_key_s),
            "::",
            stringify!(W_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).W) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_640_public_key_s),
            "::",
            stringify!(W)
        )
    );
}
impl Default for cx_ecfp_640_public_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Up to 640-bit Elliptic Curve private key"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_640_private_key_s {
    #[doc = "< Curve identifier"]
    pub curve: cx_curve_t,
    #[doc = "< Private key length in bytes"]
    pub d_len: usize,
    #[doc = "< Private key value"]
    pub d: [u8; 80usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_640_private_key_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_ecfp_640_private_key_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_640_private_key_s>(),
        88usize,
        concat!("Size of: ", stringify!(cx_ecfp_640_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_640_private_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_640_private_key_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_640_private_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_640_private_key_s),
            "::",
            stringify!(d_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_640_private_key_s),
            "::",
            stringify!(d)
        )
    );
}
impl Default for cx_ecfp_640_private_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Up to 640-bit Elliptic Curve public key"]
pub type cx_ecfp_640_public_key_t = cx_ecfp_640_public_key_s;
#[doc = " Up to 640-bit Elliptic Curve private key"]
pub type cx_ecfp_640_private_key_t = cx_ecfp_640_private_key_s;
extern "C" {
    #[doc = " @brief   Adds two points of an elliptic curve.\n\n @param[in]  curve Curve identifier.\n\n @param[out] R     Resulting point encoded as **04 || x || y**.\n\n @param[in]  P     First operand: point on curve encoded as **04 || x || y**:\n                   *x* and *y* are encoded as big endian raw values\n                   and have a binary length equal to curve domain size.\n\n @param[in]  Q     Second operand: point on curve encoded as **04 || x || y**.\n\n @return           Error code:\n                   - CX_OK on success\n                   - CX_EC_INVALID_CURVE\n                   - CX_NOT_UNLOCKED\n                   - CX_INVALID_PARAMETER_SIZE\n                   - CX_EC_INVALID_CURVE\n                   - CX_MEMORY_FULL\n                   - CX_NOT_LOCKED\n                   - CX_INVALID_PARAMETER\n                   - CX_EC_INVALID_POINT\n                   - CX_EC_INFINITE_POINT"]
    pub fn cx_ecfp_add_point_no_throw(
        curve: cx_curve_t,
        R: *mut u8,
        P: *const u8,
        Q: *const u8,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Performs a scalar multiplication over an elliptic curve.\n\n @param[in]      curve Curve identifier.\n\n @param[in, out] P     Point on curve encoded as **04 || x || y**:\n                       x and y are encoded as big endian raw values\n                       and have a binary length equal to curve domain size.\n                       This is also used for the result.\n\n @param[in]      k     Scalar encoded as big endian integer.\n\n @param[in]      k_len Length of the scalar. This should be equal to\n                       the curve domain length.\n\n @return               Error code:\n                       - CX_OK on success\n                       - CX_EC_INVALID_CURVE\n                       - CX_NOT_UNLOCKED\n                       - CX_EC_INVALID_CURVE\n                       - CX_MEMORY_FULL\n                       - CX_NOT_LOCKED\n                       - CX_INVALID_PARAMETER\n                       - CX_EC_INFINITE_POINT"]
    pub fn cx_ecfp_scalar_mult_no_throw(
        curve: cx_curve_t,
        P: *mut u8,
        k: *const u8,
        k_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Initializes a public key.\n\n @param[in]  curve   Curve identifier.\n\n @param[in]  rawkey  Pointer to a raw key value or NULL pointer\n                     The value shall be the public point encoded as:\n                      - **04 || x || y** for Weiertrass curves\n                      - **04 || x || y**  or **02 || y** (plus sign) for Twisted Edward curves\n                      - **04 || x || y**  or **02 || x** for Montgomery curves\n\n                     where *x* and *y* are encoded as big endian raw values and have a\n                     binary length equal to the curve domain size.\n\n @param[in]  key_len Length of the key.\n\n @param[out] key     Public key to initialize.\n\n @return             Error code:\n                     - CX_OK on success\n                     - CX_EC_INVALID_CURVE\n                     - INVALID_PARAMETER"]
    pub fn cx_ecfp_init_public_key_no_throw(
        curve: cx_curve_t,
        rawkey: *const u8,
        key_len: usize,
        key: *mut cx_ecfp_public_key_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Initializes a private key.\n\n @details The key can be stored in non-volatile memory and\n          used for ECDSA or ECDH processing.\n\n @param[in]  curve   Curve identifier.\n\n @param[in]  rawkey  Pointer to a raw key value or NULL pointer.\n                     The value shall be in big endian order.\n\n @param[in]  key_len Length of the key.\n\n @param[out] pvkey   Private key to initialize.\n\n @return             Error code:\n                     - CX_OK on success\n                     - CX_EC_INVALID_CURVE\n                     - CX_INVALID_PARAMETER"]
    pub fn cx_ecfp_init_private_key_no_throw(
        curve: cx_curve_t,
        rawkey: *const u8,
        key_len: usize,
        pvkey: *mut cx_ecfp_private_key_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Generates a key pair with SHA-512 hash function.\n\n @param[in]  curve       Curve identifier.\n\n @param[out] pubkey      Generated public key.\n\n @param[out] privkey     Generated private key.\n\n @param[in]  keepprivate If set, the private key is the one initialized\n                         with #cx_ecfp_init_private_key_no_throw. Otherwise,\n                         a new private key is generated.\n\n @return                 Error code:\n                         - CX_OK on success\n                         - CX_EC_INVALID_CURVE\n                         - CX_NOT_UNLOCKED\n                         - CX_INVALID_PARAMETER_SIZE\n                         - CX_MEMORY_FULL\n                         - CX_NOT_LOCKED\n                         - CX_INVALID_PARAMETER\n                         - CX_INTERNAL_ERROR\n                         - CX_EC_INVALID_POINT\n                         - CX_EC_INFINITE_POINT"]
    pub fn cx_ecfp_generate_pair_no_throw(
        curve: cx_curve_t,
        pubkey: *mut cx_ecfp_public_key_t,
        privkey: *mut cx_ecfp_private_key_t,
        keepprivate: bool,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Generates a key pair.\n\n @param[in]  curve       Curve identifier.\n\n @param[out] pubkey      Generated public key.\n\n @param[out] privkey     Generated private key.\n\n @param[in]  keepprivate If set, the private key is the one initialized with\n                         #cx_ecfp_init_private_key_no_throw.\n                         Otherwise, a new private key is generated.\n\n @param[in]  hashID      Message digest algorithm identifier.\n\n @return                 Error code:\n                         - CX_OK on success\n                         - CX_EC_INVALID_CURVE\n                         - CX_NOT_UNLOCKED\n                         - CX_INVALID_PARAMETER_SIZE\n                         - CX_MEMORY_FULL\n                         - CX_NOT_LOCKED\n                         - CX_INVALID_PARAMETER\n                         - CX_INTERNAL_ERROR\n                         - CX_EC_INVALID_POINT\n                         - CX_EC_INFINITE_POINT"]
    pub fn cx_ecfp_generate_pair2_no_throw(
        curve: cx_curve_t,
        pubkey: *mut cx_ecfp_public_key_t,
        privkey: *mut cx_ecfp_private_key_t,
        keepprivate: bool,
        hashID: cx_md_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Retrieves an EDDSA public key.\n\n @details Retrieves (a,h) = (Kr, Kl), such that (Kr, Kl) = Hash(pv_key)\n          as specified at <a href=\"https://tools.ietf.org/html/rfc8032\"> RFC8032 </a>.\n\n @param[in]  pvkey  A private key fully initialized with #cx_ecfp_init_private_key_no_throw.\n\n @param[in]  hashID Message digest algorithm identifier used to compute the input data.\n                    SHA512, SHA3 and Keccak are supported.\n\n @param[out] pukey  Key container for retrieving the public key A.\n\n @param[out] a      Private scalar such that A = a.B.\n\n @param[in]  a_len  Length of the scalar a.\n\n @param[out] h      Signature prefix.\n\n @param[in]  h_len  Length of the prefix h.\n\n @return            Error code:\n                    - CX_OK on success\n                    - CX_EC_INVALID_CURVE\n                    - CX_NOT_UNLOCKED\n                    - CX_INVALID_PARAMETER_SIZE\n                    - CX_INVALID_PARAMETER\n                    - CX_NOT_LOCKED\n                    - CX_MEMORY_FULL\n                    - CX_EC_INVALID_POINT\n                    - CX_EC_INFINITE_POINT\n                    - CX_INTERNAL_ERROR\n"]
    pub fn cx_eddsa_get_public_key_no_throw(
        pvkey: *const cx_ecfp_private_key_t,
        hashID: cx_md_t,
        pukey: *mut cx_ecfp_public_key_t,
        a: *mut u8,
        a_len: usize,
        h: *mut u8,
        h_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Compresses a point according to\n          <a href=\"https://tools.ietf.org/html/rfc8032\"> RFC8032 </a>.\n\n @param[in]      curve Curve identifier. The curve must be\n                       a Twisted Edwards curve.\n\n @param[in, out] p     Pointer to the point to compress.\n\n @param[in]      p_len Length of the point buffer.\n\n @return               Error code:\n                       - CX_OK on success\n                       - CX_EC_INVALID_CURVE\n                       - CX_NOT_UNLOCKED\n                       - CX_INVALID_PARAMETER_SIZE\n                       - CX_EC_INVALID_CURVE\n                       - CX_MEMORY_FULL\n                       - CX_NOT_LOCKED\n                       - CX_INVALID_PARAMETER\n                       - CX_EC_INFINITE_POINT"]
    pub fn cx_edwards_compress_point_no_throw(
        curve: cx_curve_t,
        p: *mut u8,
        p_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Decompresses a point according to\n          <a href=\"https://tools.ietf.org/html/rfc8032\"> RFC8032 </a>.\n\n @param[in]      curve Curve identifier. The curve must be\n                       a Twisted Edwards curve.\n\n @param[in, out] p     Pointer to the point to decompress.\n\n @param[in]      p_len Length of the point buffer.\n\n @return               Error code:\n                       - CX_OK on success\n                       - CX_EC_INVALID_CURVE\n                       - CX_NOT_UNLOCKED\n                       - CX_INVALID_PARAMETER_SIZE\n                       - CX_EC_INVALID_CURVE\n                       - CX_MEMORY_FULL\n                       - CX_NOT_LOCKED\n                       - CX_INVALID_PARAMETER\n                       - CX_EC_INFINITE_POINT\n                       - CX_NO_RESIDUE\n                       - INVALID_PARAMETER"]
    pub fn cx_edwards_decompress_point_no_throw(
        curve: cx_curve_t,
        p: *mut u8,
        p_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Signs a message digest according to ECDSA specification\n\n @param[in]  pvkey    Private key.\n                      Shall be initialized with #cx_ecfp_init_private_key_no_throw.\n\n @param[in]  mode     Crypto mode flags.\n                      Supported flags:\n                        - CX_RND_TRNG\n                        - CX_RND_RFC6979\n\n @param[in]  hashID   Message digest algorithm identifier.\n                      This parameter is mandatory with the flag CX_RND_RFC6979.\n\n @param[in]  hash     Digest of the message to be signed.\n                      The length of *hash* must be shorter than the group order size.\n                      Otherwise it is truncated.\n\n @param[in]  hash_len Length of the digest in octets.\n\n @param[out] sig      Buffer where to store the signature.\n                      The signature is encoded in TLV:  **30 || L || 02 || Lr || r || 02 || Ls || s**\n\n @param[in]  sig_len  Length of the buffer in octets.\n\n @param[out] info     Set with CX_ECCINFO_PARITY_ODD if the y-coordinate is odd when computing **[k].G**.\n\n @return              Error code:\n                      - CX_OK on success\n                      - CX_EC_INVALID_CURVE\n                      - CX_INVALID_PARAMETER\n                      - CX_INTERNAL_ERROR\n                      - CX_NOT_UNLOCKED\n                      - CX_INVALID_PARAMETER_SIZE\n                      - CX_MEMORY_FULL\n                      - CX_NOT_LOCKED\n                      - CX_EC_INVALID_POINT\n                      - CX_EC_INFINITE_POINT\n                      - CX_INVALID_PARAMETER_VALUE"]
    pub fn cx_ecdsa_sign_no_throw(
        pvkey: *const cx_ecfp_private_key_t,
        mode: u32,
        hashID: cx_md_t,
        hash: *const u8,
        hash_len: usize,
        sig: *mut u8,
        sig_len: *mut usize,
        info: *mut u32,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Verifies an ECDSA signature according to ECDSA specification.\n\n @param[in] pukey    Public key initialized with #cx_ecfp_init_public_key_no_throw.\n\n @param[in] hash     Digest of the message to be verified.\n                     The length of *hash* must be smaller than the group order size.\n                     Otherwise it is truncated.\n\n @param[in] hash_len Length of the digest in octets.\n\n @param[in] sig      Pointer to the signature encoded in TLV: **30 || L || 02 || Lr || r || 02 || Ls || s**\n\n @param[in] sig_len  Length of the signature in octets.\n\n @return             1 if the signature is verified, 0 otherwise."]
    pub fn cx_ecdsa_verify_no_throw(
        pukey: *const cx_ecfp_public_key_t,
        hash: *const u8,
        hash_len: usize,
        sig: *const u8,
        sig_len: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief   Signs a message digest.\n\n @details The signature is done according to the EDDSA specification\n          <a href=\"https://tools.ietf.org/html/rfc8032\"> RFC8032 </a>.\n\n @param[in]  pvkey    Private key.\n                      This shall be initialized with #cx_ecfp_init_private_key_no_throw.\n\n @param[in]  hashID   Message digest algorithm identifier.\n                      Algorithms supported:\n                        - SHA512\n                        - SHA3\n                        - Keccak\n\n @param[in]  hash     Pointer to the message digest.\n\n @param[in]  hash_len Length of the digest.\n\n @param[out] sig      Buffer where to store the signature.\n\n @param[in]  sig_len  Length of the signature.\n\n @return              Error code:\n                      - CX_OK on success\n                      - CX_EC_INVALID_CURVE\n                      - CX_INVALID_PARAMETER\n                      - INVALID_PARAMETER\n                      - CX_NOT_UNLOCKED\n                      - CX_INVALID_PARAMETER_SIZE\n                      - CX_MEMORY_FULL\n                      - CX_NOT_LOCKED\n                      - CX_INVALID_PARAMETER_SIZE\n                      - CX_EC_INVALID_POINT\n                      - CX_EC_INFINITE_POINT\n                      - CX_INTERNAL_ERROR\n                      - CX_INVALID_PARAMETER_VALUE"]
    pub fn cx_eddsa_sign_no_throw(
        pvkey: *const cx_ecfp_private_key_t,
        hashID: cx_md_t,
        hash: *const u8,
        hash_len: usize,
        sig: *mut u8,
        sig_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Verifies a signature.\n\n @details The verification is done according to the specification\n          <a href=\"https://tools.ietf.org/html/rfc8032\"> RFC8032 </a>.\n\n @param[in]  pukey    Public key.\n                      This shall be initialized with #cx_ecfp_init_public_key_no_throw.\n\n @param[in]  hashID   Message digest algorithm identifier.\n                      Algorithms supported:\n                        - SHA512\n                        - SHA3\n                        - Keccak\n\n @param[in]  hash     Pointer to the message digest.\n\n @param[in]  hash_len Length of the digest.\n\n @param[out] sig      Pointer to the signature.\n\n @param[in]  sig_len  Length of the signature.\n\n @return              1 if the signature is verified, otherwise 0."]
    pub fn cx_eddsa_verify_no_throw(
        pukey: *const cx_ecfp_public_key_t,
        hashID: cx_md_t,
        hash: *const u8,
        hash_len: usize,
        sig: *const u8,
        sig_len: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief   Encodes the curve point coordinates.\n\n @param[in, out] coord A pointer to the point coordinates in the form x|y.\n\n @param[in]      len   Length of the coordinates.\n\n @param[in]      sign  Sign of the x-coordinate.\n"]
    pub fn cx_encode_coord(coord: *mut u8, len: cty::c_int, sign: cty::c_int);
}
extern "C" {
    #[doc = " @brief   Decodes the curve point coordinates.\n\n @param[in, out] coord A pointer to the point encoded coordinates.\n\n @param[in]      len   Length of the encoded coordinates.\n\n @return               Sign of the x-coordinate."]
    pub fn cx_decode_coord(coord: *mut u8, len: cty::c_int) -> cty::c_int;
}
