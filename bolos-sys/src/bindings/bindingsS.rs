/* automatically generated by rust-bindgen 0.64.0 */

pub const BOLOS_VERSION: &[u8; 6usize] = b"2.1.0\0";
pub const IO_SEPROXYHAL_BUFFER_SIZE_B: u32 = 128;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const _NEWLIB_VERSION_H__: u32 = 1;
pub const _NEWLIB_VERSION: &[u8; 6usize] = b"3.3.0\0";
pub const __NEWLIB__: u32 = 3;
pub const __NEWLIB_MINOR__: u32 = 3;
pub const __NEWLIB_PATCHLEVEL__: u32 = 0;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __ATFILE_VISIBLE: u32 = 1;
pub const __BSD_VISIBLE: u32 = 1;
pub const __GNU_VISIBLE: u32 = 0;
pub const __ISO_C_VISIBLE: u32 = 2011;
pub const __LARGEFILE_VISIBLE: u32 = 0;
pub const __MISC_VISIBLE: u32 = 1;
pub const __POSIX_VISIBLE: u32 = 200809;
pub const __SVID_VISIBLE: u32 = 1;
pub const __XSI_VISIBLE: u32 = 0;
pub const __SSP_FORTIFY_LEVEL: u32 = 0;
pub const __have_longlong64: u32 = 1;
pub const __have_long32: u32 = 1;
pub const ___int8_t_defined: u32 = 1;
pub const ___int16_t_defined: u32 = 1;
pub const ___int32_t_defined: u32 = 1;
pub const ___int64_t_defined: u32 = 1;
pub const ___int_least8_t_defined: u32 = 1;
pub const ___int_least16_t_defined: u32 = 1;
pub const ___int_least32_t_defined: u32 = 1;
pub const ___int_least64_t_defined: u32 = 1;
pub const __int20: u32 = 2;
pub const __int20__: u32 = 2;
pub const __INT8: &[u8; 3usize] = b"hh\0";
pub const __INT16: &[u8; 2usize] = b"h\0";
pub const __INT64: &[u8; 3usize] = b"ll\0";
pub const __FAST8: &[u8; 3usize] = b"hh\0";
pub const __FAST16: &[u8; 2usize] = b"h\0";
pub const __FAST64: &[u8; 3usize] = b"ll\0";
pub const __LEAST8: &[u8; 3usize] = b"hh\0";
pub const __LEAST16: &[u8; 2usize] = b"h\0";
pub const __LEAST64: &[u8; 3usize] = b"ll\0";
pub const __int8_t_defined: u32 = 1;
pub const __int16_t_defined: u32 = 1;
pub const __int32_t_defined: u32 = 1;
pub const __int64_t_defined: u32 = 1;
pub const __int_least8_t_defined: u32 = 1;
pub const __int_least16_t_defined: u32 = 1;
pub const __int_least32_t_defined: u32 = 1;
pub const __int_least64_t_defined: u32 = 1;
pub const __int_fast8_t_defined: u32 = 1;
pub const __int_fast16_t_defined: u32 = 1;
pub const __int_fast32_t_defined: u32 = 1;
pub const __int_fast64_t_defined: u32 = 1;
pub const WINT_MIN: u32 = 0;
pub const CX_OK: u32 = 0;
pub const CX_CARRY: u32 = 4294967073;
pub const CX_LOCKED: u32 = 4294967169;
pub const CX_UNLOCKED: u32 = 4294967170;
pub const CX_NOT_LOCKED: u32 = 4294967171;
pub const CX_NOT_UNLOCKED: u32 = 4294967172;
pub const CX_INTERNAL_ERROR: u32 = 4294967173;
pub const CX_INVALID_PARAMETER_SIZE: u32 = 4294967174;
pub const CX_INVALID_PARAMETER_VALUE: u32 = 4294967175;
pub const CX_INVALID_PARAMETER: u32 = 4294967176;
pub const CX_NOT_INVERTIBLE: u32 = 4294967177;
pub const CX_OVERFLOW: u32 = 4294967178;
pub const CX_MEMORY_FULL: u32 = 4294967179;
pub const CX_NO_RESIDUE: u32 = 4294967180;
pub const CX_EC_INFINITE_POINT: u32 = 4294967105;
pub const CX_EC_INVALID_POINT: u32 = 4294967202;
pub const CX_EC_INVALID_CURVE: u32 = 4294967203;
pub const CX_AES_BLOCK_SIZE: u32 = 16;
pub const CX_BN_WORD_ALIGNEMENT: u32 = 16;
pub const CX_BN_FLAG_UNSET: u32 = 128;
pub const CX_DES_BLOCK_SIZE: u32 = 8;
pub const CX_MAX_DOMAIN_LENGTH: u32 = 66;
pub const CX_ECCINFO_PARITY_ODD: u32 = 1;
pub const CX_ECCINFO_xGTn: u32 = 2;
pub const CX_LAST: u32 = 1;
pub const CX_SIG_MODE: u32 = 2;
pub const CX_MASK_SIGCRYPT: u32 = 6;
pub const CX_ENCRYPT: u32 = 4;
pub const CX_DECRYPT: u32 = 0;
pub const CX_SIGN: u32 = 6;
pub const CX_VERIFY: u32 = 2;
pub const CX_MASK_PAD: u32 = 56;
pub const CX_PAD_NONE: u32 = 0;
pub const CX_PAD_ISO9797M1: u32 = 8;
pub const CX_PAD_ISO9797M2: u32 = 16;
pub const CX_PAD_PKCS1_1o5: u32 = 24;
pub const CX_PAD_PKCS1_PSS: u32 = 32;
pub const CX_PAD_PKCS1_OAEP: u32 = 40;
pub const CX_MASK_CHAIN: u32 = 448;
pub const CX_CHAIN_ECB: u32 = 0;
pub const CX_CHAIN_CBC: u32 = 64;
pub const CX_CHAIN_CTR: u32 = 128;
pub const CX_CHAIN_CFB: u32 = 192;
pub const CX_CHAIN_OFB: u32 = 256;
pub const CX_MASK_ECC_VARIANT: u32 = 448;
pub const CX_NO_CANONICAL: u32 = 64;
pub const CX_MASK_RND: u32 = 3584;
pub const CX_RND_PRNG: u32 = 512;
pub const CX_RND_TRNG: u32 = 1024;
pub const CX_RND_RFC6979: u32 = 1536;
pub const CX_RND_PROVIDED: u32 = 2048;
pub const CX_MASK_EC: u32 = 28672;
pub const CX_ECSCHNORR_BIP0340: u32 = 0;
pub const CX_ECDH_POINT: u32 = 4096;
pub const CX_ECDH_X: u32 = 8192;
pub const CX_ECSCHNORR_ISO14888_XY: u32 = 12288;
pub const CX_ECSCHNORR_ISO14888_X: u32 = 16384;
pub const CX_ECSCHNORR_BSI03111: u32 = 20480;
pub const CX_ECSCHNORR_LIBSECP: u32 = 24576;
pub const CX_ECSCHNORR_Z: u32 = 28672;
pub const CX_NO_REINIT: u32 = 32768;
pub const APPLICATION_FLAG_MAIN: u32 = 1;
pub const APPLICATION_FLAG_BOLOS_UPGRADE: u32 = 2;
pub const APPLICATION_FLAG_SIGNED: u32 = 4;
pub const APPLICATION_FLAG_BOLOS_UX: u32 = 8;
pub const APPLICATION_FLAG_DERIVE_MASTER: u32 = 16;
pub const APPLICATION_FLAG_SHARED_NVRAM: u32 = 32;
pub const APPLICATION_FLAG_GLOBAL_PIN: u32 = 64;
pub const APPLICATION_FLAG_DEBUG: u32 = 128;
pub const APPLICATION_FLAG_AUTOBOOT: u32 = 256;
pub const APPLICATION_FLAG_BOLOS_SETTINGS: u32 = 512;
pub const APPLICATION_FLAG_CUSTOM_CA: u32 = 1024;
pub const APPLICATION_FLAG_LIBRARY: u32 = 2048;
pub const APPLICATION_FLAG_NO_RUN: u32 = 4096;
pub const APPLICATION_FLAG_ISSUER: u32 = 16384;
pub const APPLICATION_FLAG_ENABLED: u32 = 32768;
pub const APPLICATION_FLAG_AEM_PIN: u32 = 8;
pub const APPLICATION_FLAG_NEG_MASK: u32 = 4294901760;
pub const TARGET_ID: u32 = 823132164;
pub const ERR_IOL_RANGE: u32 = 4096;
pub const ERR_TSK_RANGE: u32 = 8192;
pub const ERR_CRY_RANGE: u32 = 12288;
pub const ERR_PAR_RANGE: u32 = 16384;
pub const ERR_SEC_RANGE: u32 = 20480;
pub const ERR_APD_RANGE: u32 = 24576;
pub const ERR_MUI_RANGE: u32 = 40960;
pub const ERR_APP_RANGE_01: u32 = 45056;
pub const ERR_APP_RANGE_02: u32 = 49152;
pub const ERR_APP_RANGE_03: u32 = 53248;
pub const ERR_APP_RANGE_04: u32 = 57344;
pub const ERR_GEN_SUB_01: u32 = 256;
pub const ERR_GEN_SUB_02: u32 = 512;
pub const ERR_GEN_SUB_03: u32 = 768;
pub const ERR_GEN_SUB_04: u32 = 1024;
pub const ERR_GEN_SUB_05: u32 = 1280;
pub const ERR_GEN_SUB_06: u32 = 1536;
pub const ERR_GEN_SUB_07: u32 = 1792;
pub const ERR_GEN_SUB_08: u32 = 2048;
pub const ERR_GEN_SUB_09: u32 = 2304;
pub const ERR_GEN_SUB_0D: u32 = 3328;
pub const ERR_GEN_SUB_0E: u32 = 3584;
pub const ERR_IOL_OFW: u32 = 4352;
pub const ERR_IOL_HDR: u32 = 4608;
pub const ERR_IOL_STA: u32 = 4864;
pub const ERR_IOL_RST: u32 = 5120;
pub const ERR_TSK_STC: u32 = 8448;
pub const ERR_TSK_OWN: u32 = 8704;
pub const ERR_TSK_OFW: u32 = 8960;
pub const ERR_CRY_LEN: u32 = 12544;
pub const ERR_CRY_VAL: u32 = 12800;
pub const ERR_PAR_LEN: u32 = 16640;
pub const ERR_PAR_VAL: u32 = 16896;
pub const ERR_SEC_APP: u32 = 20736;
pub const ERR_SEC_CRC: u32 = 20992;
pub const ERR_SEC_CHK: u32 = 21248;
pub const ERR_SEC_KEY: u32 = 21504;
pub const ERR_SEC_PIN: u32 = 21760;
pub const ERR_SEC_SCP: u32 = 22016;
pub const ERR_SEC_SIG: u32 = 22272;
pub const ERR_SEC_MEM: u32 = 22528;
pub const ERR_SEC_STA: u32 = 22784;
pub const ERR_APD_CLA: u32 = 28160;
pub const ERR_APD_INS: u32 = 27904;
pub const ERR_APD_HDR: u32 = 25856;
pub const ERR_APD_STA: u32 = 26112;
pub const ERR_APD_LEN: u32 = 26368;
pub const ERR_APD_DAT: u32 = 26624;
pub const SWO_SUCCESS: u32 = 36864;
pub const EXCEPTION: u32 = 1;
pub const INVALID_PARAMETER: u32 = 2;
pub const EXCEPTION_SECURITY: u32 = 3;
pub const INVALID_STATE: u32 = 4;
pub const EXCEPTION_IO_RESET: u32 = 5;
pub const NOT_ENOUGH_SPACE: u32 = 6;
pub const EXCEPTION_OVERFLOW: u32 = 7;
pub const INVALID_CRC: u32 = 8;
pub const INVALID_CHECKSUM: u32 = 9;
pub const INVALID_COUNTER: u32 = 10;
pub const NOT_SUPPORTED: u32 = 11;
pub const TIMEOUT: u32 = 12;
pub const EXCEPTION_PIC: u32 = 13;
pub const EXCEPTION_APPEXIT: u32 = 14;
pub const EXCEPTION_IO_OVERFLOW: u32 = 15;
pub const EXCEPTION_IO_HEADER: u32 = 16;
pub const EXCEPTION_IO_STATE: u32 = 17;
pub const EXCEPTION_CXPORT: u32 = 18;
pub const EXCEPTION_SYSTEM: u32 = 19;
pub const OS_PARSE_BERTLV_OFFSET_COMPARE_WITH_BUFFER: u32 = 2147483648;
pub const OS_PARSE_BERTLV_OFFSET_GET_LENGTH: u32 = 1073741824;
pub const CX_HASH_MAX_BLOCK_COUNT: u32 = 65535;
pub const CX_RIPEMD160_SIZE: u32 = 20;
pub const CX_SHA256_SIZE: u32 = 32;
pub const CX_SHA384_SIZE: u32 = 48;
pub const CX_SHA512_SIZE: u32 = 64;
pub const IO_USB_MAX_ENDPOINTS: u32 = 7;
pub const IO_HID_EP_LENGTH: u32 = 64;
pub const USB_SEGMENT_SIZE: u32 = 64;
pub const WEBUSB_URL_SIZE_B: u32 = 0;
pub const WEBUSB_URL: &[u8; 1usize] = b"\0";
pub const BAGL_NOFILL: u32 = 0;
pub const BAGL_FILL: u32 = 1;
pub const BAGL_OUTLINE: u32 = 2;
pub const BAGL_NOICON: u32 = 3;
pub const BAGL_FILL_CIRCLE_1_OCTANT: u32 = 1;
pub const BAGL_FILL_CIRCLE_2_OCTANT: u32 = 2;
pub const BAGL_FILL_CIRCLE_3_OCTANT: u32 = 4;
pub const BAGL_FILL_CIRCLE_4_OCTANT: u32 = 8;
pub const BAGL_FILL_CIRCLE_5_OCTANT: u32 = 16;
pub const BAGL_FILL_CIRCLE_6_OCTANT: u32 = 32;
pub const BAGL_FILL_CIRCLE_7_OCTANT: u32 = 64;
pub const BAGL_FILL_CIRCLE_8_OCTANT: u32 = 128;
pub const BAGL_FILL_CIRCLE: u32 = 255;
pub const BAGL_FILL_CIRCLE_3PI2_2PI: u32 = 3;
pub const BAGL_FILL_CIRCLE_PI_3PI2: u32 = 12;
pub const BAGL_FILL_CIRCLE_0_PI2: u32 = 48;
pub const BAGL_FILL_CIRCLE_PI2_PI: u32 = 192;
pub const BAGL_TYPE_FLAGS_MASK: u32 = 128;
pub const BAGL_FONT_ID_MASK: u32 = 4095;
pub const BAGL_FONT_ALIGNMENT_HORIZONTAL_MASK: u32 = 49152;
pub const BAGL_FONT_ALIGNMENT_LEFT: u32 = 0;
pub const BAGL_FONT_ALIGNMENT_RIGHT: u32 = 16384;
pub const BAGL_FONT_ALIGNMENT_CENTER: u32 = 32768;
pub const BAGL_FONT_ALIGNMENT_VERTICAL_MASK: u32 = 12288;
pub const BAGL_FONT_ALIGNMENT_TOP: u32 = 0;
pub const BAGL_FONT_ALIGNMENT_BOTTOM: u32 = 4096;
pub const BAGL_FONT_ALIGNMENT_MIDDLE: u32 = 8192;
pub const BAGL_STROKE_FLAG_ONESHOT: u32 = 128;
pub const BAGL_ENCODING_LATIN1: u32 = 0;
pub const BAGL_FONT_SYMBOLS_0_CLEAR: [u8; 2usize] = [128u8, 0u8];
pub const BAGL_FONT_SYMBOLS_0_DOT: [u8; 2usize] = [129u8, 0u8];
pub const BAGL_FONT_SYMBOLS_0_LEFT: [u8; 2usize] = [130u8, 0u8];
pub const BAGL_FONT_SYMBOLS_0_LIGHTNING: [u8; 2usize] = [131u8, 0u8];
pub const BAGL_FONT_SYMBOLS_0_MINIRIGHT: [u8; 2usize] = [132u8, 0u8];
pub const BAGL_FONT_SYMBOLS_0_DASHBOARD: [u8; 2usize] = [133u8, 0u8];
pub const BAGL_FONT_SYMBOLS_0_SETTINGS: [u8; 2usize] = [134u8, 0u8];
pub const BAGL_FONT_SYMBOLS_0_EXIT: [u8; 2usize] = [135u8, 0u8];
pub const BAGL_FONT_SYMBOLS_1_CARET: [u8; 2usize] = [160u8, 0u8];
pub const ENDORSEMENT_MAX_ASN1_LENGTH: u32 = 72;
pub const BOLOS_TRUE: u32 = 170;
pub const BOLOS_FALSE: u32 = 85;
pub const BOLOS_UX_OK: u32 = 170;
pub const BOLOS_UX_CANCEL: u32 = 85;
pub const BOLOS_UX_ERROR: u32 = 214;
pub const BOLOS_UX_IGNORE: u32 = 151;
pub const BOLOS_UX_REDRAW: u32 = 105;
pub const BOLOS_UX_CONTINUE: u32 = 0;
pub const OS_FLAG_RECOVERY: u32 = 1;
pub const OS_FLAG_SIGNED_MCU_CODE: u32 = 2;
pub const OS_FLAG_ONBOARDED: u32 = 4;
pub const OS_FLAG_PIN_VALIDATED: u32 = 128;
pub const IMPL_IO_APDU_BUFFER_SIZE: u32 = 260;
pub const IO_APDU_BUFFER_SIZE: u32 = 260;
pub const CHANNEL_APDU: u32 = 0;
pub const CHANNEL_KEYBOARD: u32 = 1;
pub const CHANNEL_SPI: u32 = 2;
pub const IO_RESET_AFTER_REPLIED: u32 = 128;
pub const IO_RECEIVE_DATA: u32 = 64;
pub const IO_RETURN_AFTER_TX: u32 = 32;
pub const IO_ASYNCH_REPLY: u32 = 16;
pub const IO_FINISHED: u32 = 8;
pub const IO_FLAGS: u32 = 248;
pub const BLE_SEGMENT_SIZE: u32 = 64;
pub const NVM_ERASED_WORD_VALUE: u32 = 4294967295;
pub const DEFAULT_PIN_RETRIES: u32 = 3;
pub const __NEWLIB_H__: u32 = 1;
pub const _WANT_IO_C99_FORMATS: u32 = 1;
pub const _WANT_IO_LONG_LONG: u32 = 1;
pub const _WANT_REGISTER_FINI: u32 = 1;
pub const _REENT_CHECK_VERIFY: u32 = 1;
pub const _MB_LEN_MAX: u32 = 1;
pub const HAVE_INITFINI_ARRAY: u32 = 1;
pub const _ATEXIT_DYNAMIC_ALLOC: u32 = 1;
pub const _HAVE_LONG_DOUBLE: u32 = 1;
pub const _HAVE_CC_INHIBIT_LOOP_TO_LIBCALL: u32 = 1;
pub const _LDBL_EQ_DBL: u32 = 1;
pub const _FVWRITE_IN_STREAMIO: u32 = 1;
pub const _FSEEK_OPTIMIZATION: u32 = 1;
pub const _WIDE_ORIENT: u32 = 1;
pub const _UNBUF_STREAM_OPT: u32 = 1;
pub const _RETARGETABLE_LOCKING: u32 = 1;
pub const __OBSOLETE_MATH_DEFAULT: u32 = 1;
pub const __OBSOLETE_MATH: u32 = 1;
pub const __RAND_MAX: u32 = 2147483647;
pub const __GNUCLIKE_ASM: u32 = 3;
pub const __GNUCLIKE___TYPEOF: u32 = 1;
pub const __GNUCLIKE___OFFSETOF: u32 = 1;
pub const __GNUCLIKE___SECTION: u32 = 1;
pub const __GNUCLIKE_CTOR_SECTION_HANDLING: u32 = 1;
pub const __GNUCLIKE_BUILTIN_CONSTANT_P: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VARARGS: u32 = 1;
pub const __GNUCLIKE_BUILTIN_STDARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_VAALIST: u32 = 1;
pub const __GNUC_VA_LIST_COMPATIBILITY: u32 = 1;
pub const __GNUCLIKE_BUILTIN_NEXT_ARG: u32 = 1;
pub const __GNUCLIKE_BUILTIN_MEMCPY: u32 = 1;
pub const __CC_SUPPORTS_INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE: u32 = 1;
pub const __CC_SUPPORTS___INLINE__: u32 = 1;
pub const __CC_SUPPORTS___FUNC__: u32 = 1;
pub const __CC_SUPPORTS_WARNING: u32 = 1;
pub const __CC_SUPPORTS_VARADIC_XXX: u32 = 1;
pub const __CC_SUPPORTS_DYNAMIC_ARRAY_INIT: u32 = 1;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _NULL: u32 = 0;
pub const _ATEXIT_SIZE: u32 = 32;
pub const _RAND48_SEED_0: u32 = 13070;
pub const _RAND48_SEED_1: u32 = 43981;
pub const _RAND48_SEED_2: u32 = 4660;
pub const _RAND48_MULT_0: u32 = 58989;
pub const _RAND48_MULT_1: u32 = 57068;
pub const _RAND48_MULT_2: u32 = 5;
pub const _RAND48_ADD: u32 = 11;
pub const _REENT_EMERGENCY_SIZE: u32 = 25;
pub const _REENT_ASCTIME_SIZE: u32 = 26;
pub const _REENT_SIGNAL_SIZE: u32 = 24;
pub const _N_LISTS: u32 = 30;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _LITTLE_ENDIAN: u32 = 1234;
pub const _BIG_ENDIAN: u32 = 4321;
pub const _PDP_ENDIAN: u32 = 3412;
pub const _BYTE_ORDER: u32 = 1234;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const FD_SETSIZE: u32 = 64;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const PTHREAD_SCOPE_PROCESS: u32 = 0;
pub const PTHREAD_SCOPE_SYSTEM: u32 = 1;
pub const PTHREAD_INHERIT_SCHED: u32 = 1;
pub const PTHREAD_EXPLICIT_SCHED: u32 = 2;
pub const PTHREAD_CREATE_DETACHED: u32 = 0;
pub const PTHREAD_CREATE_JOINABLE: u32 = 1;
pub const __SLBF: u32 = 1;
pub const __SNBF: u32 = 2;
pub const __SRD: u32 = 4;
pub const __SWR: u32 = 8;
pub const __SRW: u32 = 16;
pub const __SEOF: u32 = 32;
pub const __SERR: u32 = 64;
pub const __SMBF: u32 = 128;
pub const __SAPP: u32 = 256;
pub const __SSTR: u32 = 512;
pub const __SOPT: u32 = 1024;
pub const __SNPT: u32 = 2048;
pub const __SOFF: u32 = 4096;
pub const __SORD: u32 = 8192;
pub const __SL64: u32 = 32768;
pub const __SNLK: u32 = 1;
pub const __SWID: u32 = 8192;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const EOF: i32 = -1;
pub const BUFSIZ: u32 = 1024;
pub const FOPEN_MAX: u32 = 20;
pub const FILENAME_MAX: u32 = 1024;
pub const L_tmpnam: u32 = 1024;
pub const P_tmpdir: &[u8; 5usize] = b"/tmp\0";
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const TMP_MAX: u32 = 26;
pub const L_ctermid: u32 = 16;
pub const BOLOS_APPNAME_MAX_SIZE_B: u32 = 32;
pub const BOLOS_APPVERSION_MAX_SIZE_B: u32 = 16;
pub const BOLOS_TAG_APPNAME: u32 = 1;
pub const BOLOS_TAG_APPVERSION: u32 = 2;
pub const BOLOS_TAG_ICON: u32 = 3;
pub const BOLOS_TAG_DERIVEPATH: u32 = 4;
pub const BOLOS_TAG_DATA_SIZE: u32 = 5;
pub const BOLOS_TAG_DEPENDENCY: u32 = 6;
pub const BOLOS_TAG_USER_TAG: u32 = 32;
pub const OS_REGISTRY_GET_TAG_OFFSET_COMPARE_WITH_BUFFER: u32 = 2147483648;
pub const OS_REGISTRY_GET_TAG_OFFSET_GET_LENGTH: u32 = 1073741824;
pub const BOLOS_UX_ONBOARDING_ALGORITHM_BIP39: u32 = 1;
pub const BOLOS_UX_ONBOARDING_ALGORITHM_ELECTRUM: u32 = 2;
pub const HDW_NORMAL: u32 = 0;
pub const HDW_ED25519_SLIP10: u32 = 1;
pub const HDW_SLIP21: u32 = 2;
pub const CX_APILEVEL: u32 = 12;
pub const CX_COMPAT_APILEVEL: u32 = 12;
pub const CXPORT_ED_DES: u32 = 1;
pub const CXPORT_ED_AES: u32 = 2;
pub const CXPORT_ED_RSA: u32 = 4;
pub const SYSCALL_get_api_level_ID_IN: u32 = 1610613048;
pub const SYSCALL_halt_ID_IN: u32 = 1610613308;
pub const SYSCALL_nvm_write_ID_IN: u32 = 1610613631;
pub const SYSCALL_nvm_erase_ID_IN: u32 = 1610686760;
pub const SYSCALL_cx_aes_set_key_hw_ID_IN: u32 = 1610658504;
pub const SYSCALL_cx_aes_reset_hw_ID_IN: u32 = 1610658626;
pub const SYSCALL_cx_aes_block_hw_ID_IN: u32 = 1610658830;
pub const SYSCALL_cx_des_set_key_hw_ID_IN: u32 = 1610657665;
pub const SYSCALL_cx_des_reset_hw_ID_IN: u32 = 1610658021;
pub const SYSCALL_cx_des_block_hw_ID_IN: u32 = 1610658192;
pub const SYSCALL_cx_bn_lock_ID_IN: u32 = 1610683121;
pub const SYSCALL_cx_bn_unlock_ID_IN: u32 = 1610659351;
pub const SYSCALL_cx_bn_is_locked_ID_IN: u32 = 1610659666;
pub const SYSCALL_cx_bn_alloc_ID_IN: u32 = 1610683196;
pub const SYSCALL_cx_bn_alloc_init_ID_IN: u32 = 1610683597;
pub const SYSCALL_cx_bn_destroy_ID_IN: u32 = 1610660961;
pub const SYSCALL_cx_bn_nbytes_ID_IN: u32 = 1610681643;
pub const SYSCALL_cx_bn_init_ID_IN: u32 = 1610683685;
pub const SYSCALL_cx_bn_rand_ID_IN: u32 = 1610672868;
pub const SYSCALL_cx_bn_copy_ID_IN: u32 = 1610661913;
pub const SYSCALL_cx_bn_set_u32_ID_IN: u32 = 1610662294;
pub const SYSCALL_cx_bn_get_u32_ID_IN: u32 = 1610672970;
pub const SYSCALL_cx_bn_export_ID_IN: u32 = 1610662746;
pub const SYSCALL_cx_bn_cmp_ID_IN: u32 = 1610662941;
pub const SYSCALL_cx_bn_cmp_u32_ID_IN: u32 = 1610663379;
pub const SYSCALL_cx_bn_is_odd_ID_IN: u32 = 1610684598;
pub const SYSCALL_cx_bn_xor_ID_IN: u32 = 1610664188;
pub const SYSCALL_cx_bn_or_ID_IN: u32 = 1610664423;
pub const SYSCALL_cx_bn_and_ID_IN: u32 = 1610664671;
pub const SYSCALL_cx_bn_tst_bit_ID_IN: u32 = 1610664768;
pub const SYSCALL_cx_bn_set_bit_ID_IN: u32 = 1610665207;
pub const SYSCALL_cx_bn_clr_bit_ID_IN: u32 = 1610665392;
pub const SYSCALL_cx_bn_shr_ID_IN: u32 = 1610665524;
pub const SYSCALL_cx_bn_shl_ID_IN: u32 = 1610685524;
pub const SYSCALL_cx_bn_cnt_bits_ID_IN: u32 = 1610673184;
pub const SYSCALL_cx_bn_add_ID_IN: u32 = 1610684692;
pub const SYSCALL_cx_bn_sub_ID_IN: u32 = 1610685120;
pub const SYSCALL_cx_bn_mul_ID_IN: u32 = 1610666655;
pub const SYSCALL_cx_bn_mod_add_ID_IN: u32 = 1610666754;
pub const SYSCALL_cx_bn_mod_sub_ID_IN: u32 = 1610667125;
pub const SYSCALL_cx_bn_mod_mul_ID_IN: u32 = 1610667421;
pub const SYSCALL_cx_bn_reduce_ID_IN: u32 = 1610667534;
pub const SYSCALL_cx_bn_mod_sqrt_ID_IN: u32 = 1610685805;
pub const SYSCALL_cx_bn_mod_pow_bn_ID_IN: u32 = 1610667966;
pub const SYSCALL_cx_bn_mod_pow_ID_IN: u32 = 1610673553;
pub const SYSCALL_cx_bn_mod_pow2_ID_IN: u32 = 1610673832;
pub const SYSCALL_cx_bn_mod_invert_nprime_ID_IN: u32 = 1610668782;
pub const SYSCALL_cx_bn_mod_u32_invert_ID_IN: u32 = 1610684151;
pub const SYSCALL_cx_mont_alloc_ID_IN: u32 = 1610669094;
pub const SYSCALL_cx_mont_init_ID_IN: u32 = 1610669393;
pub const SYSCALL_cx_mont_init2_ID_IN: u32 = 1610669593;
pub const SYSCALL_cx_mont_to_montgomery_ID_IN: u32 = 1610669894;
pub const SYSCALL_cx_mont_from_montgomery_ID_IN: u32 = 1610670232;
pub const SYSCALL_cx_mont_mul_ID_IN: u32 = 1610670414;
pub const SYSCALL_cx_mont_pow_ID_IN: u32 = 1610670812;
pub const SYSCALL_cx_mont_pow_bn_ID_IN: u32 = 1610670860;
pub const SYSCALL_cx_mont_invert_nprime_ID_IN: u32 = 1610671282;
pub const SYSCALL_cx_bn_is_prime_ID_IN: u32 = 1610674027;
pub const SYSCALL_cx_bn_next_prime_ID_IN: u32 = 1610674288;
pub const SYSCALL_cx_bn_rng_ID_IN: u32 = 1610734972;
pub const SYSCALL_cx_ecdomain_size_ID_IN: u32 = 1610690052;
pub const SYSCALL_cx_ecdomain_parameters_length_ID_IN: u32 = 1610690484;
pub const SYSCALL_cx_ecdomain_parameter_ID_IN: u32 = 1610690671;
pub const SYSCALL_cx_ecdomain_parameter_bn_ID_IN: u32 = 1610690962;
pub const SYSCALL_cx_ecdomain_generator_ID_IN: u32 = 1610691300;
pub const SYSCALL_cx_ecdomain_generator_bn_ID_IN: u32 = 1610691521;
pub const SYSCALL_cx_ecpoint_alloc_ID_IN: u32 = 1610674646;
pub const SYSCALL_cx_ecpoint_destroy_ID_IN: u32 = 1610674894;
pub const SYSCALL_cx_ecpoint_init_ID_IN: u32 = 1610675049;
pub const SYSCALL_cx_ecpoint_init_bn_ID_IN: u32 = 1610675373;
pub const SYSCALL_cx_ecpoint_export_ID_IN: u32 = 1610675641;
pub const SYSCALL_cx_ecpoint_export_bn_ID_IN: u32 = 1610675948;
pub const SYSCALL_cx_ecpoint_compress_ID_IN: u32 = 1610689767;
pub const SYSCALL_cx_ecpoint_decompress_ID_IN: u32 = 1610689858;
pub const SYSCALL_cx_ecpoint_add_ID_IN: u32 = 1610681858;
pub const SYSCALL_cx_ecpoint_neg_ID_IN: u32 = 1610682135;
pub const SYSCALL_cx_ecpoint_scalarmul_ID_IN: u32 = 1610682428;
pub const SYSCALL_cx_ecpoint_scalarmul_bn_ID_IN: u32 = 1610682864;
pub const SYSCALL_cx_ecpoint_rnd_scalarmul_ID_IN: u32 = 1610688333;
pub const SYSCALL_cx_ecpoint_rnd_scalarmul_bn_ID_IN: u32 = 1610688649;
pub const SYSCALL_cx_ecpoint_double_scalarmul_ID_IN: u32 = 1610696872;
pub const SYSCALL_cx_ecpoint_double_scalarmul_bn_ID_IN: u32 = 1610697373;
pub const SYSCALL_cx_ecpoint_cmp_ID_IN: u32 = 1610677189;
pub const SYSCALL_cx_ecpoint_is_on_curve_ID_IN: u32 = 1610677445;
pub const SYSCALL_cx_ecpoint_is_at_infinity_ID_IN: u32 = 1610697643;
pub const SYSCALL_cx_crc32_hw_ID_IN: u32 = 1610678897;
pub const SYSCALL_cx_get_random_bytes_ID_IN: u32 = 1610680181;
pub const SYSCALL_cx_trng_get_random_data_ID_IN: u32 = 1610679926;
pub const SYSCALL_os_perso_erase_all_ID_IN: u32 = 1610632181;
pub const SYSCALL_os_perso_set_seed_ID_IN: u32 = 1610632892;
pub const SYSCALL_os_perso_derive_and_set_seed_ID_IN: u32 = 1610633149;
pub const SYSCALL_os_perso_set_words_ID_IN: u32 = 1610633240;
pub const SYSCALL_os_perso_finalize_ID_IN: u32 = 1610633600;
pub const SYSCALL_os_perso_isonboarded_ID_IN: u32 = 1610653519;
pub const SYSCALL_os_perso_setonboardingstatus_ID_IN: u32 = 1610650624;
pub const SYSCALL_os_perso_derive_node_bip32_ID_IN: u32 = 1610634170;
pub const SYSCALL_os_perso_derive_node_with_seed_key_ID_IN: u32 = 1610655448;
pub const SYSCALL_os_perso_derive_eip2333_ID_IN: u32 = 1610655568;
pub const SYSCALL_os_endorsement_get_code_hash_ID_IN: u32 = 1610634511;
pub const SYSCALL_os_endorsement_get_public_key_ID_IN: u32 = 1610634995;
pub const SYSCALL_os_endorsement_get_public_key_certificate_ID_IN: u32 = 1610635084;
pub const SYSCALL_os_endorsement_key1_get_app_secret_ID_IN: u32 = 1610635356;
pub const SYSCALL_os_endorsement_key1_sign_data_ID_IN: u32 = 1610635736;
pub const SYSCALL_os_endorsement_key2_derive_sign_data_ID_IN: u32 = 1610635850;
pub const SYSCALL_os_perso_set_pin_ID_IN: u32 = 1610632415;
pub const SYSCALL_os_perso_set_current_identity_pin_ID_IN: u32 = 1610632702;
pub const SYSCALL_os_global_pin_is_validated_ID_IN: u32 = 1610653756;
pub const SYSCALL_os_global_pin_check_ID_IN: u32 = 1610653954;
pub const SYSCALL_os_global_pin_invalidate_ID_IN: u32 = 1610636752;
pub const SYSCALL_os_global_pin_retries_ID_IN: u32 = 1610636889;
pub const SYSCALL_os_registry_count_ID_IN: u32 = 1610637120;
pub const SYSCALL_os_registry_get_ID_IN: u32 = 1610687075;
pub const SYSCALL_os_ux_ID_IN: u32 = 1610638424;
pub const SYSCALL_os_ux_result_ID_IN: u32 = 1610638592;
pub const SYSCALL_os_lib_call_ID_IN: u32 = 1610639117;
pub const SYSCALL_os_lib_end_ID_IN: u32 = 1610639501;
pub const SYSCALL_os_flags_ID_IN: u32 = 1610639982;
pub const SYSCALL_os_version_ID_IN: u32 = 1610640312;
pub const SYSCALL_os_serial_ID_IN: u32 = 1610640563;
pub const SYSCALL_os_seph_features_ID_IN: u32 = 1610641110;
pub const SYSCALL_os_seph_version_ID_IN: u32 = 1610641324;
pub const SYSCALL_os_bootloader_version_ID_IN: u32 = 1610642349;
pub const SYSCALL_os_setting_get_ID_IN: u32 = 1610641605;
pub const SYSCALL_os_setting_set_ID_IN: u32 = 1610641814;
pub const SYSCALL_os_get_memory_info_ID_IN: u32 = 1610642019;
pub const SYSCALL_os_registry_get_tag_ID_IN: u32 = 1610687344;
pub const SYSCALL_os_registry_get_current_app_tag_ID_IN: u32 = 1610642644;
pub const SYSCALL_os_registry_delete_app_and_dependees_ID_IN: u32 = 1610687659;
pub const SYSCALL_os_registry_delete_all_apps_ID_IN: u32 = 1610687912;
pub const SYSCALL_os_sched_exec_ID_IN: u32 = 1610688239;
pub const SYSCALL_os_sched_exit_ID_IN: u32 = 1610652350;
pub const SYSCALL_os_sched_is_running_ID_IN: u32 = 1610652634;
pub const SYSCALL_os_sched_create_ID_IN: u32 = 1610685208;
pub const SYSCALL_os_sched_kill_ID_IN: u32 = 1610643672;
pub const SYSCALL_io_seph_send_ID_IN: u32 = 1610646401;
pub const SYSCALL_io_seph_is_status_sent_ID_IN: u32 = 1610646715;
pub const SYSCALL_io_seph_recv_ID_IN: u32 = 1610647012;
pub const SYSCALL_nvm_write_page_ID_IN: u32 = 1610680896;
pub const SYSCALL_nvm_erase_page_ID_IN: u32 = 1610692324;
pub const SYSCALL_try_context_get_ID_IN: u32 = 1610647473;
pub const SYSCALL_try_context_set_ID_IN: u32 = 1610681094;
pub const SYSCALL_os_sched_last_status_ID_IN: u32 = 1610652811;
pub const SYSCALL_os_sched_yield_ID_IN: u32 = 1610653118;
pub const SYSCALL_os_sched_switch_ID_IN: u32 = 1610653213;
pub const SYSCALL_os_sched_current_task_ID_IN: u32 = 1610648401;
pub const SYSCALL_os_mpu_protect_ram_ID_IN: u32 = 1610648898;
pub const SYSCALL_os_mpu_protect_flash_ID_IN: u32 = 1610649335;
pub const SYSCALL_os_allow_protected_flash_ID_IN: u32 = 1610649500;
pub const SYSCALL_os_deny_protected_flash_ID_IN: u32 = 1610649908;
pub const SYSCALL_os_allow_protected_ram_ID_IN: u32 = 1610650217;
pub const SYSCALL_os_deny_protected_ram_ID_IN: u32 = 1610650601;
pub const SYSCALL_os_customca_verify_ID_IN: u32 = 1610649697;
pub const SYSCALL_PARAMETER_ARRAY_MAX_LEN: u32 = 11;
pub const BLE_CMD_APDU: u32 = 5;
pub const BLE_CHUNK_LENGTH: u32 = 20;
pub const M24SR_CHUNK_LENGTH: u32 = 246;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT: u32 = 1;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_REQBLE: u32 = 1;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_RECOVERY: u32 = 2;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FLASHBACK: u32 = 4;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_USB: u32 = 1;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_BLE: u32 = 2;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_TOUCH: u32 = 4;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_BUTTON_COUNT: u32 = 240;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_BUTTON_COUNT_POS: u32 = 4;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_SCREEN_MASK: u32 = 3840;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_NO_SCREEN: u32 = 0;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_SCREEN_BIG: u32 = 256;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_SCREEN_SML: u32 = 512;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_SCREEN_SSD1312: u32 = 768;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_LEDRGB: u32 = 4096;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_BATTERY: u32 = 8;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_ISET_MASK: u32 = 4026531840;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_ISET_BASIC: u32 = 0;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_ISET_MCUSEC: u32 = 268435456;
pub const SEPROXYHAL_TAG_SESSION_START_EVENT_FEATURE_ISET_MCUBL: u32 = 536870912;
pub const SEPROXYHAL_TAG_BLE_SECURITY_DB_EVENT: u32 = 2;
pub const SEPROXYHAL_TAG_BLE_SECURITY_DB_LOADED_EVENT: u32 = 0;
pub const SEPROXYHAL_TAG_BLE_SECURITY_DB_DUMP_EVENT: u32 = 1;
pub const SEPROXYHAL_TAG_BLE_WRITE_REQUEST_EVENT: u32 = 3;
pub const SEPROXYHAL_TAG_BLE_READ_REQUEST_EVENT: u32 = 4;
pub const SEPROXYHAL_TAG_BUTTON_PUSH_EVENT: u32 = 5;
pub const SEPROXYHAL_TAG_BUTTON_PUSH_ID_MASK: u32 = 254;
pub const SEPROXYHAL_TAG_BUTTON_PUSH_INTERVAL_MS: u32 = 100;
pub const SEPROXYHAL_TAG_NFC_FIELD_DETECTION_EVENT: u32 = 6;
pub const SEPROXYHAL_TAG_NFC_APDU_RECEIVED_EVENT: u32 = 7;
pub const SEPROXYHAL_TAG_BATTERY_NOTIFICATION_EVENT: u32 = 8;
pub const SEPROXYHAL_TAG_M24SR_GPO_CHANGE_EVENT: u32 = 9;
pub const SEPROXYHAL_TAG_M24SR_RESPONSE_APDU_EVENT: u32 = 10;
pub const SEPROXYHAL_TAG_BLE_NOTIFY_INDICATE_EVENT: u32 = 11;
pub const SEPROXYHAL_TAG_FINGER_EVENT: u32 = 12;
pub const SEPROXYHAL_TAG_FINGER_EVENT_TOUCH: u32 = 1;
pub const SEPROXYHAL_TAG_FINGER_EVENT_RELEASE: u32 = 2;
pub const SEPROXYHAL_TAG_DISPLAY_PROCESSED_EVENT: u32 = 13;
pub const SEPROXYHAL_TAG_TICKER_EVENT: u32 = 14;
pub const SEPROXYHAL_TAG_USB_EVENT: u32 = 15;
pub const SEPROXYHAL_TAG_USB_EVENT_RESET: u32 = 1;
pub const SEPROXYHAL_TAG_USB_EVENT_SOF: u32 = 2;
pub const SEPROXYHAL_TAG_USB_EVENT_SUSPENDED: u32 = 4;
pub const SEPROXYHAL_TAG_USB_EVENT_RESUMED: u32 = 8;
pub const SEPROXYHAL_TAG_USB_EP_XFER_EVENT: u32 = 16;
pub const SEPROXYHAL_TAG_USB_EP_XFER_SETUP: u32 = 1;
pub const SEPROXYHAL_TAG_USB_EP_XFER_IN: u32 = 2;
pub const SEPROXYHAL_TAG_USB_EP_XFER_OUT: u32 = 4;
pub const SEPROXYHAL_TAG_BLE_CONNECTION_EVENT: u32 = 17;
pub const SEPROXYHAL_TAG_UNSEC_CHUNK_EVENT: u32 = 18;
pub const SEPROXYHAL_TAG_ACK_LINK_SPEED: u32 = 19;
pub const SEPROXYHAL_TAG_BLUENRG_RECV_EVENT: u32 = 20;
pub const SEPROXYHAL_TAG_STATUS_EVENT: u32 = 21;
pub const SEPROXYHAL_TAG_STATUS_EVENT_FLAG_CHARGING: u32 = 1;
pub const SEPROXYHAL_TAG_STATUS_EVENT_FLAG_USB_ON: u32 = 2;
pub const SEPROXYHAL_TAG_STATUS_EVENT_FLAG_BLE_ON: u32 = 4;
pub const SEPROXYHAL_TAG_STATUS_EVENT_FLAG_USB_POWERED: u32 = 8;
pub const SEPROXYHAL_TAG_STATUS_EVENT_FLAG_CHARGING_ISSUE: u32 = 16;
pub const SEPROXYHAL_TAG_STATUS_EVENT_FLAG_TEMPERATURE_ISSUE: u32 = 32;
pub const SEPROXYHAL_TAG_STATUS_EVENT_FLAG_BATTERY_ISSUE: u32 = 64;
pub const SEPROXYHAL_TAG_CAPDU_EVENT: u32 = 22;
pub const SEPROXYHAL_TAG_I2C_EVENT: u32 = 23;
pub const SEPROXYHAL_TAG_I2C_EVENT_KIND_READ: u32 = 1;
pub const SEPROXYHAL_TAG_I2C_EVENT_KIND_WRITE: u32 = 2;
pub const SEPROXYHAL_TAG_BLE_RECV_EVENT: u32 = 24;
pub const SEPROXYHAL_TAG_BOOTLOADER_RAPDU_EVENT: u32 = 25;
pub const SEPROXYHAL_TAG_UNSEC_CHUNK_READ: u32 = 50;
pub const SEPROXYHAL_TAG_UNSEC_CHUNK_READ_EXT: u32 = 51;
pub const SEPROXYHAL_TAG_BLE_SEND: u32 = 56;
pub const SEPROXYHAL_TAG_SET_SCREEN_CONFIG: u32 = 62;
pub const SEPROXYHAL_TAG_SET_LINK_PROP: u32 = 63;
pub const SEPROXYHAL_TAG_BLUENRG_SEND: u32 = 64;
pub const SEPROXYHAL_TAG_BLE_DEFINE_GENERIC_SETTING: u32 = 65;
pub const SEPROXYHAL_TAG_BLE_DEFINE_SERVICE_SETTING: u32 = 66;
pub const SEPROXYHAL_TAG_NFC_DEFINE_SERVICE_SETTING: u32 = 67;
pub const SEPROXYHAL_TAG_BLE_RADIO_POWER: u32 = 68;
pub const SEPROXYHAL_TAG_BLE_RADIO_POWER_ACTION_ON: u32 = 2;
pub const SEPROXYHAL_TAG_BLE_RADIO_POWER_ACTION_DBWIPE: u32 = 4;
pub const SEPROXYHAL_TAG_BLE_RADIO_POWER_FACTORY_TEST: u32 = 64;
pub const SEPROXYHAL_TAG_NFC_RADIO_POWER: u32 = 69;
pub const SEPROXYHAL_TAG_SE_POWER_OFF: u32 = 70;
pub const SEPROXYHAL_TAG_BLE_SECURITY_DB: u32 = 72;
pub const SEPROXYHAL_TAG_BLE_SECURITY_DB_CMD_READ: u32 = 1;
pub const SEPROXYHAL_TAG_BLE_SECURITY_DB_CMD_WRITE: u32 = 2;
pub const SEPROXYHAL_TAG_BATTERY_CHARGE: u32 = 73;
pub const SEPROXYHAL_TAG_DEVICE_OFF: u32 = 75;
pub const SEPROXYHAL_TAG_MORE_TIME: u32 = 76;
pub const SEPROXYHAL_TAG_M24SR_C_APDU: u32 = 77;
pub const SEPROXYHAL_TAG_SET_TICKER_INTERVAL: u32 = 78;
pub const SEPROXYHAL_TAG_USB_CONFIG: u32 = 79;
pub const SEPROXYHAL_TAG_USB_CONFIG_CONNECT: u32 = 1;
pub const SEPROXYHAL_TAG_USB_CONFIG_DISCONNECT: u32 = 2;
pub const SEPROXYHAL_TAG_USB_CONFIG_ADDR: u32 = 3;
pub const SEPROXYHAL_TAG_USB_CONFIG_ENDPOINTS: u32 = 4;
pub const SEPROXYHAL_TAG_USB_CONFIG_TYPE_DISABLED: u32 = 0;
pub const SEPROXYHAL_TAG_USB_CONFIG_TYPE_CONTROL: u32 = 1;
pub const SEPROXYHAL_TAG_USB_CONFIG_TYPE_INTERRUPT: u32 = 2;
pub const SEPROXYHAL_TAG_USB_CONFIG_TYPE_BULK: u32 = 3;
pub const SEPROXYHAL_TAG_USB_CONFIG_TYPE_ISOCHRONOUS: u32 = 4;
pub const SEPROXYHAL_TAG_USB_EP_PREPARE: u32 = 80;
pub const SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_SETUP: u32 = 16;
pub const SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_IN: u32 = 32;
pub const SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_OUT: u32 = 48;
pub const SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_STALL: u32 = 64;
pub const SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_UNSTALL: u32 = 128;
pub const SEPROXYHAL_TAG_SET_LED: u32 = 81;
pub const SEPROXYHAL_TAG_REQUEST_STATUS: u32 = 82;
pub const SEPROXYHAL_TAG_RAPDU: u32 = 83;
pub const SEPROXYHAL_TAG_I2C_XFER: u32 = 84;
pub const SEPROXYHAL_TAG_PRINTF: u32 = 95;
pub const SEPROXYHAL_TAG_DBG_SCREEN_DISPLAY_STATUS: u32 = 94;
pub const SEPROXYHAL_TAG_STATUS_MASK: u32 = 96;
pub const SEPROXYHAL_TAG_GENERAL_STATUS: u32 = 96;
pub const SEPROXYHAL_TAG_GENERAL_STATUS_LAST_COMMAND: u32 = 0;
pub const SEPROXYHAL_TAG_PAIRING_STATUS: u32 = 97;
pub const SEPROXYHAL_TAG_BLE_READ_RESPONSE_STATUS: u32 = 98;
pub const SEPROXYHAL_TAG_NFC_READ_RESPONSE_STATUS: u32 = 99;
pub const SEPROXYHAL_TAG_BLE_NOTIFY_INDICATE_STATUS: u32 = 100;
pub const SEPROXYHAL_TAG_SCREEN_DISPLAY_STATUS: u32 = 101;
pub const SEPROXYHAL_TAG_PRINTF_STATUS: u32 = 102;
pub const SEPROXYHAL_TAG_SET_LINK_SPEED: u32 = 103;
pub const SEPROXYHAL_TAG_SCREEN_ANIMATION_STATUS: u32 = 104;
pub const SEPROXYHAL_TAG_SCREEN_ANIMATION_STATUS_VERTICAL_SPLIT_SLIDE: u32 = 0;
pub const SEPROXYHAL_TAG_BOOTLOADER_CAPDU_STATUS: u32 = 106;
pub const IO_CACHE: u32 = 1;
pub const NO_TIMEOUT: u32 = 0;
pub type wchar_t = cty::c_uint;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: cty::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::core::mem::MaybeUninit<max_align_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<max_align_t>(),
        16usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::core::mem::align_of::<max_align_t>(),
        8usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type __int8_t = cty::c_schar;
pub type __uint8_t = cty::c_uchar;
pub type __int16_t = cty::c_short;
pub type __uint16_t = cty::c_ushort;
pub type __int32_t = cty::c_int;
pub type __uint32_t = cty::c_uint;
pub type __int64_t = cty::c_longlong;
pub type __uint64_t = cty::c_ulonglong;
pub type __int_least8_t = cty::c_schar;
pub type __uint_least8_t = cty::c_uchar;
pub type __int_least16_t = cty::c_short;
pub type __uint_least16_t = cty::c_ushort;
pub type __int_least32_t = cty::c_int;
pub type __uint_least32_t = cty::c_uint;
pub type __int_least64_t = cty::c_longlong;
pub type __uint_least64_t = cty::c_ulonglong;
pub type __intmax_t = cty::c_longlong;
pub type __uintmax_t = cty::c_ulonglong;
pub type __intptr_t = cty::c_int;
pub type __uintptr_t = cty::c_uint;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type int_least8_t = __int_least8_t;
pub type uint_least8_t = __uint_least8_t;
pub type int_least16_t = __int_least16_t;
pub type uint_least16_t = __uint_least16_t;
pub type int_least32_t = __int_least32_t;
pub type uint_least32_t = __uint_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = cty::c_schar;
pub type uint_fast8_t = cty::c_uchar;
pub type int_fast16_t = cty::c_short;
pub type uint_fast16_t = cty::c_ushort;
pub type int_fast32_t = cty::c_int;
pub type uint_fast32_t = cty::c_uint;
pub type int_fast64_t = cty::c_longlong;
pub type uint_fast64_t = cty::c_ulonglong;
#[doc = " Type of error code"]
pub type cx_err_t = u32;
#[doc = " @brief   AES key container.\n\n @details Such container should be initialized with cx_ees_init_key to ensure\n future API compatibility. Indeed, in next API level, the key store format may\n changed at all. Only 16-byte key (AES128) is supported ."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cx_aes_key_s {
    #[doc = "< key size"]
    pub size: usize,
    #[doc = "< key value"]
    pub keys: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_cx_aes_key_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_aes_key_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_aes_key_s>(),
        36usize,
        concat!("Size of: ", stringify!(cx_aes_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_aes_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_aes_key_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_aes_key_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keys) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_aes_key_s),
            "::",
            stringify!(keys)
        )
    );
}
#[doc = " @brief   AES key container.\n\n @details Such container should be initialized with cx_ees_init_key to ensure\n future API compatibility. Indeed, in next API level, the key store format may\n changed at all. Only 16-byte key (AES128) is supported ."]
pub type cx_aes_key_t = cx_aes_key_s;
extern "C" {
    #[doc = " @brief   Set an AES key in hardware.\n\n @param[in] key AES key.\n\n @param[in] mode Operation for which the key will be used.\n\n @return         Error code:\n                 - CX_OK on success\n                 - CX_INVALID_PARAMETER"]
    pub fn cx_aes_set_key_hw(key: *const cx_aes_key_t, mode: u32) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Reset AES context."]
    pub fn cx_aes_reset_hw();
}
extern "C" {
    #[doc = " @brief   Encrypt or decrypt a block with AES.\n\n @param[in]  inblock  Pointer to the block.\n\n @param[out] outblock Buffer for the output.\n\n @return              Error code:\n                      - CX_OK on success\n                      - INVALID_PARAMETER"]
    pub fn cx_aes_block_hw(inblock: *const cty::c_uchar, outblock: *mut cty::c_uchar) -> cx_err_t;
}
#[doc = " Index of a big number."]
pub type cx_bn_t = u32;
#[doc = " @brief Montgomery context."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cx_bn_mont_ctx_t {
    #[doc = "< @private Modulus"]
    pub n: cx_bn_t,
    #[doc = "< @private Second Montgomery constant"]
    pub h: cx_bn_t,
}
#[test]
fn bindgen_test_layout_cx_bn_mont_ctx_t() {
    const UNINIT: ::core::mem::MaybeUninit<cx_bn_mont_ctx_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_bn_mont_ctx_t>(),
        8usize,
        concat!("Size of: ", stringify!(cx_bn_mont_ctx_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_bn_mont_ctx_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_bn_mont_ctx_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_bn_mont_ctx_t),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_bn_mont_ctx_t),
            "::",
            stringify!(h)
        )
    );
}
extern "C" {
    #[doc = " @brief   Acquire lock to BN processor.\n\n @details Reset it, set the word size and configure.\n          Once locked the memory can be used.\n\n @param[in] word_nbytes  Word size in byte, the size of the parameters will be\n a multiple of *word_nbytes*. This size must be a multiple of\n CX_BN_WORD_ALIGNEMENT.\n @param[in] flags        Flags.\n\n @return                 Error code:\n                         - CX_OK on success\n                         - CX_BN_LOCKED if already locked."]
    pub fn cx_bn_lock(word_nbytes: usize, flags: u32) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Release the BN lock.\n\n @details Erase all content data.\n          Once unlocked the memory cannot be used anymore.\n\n @return  Error code:\n          - CX_OK on success\n          - CX_BN_NOT_LOCKED if not locked"]
    pub fn cx_bn_unlock() -> u32;
}
extern "C" {
    #[doc = " @brief   Check if BN processor is currently locked.\n\n @details The memory can be used only if the BN processor is locked.\n\n @return  1 if locked, 0 otherwise."]
    pub fn cx_bn_is_locked() -> bool;
}
extern "C" {
    #[doc = " @brief   Ensure BN processor is currently locked.\n\n @details If the BN processor is not locked the memory\n          cannot be used.\n\n @return  Error code:\n         - CX_OK on success\n         - CX_NOT_LOCKED"]
    pub fn cx_bn_locked() -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Allocate a new BN.\n\n @details The specified number of bytes is the minimal required bytes,\n          the number of words allocated will be automatically a multiple\n          of the configured word size. At this moment the BN value is set\n          to 0.\n\n @param[in] x        Pointer to a BN.\n\n @param[in] nbytes   Number of bytes of x.\n\n @return             Error code:\n                     - CX_OK on success\n                     - CX_BN_MEMORY_FULL\n                     - CX_BN_INVALID_PARAMETER_SIZE"]
    pub fn cx_bn_alloc(x: *mut cx_bn_t, nbytes: usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Allocate a new BN and initialize it with the specified value.\n\n @details The specified number of bytes is the minimal required bytes,\n          the number of words allocated will be automatically a multiple\n          of the configured word size.\n\n @param[in] x            Pointer to a BN.\n\n @param[in] nbytes       Number of bytes of x.\n\n @param[in] value        Pointer to the value used to initialize the BN.\n\n @param[in] value_nbytes Number of bytes of value.\n\n @return                 Error code:\n                         - CX_OK on success\n                         - CX_BN_MEMORY_FULL\n                         - CX_BN_INVALID_PARAMETER_SIZE"]
    pub fn cx_bn_alloc_init(
        x: *mut cx_bn_t,
        nbytes: usize,
        value: *const u8,
        value_nbytes: usize,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Release a BN and give back its attached memory to the system.\n\n @param[in] x BN to release. If NULL, nothing is done.\n\n @return      Error code:\n              - CX_OK on success\n              - CX_BN_INVALID_PARAMETER_SIZE\n              - CX_BN_INVALID_PARAMETER_VALUE"]
    pub fn cx_bn_destroy(x: *mut cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Return the size in bytes of a BN.\n\n @param[in]  x      BN index.\n\n @param[out] nbytes Returned number of bytes.\n\n @return            Error code:\n                    - CX_OK on success\n                    - CX_BN_INVALID_PARAMETER"]
    pub fn cx_bn_nbytes(x: cx_bn_t, nbytes: *mut usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Initialize a BN with an unsigned value.\n\n @param[in] x              BN index.\n\n @param[in] value          Pointer to the value in big-endian order.\n\n @param[in] value_nbytes   Number of bytes of the value.\n\n @return                   Error code:\n                           - CX_OK on success\n                           - CX_BN_INVALID_PARAMETER_SIZE\n                           - CX_BN_INVALID_PARAMETER_VALUE"]
    pub fn cx_bn_init(x: cx_bn_t, value: *const u8, value_nbytes: usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Generate a random number and store it in the given index.\n\n @param[in] x BN index.\n\n @return      Error code:\n              - CX_OK on success\n              - CX_BN_INVALID_PARAMETER_VALUE"]
    pub fn cx_bn_rand(x: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Copy the BN value.\n\n @param[out] a BN destination index.\n\n @param[in]  b BN source index.\n\n @return       Error code:\n               - CX_OK on success\n               - CX_BN_INVALID_PARAMETER_SIZE\n               - CX_BN_INVALID_PARAMETER_VALUE"]
    pub fn cx_bn_copy(a: cx_bn_t, b: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Set the value of a BN with a 32-bit unsigned value.\n\n @param[in] x BN index.\n\n @param[in] n 32-bit value to be assigned.\n\n @return      Error code:\n              - CX_OK on success\n              - CX_NOT_LOCKED\n              - CX_INVALID_PARAMETER"]
    pub fn cx_bn_set_u32(x: cx_bn_t, n: u32) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Get the 32-bit value corresponding to a BN.\n\n @param[in]  x BN index.\n\n @param[out] n Stored 32-bit unsigned value.\n\n @return       Error code:\n               - CX_OK on success\n               - CX_NOT_LOCKED\n               - CX_INVALID_PARAMETER"]
    pub fn cx_bn_get_u32(x: cx_bn_t, n: *mut u32) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Store/Serialize a BN value as unsigned raw bytes in big-endian\n order.\n\n @details Only the least significant *nbytes* bytes of the BN are serialized\n          If *nbytes* is greater than the BN size, *x* is serialized right\n aligned and zero left padded.\n\n @param[in]  x       BN index.\n\n @param[out] bytes   Buffer where to store the serialized number.\n\n @param[in]  nbytes  Number of bytes to store into the buffer.\n\n @return             Error code:\n                     - CX_OK on success\n                     - CX_BN_INVALID_PARAMETER_SIZE\n                     - CX_BN_INVALID_PARAMETER_VALUE"]
    pub fn cx_bn_export(x: cx_bn_t, bytes: *mut u8, nbytes: usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Compare two BN values.\n\n @param[in]  a    BN index to the first value to be compared.\n\n @param[in]  b    BN index to the second value to be compared.\n\n @param[out] diff Result of the comparison:\n                  - 0 if the numbers are equal.\n                  - > 0 if the first number is greater than the second\n                  - < 0 if the first number is smaller than the second\n\n @return          Error code:\n                  - CX_OK on success\n                  - CX_NOT_LOCKED\n                  - CX_INVALID_PARAMETER"]
    pub fn cx_bn_cmp(a: cx_bn_t, b: cx_bn_t, diff: *mut cty::c_int) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Compare a BN value with an unsigned integer.\n\n @param[in]  a    BN index to the value to be compared.\n\n @param[in]  b    Integer to be compared.\n\n @param[out] diff Result of the comparison:\n                  - 0 if the numbers are equal.\n                  - > 0 if the BN value is greater\n                  - < 0 if the BN value is smaller\n\n @return          Error code:\n                  - CX_OK on success\n                  - CX_NOT_LOCKED\n                  - CX_INVALID_PARAMETER"]
    pub fn cx_bn_cmp_u32(a: cx_bn_t, b: u32, diff: *mut cty::c_int) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Test whether a BN value is odd.\n\n @param[in]  n    BN index.\n\n @param[out] odd  Boolean which indicates the parity of the BN value:\n                  - 1 if odd\n                  - 0 if even\n\n @return          Error code:\n                  - CX_OK on success\n                  - CX_NOT_LOCKED\n                  - CX_INVALID_PARAMETER"]
    pub fn cx_bn_is_odd(n: cx_bn_t, odd: *mut bool) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform the bitwise 'exclusive-OR' of two BN values.\n\n @details *r* must be distinct from *a* and *b*.\n\n @param[out] r BN index for the result.\n\n @param[in]  a BN index of the first operand.\n\n @param[in]  b BN index of the second operand.\n\n @return       Error code:\n               - CX_OK on success\n               - CX_NOT_LOCKED\n               - CX_INVALID_PARAMETER"]
    pub fn cx_bn_xor(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform the bitwise 'OR' of two BN values.\n\n @details *r* must be distinct from *a* and *b*.\n\n @param[out] r BN index for the result.\n\n @param[in]  a BN index of the first operand.\n\n @param[in]  b BN index of the second operand.\n\n @return       Error code:\n               - CX_OK on success\n               - CX_NOT_LOCKED\n               - CX_INVALID_PARAMETER"]
    pub fn cx_bn_or(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform the bitwise 'AND' of two BN values.\n\n @details *r* must be distinct from *a* and *b*.\n\n @param[out] r BN index for the result.\n\n @param[in]  a BN index of the first operand.\n\n @param[in]  b BN index of the second operand.\n\n @return       Error code:\n               - CX_OK on success\n               - CX_NOT_LOCKED\n               - CX_INVALID_PARAMETER"]
    pub fn cx_bn_and(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Test the bit value at the specified index.\n\n @details The BN value is in big endian order, thus the\n          position 0 corresponds to the least significant bit.\n\n @param[in]  x    BN index.\n\n @param[in]  pos  Position of the bit.\n\n @param[out] set  Boolean which indicates the bit value\n                  - 1 if the bit is set\n                  - 0 otherwise\n\n @return          Error code:\n                  - CX_OK on success\n                  - CX_NOT_LOCKED\n                  - CX_INVALID_PARAMETER"]
    pub fn cx_bn_tst_bit(x: cx_bn_t, pos: u32, set: *mut bool) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Set the bit value at the specified index.\n\n @details The BN value is in big endian order, thus the\n          position 0 corresponds to the least significant bit.\n\n @param[in]  x    BN index.\n\n @param[in]  pos  Position of the bit.\n\n @return          Error code:\n                  - CX_OK on success\n                  - CX_NOT_LOCKED\n                  - CX_INVALID_PARAMETER"]
    pub fn cx_bn_set_bit(x: cx_bn_t, pos: u32) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Clear the bit value at the specified index.\n\n @details The BN value is in big endian order, thus the\n          position 0 corresponds to the least significant bit.\n\n @param[in]  x    BN index.\n\n @param[in]  pos  Position of the bit.\n\n @return          Error code:\n                  - CX_OK on success\n                  - CX_NOT_LOCKED\n                  - CX_INVALID_PARAMETER"]
    pub fn cx_bn_clr_bit(x: cx_bn_t, pos: u32) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform a right shift.\n\n @param[in]  x  BN index.\n\n @param[in]  n  Number of bits to shift.\n\n @return        Error code:\n                - CX_OK on success\n                - CX_NOT_LOCKED\n                - CX_INVALID_PARAMETER"]
    pub fn cx_bn_shr(x: cx_bn_t, n: u32) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform a left shift.\n\n @param[in]  x  BN index.\n\n @param[in]  n  Number of bits to shift.\n\n @return        Error code:\n                - CX_OK on success\n                - CX_NOT_LOCKED\n                - CX_INVALID_PARAMETER"]
    pub fn cx_bn_shl(x: cx_bn_t, n: u32) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Count the number of bits set to 1 of the BN value.\n\n @param[in]  n      BN index.\n\n @param[out] nbits  Number of bits set.\n\n @return            Error code:\n                    - CX_OK on success\n                    - CX_NOT_LOCKED\n                    - CX_INVALID_PARAMETER"]
    pub fn cx_bn_cnt_bits(n: cx_bn_t, nbits: *mut u32) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform an addition **r = a + b**.\n\n @details *r*, *a* and *b* shall have the same BN size.\n\n @param[out] r BN index for the result.\n\n @param[in]  a BN index of the first operand.\n\n @param[in]  b BN index of the second operand.\n\n @return       Error code:\n               - CX_OK or CX_CARRY on success\n               - CX_NOT_LOCKED\n               - CX_INVALID_PARAMETER"]
    pub fn cx_bn_add(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform a subtraction **r = a - b**.\n\n @details *r*, *a* and *b* shall have the same BN size.\n\n @param[out] r BN index for the result.\n\n @param[in]  a BN index of the first operand.\n\n @param[in]  b BN index of the second operand.\n\n @return       Error code:\n               - CX_OK or CX_CARRY on success\n               - CX_NOT_LOCKED\n               - CX_INVALID_PARAMETER"]
    pub fn cx_bn_sub(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform a multiplication **r = a * b**.\n\n @details *r*, *a* and *b* shall have the same BN size.\n\n @param[out] r BN index for the result.\n\n @param[in]  a BN index of the first operand.\n\n @param[in]  b BN index of the second operand.\n\n @return       Error code:\n               - CX_OK on success\n               - CX_NOT_LOCKED\n               - CX_INVALID_PARAMETER"]
    pub fn cx_bn_mul(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform a modular addition **r = a + b mod n**.\n\n @details *r*, *a*, *b* and *n* shall have the same BN size.\n          The values of *a* and *b* must be strictly smaller\n          than modulus value.\n\n @param[out] r BN index for the result.\n\n @param[in]  a BN index of the first operand.\n\n @param[in]  b BN index of the second operand.\n\n @param[in]  n BN index of the modulus.\n\n @return       Error code:\n               - CX_OK on success\n               - CX_NOT_LOCKED\n               - CX_INVALID_PARAMETER\n               - CX_MEMORY_FULL"]
    pub fn cx_bn_mod_add(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform a modular subtraction **r = a - b mod n**.\n\n @details *r*, *a*, *b* and *n* shall have the same BN size.\n          The values of *a* and *b* must be strictly smaller\n          than modulus value.\n\n @param[out] r BN index for the result.\n\n @param[in]  a BN index of the first operand.\n\n @param[in]  b BN index of the second operand.\n\n @param[in]  n BN index of the modulus.\n\n @return       Error code:\n               - CX_OK on success\n               - CX_NOT_LOCKED\n               - CX_INVALID_PARAMETER\n               - CX_MEMORY_FULL"]
    pub fn cx_bn_mod_sub(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform a modular multiplication **r = a * b mod n**.\n\n @details *r*, *a*, *b* and *n* shall have the same BN size.\n          The value of b must be strictly smaller\n          than modulus value.\n\n @param[out] r BN index for the result.\n\n @param[in]  a BN index of the first operand.\n\n @param[in]  b BN index of the second operand.\n\n @param[in]  n BN index of the modulus.\n\n @return       Error code:\n               - CX_OK on success\n               - CX_NOT_LOCKED\n               - CX_INVALID_PARAMETER\n               - CX_INVALID_PARAMETER_VALUE\n               - CX_MEMORY_FULL"]
    pub fn cx_bn_mod_mul(r: cx_bn_t, a: cx_bn_t, b: cx_bn_t, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform a reduction **r = d mod n**.\n\n @details *r* and *n* shall have the same BN size.\n\n @param[out] r BN index for the result.\n\n @param[in]  d BN index of the value to be reduced.\n\n @param[in]  n BN index of the modulus.\n\n @return       Error code:\n               - CX_OK on success\n               - CX_NOT_LOCKED\n               - CX_INVALID_PARAMETER\n               - CX_MEMORY_FULL"]
    pub fn cx_bn_reduce(r: cx_bn_t, d: cx_bn_t, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Compute *r* such that **r² = a mod n** if *a* is a quadratic\n residue.\n\n @details This returns an error if the given number is not a quadratic\n residue. *r*, *a* and *n* shall have the same BN size.\n\n @param[out] r    BN index for the result.\n\n @param[in]  a    BN index of the value to compute the quadratic residue.\n\n @param[in]  n    BN index of the modulus.\n\n @param[in]  sign Sign of the quadratic residue.\n\n @return          Error code:\n                  - CX_OK on success\n                  - CX_NOT_LOCKED\n                  - CX_INVALID_PARAMETER\n                  - CX_MEMORY_FULL\n                  - CX_NO_RESIDUE"]
    pub fn cx_bn_mod_sqrt(r: cx_bn_t, a: cx_bn_t, n: cx_bn_t, sign: u32) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform a modular exponentiation **r = a^e mod n**.\n\n @details *r*, *a* and *n* shall have the same BN size.\n          *r*, *a* and *n* must be different.\n\n @param[out] r BN index for the result.\n\n @param[in]  a BN index of the base of the exponentiation.\n\n @param[in]  e BN index of the exponent.\n\n @param[in]  n BN index of the modulus.\n\n @return       Error code:\n               - CX_OK on success\n               - CX_NOT_LOCKED\n               - CX_INVALID_PARAMETER\n               - CX_MEMORY_FULL"]
    pub fn cx_bn_mod_pow_bn(r: cx_bn_t, a: cx_bn_t, e: cx_bn_t, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform a modular exponentiation **r = a^e mod n**.\n\n @details *r*, *a* and *n* shall have the same BN size.\n          *r*, *a* and *n* must be different.\n\n @param[out] r     BN index for the result.\n\n @param[in]  a     BN index of the base of the exponentiation.\n\n @param[in]  e     Pointer to the exponent.\n\n @param[in]  e_len Length of the exponent buffer.\n\n @param[in]  n     BN index of the modulus.\n\n @return           Error code:\n                   - CX_OK on success\n                   - CX_NOT_LOCKED\n                   - CX_INVALID_PARAMETER\n                   - CX_MEMORY_FULL"]
    pub fn cx_bn_mod_pow(r: cx_bn_t, a: cx_bn_t, e: *const u8, e_len: u32, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform a modular exponentiation **r = a^e mod n**.\n\n @details This fonction reuses the parameter *a* for intermediate\n computations, hence requires less memory. *r*, *a* and *n* shall have the\n same BN size. *r*, *a* and *n* must be different.\n\n @param[out] r     BN index for the result.\n\n @param[in]  a     BN index of the base of the exponentiation.\n                   The BN value is modified during the\n                   computations.\n\n @param[in]  e     Pointer to the exponent.\n\n @param[in]  e_len Length of the exponent buffer.\n\n @param[in]  n     BN index of the modulus.\n\n @return           Error code:\n                   - CX_OK on success\n                   - CX_NOT_LOCKED\n                   - CX_INVALID_PARAMETER\n                   - CX_MEMORY_FULL"]
    pub fn cx_bn_mod_pow2(r: cx_bn_t, a: cx_bn_t, e: *const u8, e_len: u32, n: cx_bn_t)
        -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Compute the modular inverse **r = a^(-1) mod n**,\n          for a prime *n*.\n\n @details *r*, *a* and *n* shall have the same BN size. *n* must be prime.\n\n @param[out] r BN index for the result.\n\n @param[in]  a BN index of the value to be inverted.\n\n @param[in]  n BN index of the modulus.\n\n @return       Error code:\n               - CX_OK on success\n               - CX_NOT_LOCKED\n               - CX_INVALID_PARAMETER\n               - CX_MEMORY_FULL"]
    pub fn cx_bn_mod_invert_nprime(r: cx_bn_t, a: cx_bn_t, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Compute the modular inverse **r = a^(-1) mod n**,\n          of a 32-bit value.\n\n @details *r* and *n* shall have the same BN size.\n          The parameters *n* is detroyed and contains zero\n          after the function returns.\n\n @param[out] r BN index for the result.\n\n @param[in]  a 32-bit value to be inverted.\n\n @param[in]  n BN index of the modulus.\n\n @return       Error code:\n               - CX_OK on success\n               - CX_NOT_LOCKED\n               - CX_INVALID_PARAMETER\n               - CX_MEMORY_FULL\n               - CX_INTERNAL_ERROR\n               - CX_NOT_INVERTIBLE"]
    pub fn cx_bn_mod_u32_invert(r: cx_bn_t, a: u32, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Allocate memory for the Montgomery context.\n\n @param[in] ctx    Pointer to the Montogmery context.\n\n @param[in] length BN size for the context fields.\n\n @return           Error code:\n                   - CX_OK on success\n                   - CX_NOT_LOCKED\n                   - CX_MEMORY_FULL"]
    pub fn cx_mont_alloc(ctx: *mut cx_bn_mont_ctx_t, length: usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Initialize a Montgomery context with the modulus.\n\n @details Calculate and set up the second Montgomery constant.\n\n @param[in] ctx Pointer to a Montgomery context.\n\n @param[in] n   BN index of the modulus.\n\n @return        Error code:\n                - CX_OK on success\n                - CX_NOT_LOCKED\n                - CX_INVALID_PARAMETER\n                - CX_MEMORY_FULL"]
    pub fn cx_mont_init(ctx: *mut cx_bn_mont_ctx_t, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Initialize a Montgomery context with the modulus and\n          the second Montgomery constant.\n\n @details Set up the second Montgomery constant with the given\n          parameter.\n          The caller should make sure that the given\n          second Montgomery constant is correct.\n\n @param[in] ctx Pointer to a Montgomery context.\n\n @param[in] n   BN index of the modulus.\n\n @param[in] h   BN index of the pre calculated second Montgomery constant.\n\n @return        Error code:\n                - CX_OK on success\n                - CX_NOT_LOCKED\n                - CX_INVALID_PARAMETER"]
    pub fn cx_mont_init2(ctx: *mut cx_bn_mont_ctx_t, n: cx_bn_t, h: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Compute the Montgomery representation of a BN value.\n\n @details The context must be initialized.\n\n @param[out] x   BN index for the result.\n\n @param[in]  z   BN index of the value to convert into Montgomery\n representation.\n\n @param[in]  ctx Pointer to the Montgomery context, initialized\n                 with the modulus and the second Montgomery constant.\n\n @return         Error code:\n                 - CX_OK on success\n                 - CX_NOT_LOCKED\n                 - CX_INVALID_PARAMETER\n                 - CX_MEMORY_FULL"]
    pub fn cx_mont_to_montgomery(x: cx_bn_t, z: cx_bn_t, ctx: *const cx_bn_mont_ctx_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Compute the normal representation of a BN value\n          given a Montgomery representation.\n\n @details The context must be initialized.\n\n @param[out] x   BN index for the result.\n\n @param[in]  z   BN index of the value to be converted.\n                 The value should be in Montgomery representation.\n\n @param[in]  ctx Pointer to the Montgomery context, initialized\n                 with the modulus and the second Montgomery constant.\n\n @return         Error code:\n                 - CX_OK on success\n                 - CX_NOT_LOCKED\n                 - CX_INVALID_PARAMETER\n                 - CX_MEMORY_FULL"]
    pub fn cx_mont_from_montgomery(
        z: cx_bn_t,
        x: cx_bn_t,
        ctx: *const cx_bn_mont_ctx_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform a Montgomery multiplication.\n\n @details The context must be initialized.\n\n @param[out] r   BN index for the result.\n\n @param[in]  a   BN index of the first operand in Montgomery representation.\n\n @param[in]  b   BN index of the second operand in Montgomery representation.\n\n @param[in]  ctx Pointer to the Montgomery context, initialized\n                 with the modulus and the second Montgomery constant.\n\n @return         Error code:\n                 - CX_OK on success\n                 - CX_NOT_LOCKED\n                 - CX_INVALID_PARAMETER"]
    pub fn cx_mont_mul(
        r: cx_bn_t,
        a: cx_bn_t,
        b: cx_bn_t,
        ctx: *const cx_bn_mont_ctx_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform a modular exponentiation **r = a^e mod n**.\n\n @details The context must be initialized. The BN value *a*\n          is in Montgomery representation.\n\n @param[out] r     BN index for the result. The result is in\n                   Montgomery representation.\n\n @param[in]  a     BN index of the exponentiation base in Montgomery\n                   representation.\n\n @param[in]  e     Pointer to the exponent.\n\n @param[in]  e_len Length of the exponent in bytes.\n\n @param[in]  ctx   Pointer to the Montgomery context, initialized\n                   with the modulus and the second Montgomery constant.\n\n @return           Error code:\n                   - CX_OK on success\n                   - CX_NOT_LOCKED\n                   - CX_INVALID_PARAMETER\n                   - CX_MEMORY_FULL"]
    pub fn cx_mont_pow(
        r: cx_bn_t,
        a: cx_bn_t,
        e: *const u8,
        e_len: u32,
        ctx: *const cx_bn_mont_ctx_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform a modular exponentiation **r = a^e mod n**.\n\n @details The context must be initialized. The BN value *a*\n          is in Montgomery representation.\n\n @param[out] r     BN index for the result. The result is in\n                   Montgomery representation.\n\n @param[in]  a     BN index of the exponentiation base in Montgomery\n                   representation.\n\n @param[in]  e     BN index of the exponent.\n\n @param[in]  ctx   Pointer to the Montgomery context, initialized\n                   with the modulus and the second Montgomery constant.\n\n @return           Error code:\n                   - CX_OK on success\n                   - CX_NOT_LOCKED\n                   - CX_INVALID_PARAMETER\n                   - CX_MEMORY_FULL"]
    pub fn cx_mont_pow_bn(
        r: cx_bn_t,
        a: cx_bn_t,
        e: cx_bn_t,
        ctx: *const cx_bn_mont_ctx_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Compute the modular inverse **r = a^(-1) mod n** for\n          a prime number *n*.\n\n @details The context must be initialized.\n\n @param[out] r   BN index for the result. The result is in\n                 Montgomery representation.\n\n @param[in]  a   BN index of the value to be inverted. The value\n                 is in Montgomery representation.\n\n @param[in]  ctx Pointer to the Montgomery context, initialized\n                 with the modulus and the second Montgomery constant\n\n @return         Error code:\n                 - CX_OK on success\n                 - CX_NOT_LOCKED\n                 - CX_INVALID_PARAMETER\n                 - CX_MEMORY_FULL"]
    pub fn cx_mont_invert_nprime(r: cx_bn_t, a: cx_bn_t, ctx: *const cx_bn_mont_ctx_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Test whether a BN value is a probable prime.\n\n @param[in] n      BN index of the value.\n\n @param[out] prime Boolean which indicates whether the number is a prime:\n                   - 1 if it is a prime\n                   - 0 otherwise\n\n @return           Error code:\n                   - CX_OK on success\n                   - CX_NOT_LOCKED\n                   - CX_INVALID_PARAMETER\n                   - CX_MEMORY_FULL"]
    pub fn cx_bn_is_prime(n: cx_bn_t, prime: *mut bool) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Return the first prime number after a\n          given BN value.\n\n @param[in, out] n BN index of the value and the result.\n\n @return           Error code:\n                   - CX_OK on success\n                   - CX_NOT_LOCKED\n                   - CX_INVALID_PARAMETER\n                   - CX_MEMORY_FULL\n                   - CX_OVERFLOW"]
    pub fn cx_bn_next_prime(n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief Generate a random number *r* in the range ]0,n[.\n\n @details *r* is such that: **0 < r < n**.\n\n @param[out] r BN index for the result.\n\n @param[in]  n BN index of the upper bound.\n\n @return       Error code:\n               - CX_OK on success\n               - CX_NOT_LOCKED\n               - CX_INVALID_PARAMETER\n               - CX_MEMORY_FULL"]
    pub fn cx_bn_rng(r: cx_bn_t, n: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief Calculate a 32-bit cyclic redundancy check.\n\n @param[in] buf Pointer to the buffer to check.\n\n @param[in] len Length of the buffer.\n\n @return        Result of the 32-bit CRC calculation.\n"]
    pub fn cx_crc32_hw(buf: *const cty::c_void, len: usize) -> u32;
}
#[doc = " @brief   DES key container.\n\n  @details DES key container.\n           Such container should be initialized with **cx_des_init_key** to\n ensure future API compatibility. Indeed, in next API level, the key store\n format may changed at all. 8 bytes (simple DES), 16 bytes (triple DES with 2\n keys) and 24 bytes (triple DES with 3 keys) are supported."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct cx_des_key_s {
    #[doc = "< key size"]
    pub size: u8,
    #[doc = "< key value"]
    pub keys: [u8; 24usize],
}
#[test]
fn bindgen_test_layout_cx_des_key_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_des_key_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_des_key_s>(),
        25usize,
        concat!("Size of: ", stringify!(cx_des_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_des_key_s>(),
        1usize,
        concat!("Alignment of ", stringify!(cx_des_key_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_des_key_s),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).keys) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_des_key_s),
            "::",
            stringify!(keys)
        )
    );
}
#[doc = " @brief   DES key container.\n\n  @details DES key container.\n           Such container should be initialized with **cx_des_init_key** to\n ensure future API compatibility. Indeed, in next API level, the key store\n format may changed at all. 8 bytes (simple DES), 16 bytes (triple DES with 2\n keys) and 24 bytes (triple DES with 3 keys) are supported."]
pub type cx_des_key_t = cx_des_key_s;
extern "C" {
    #[doc = " @brief   Set a DES key in hardware.\n\n @param[in] keys DES key.\n\n @param[in] mode Operation for which the key will be used.\n\n @return         Error code:\n                 - CX_OK on success\n                 - INVALID_PARAMETER"]
    pub fn cx_des_set_key_hw(keys: *const cx_des_key_t, mode: u32) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Reset DES context."]
    pub fn cx_des_reset_hw();
}
extern "C" {
    #[doc = " @brief   Encrypt or decrypt a block with DES.\n\n @param[in]  inblock  Pointer to the block.\n\n @param[out] outblock Buffer for the output."]
    pub fn cx_des_block_hw(inblock: *const cty::c_uchar, outblock: *mut cty::c_uchar);
}
#[doc = " Undefined curve"]
pub const cx_curve_e_CX_CURVE_NONE: cx_curve_e = 0;
#[doc = " Low limit (not included) of Weierstrass curve ID"]
pub const cx_curve_e_CX_CURVE_WEIERSTRASS_START: cx_curve_e = 32;
#[doc = " Secp256k1"]
pub const cx_curve_e_CX_CURVE_SECP256K1: cx_curve_e = 33;
#[doc = " Secp256r1"]
pub const cx_curve_e_CX_CURVE_SECP256R1: cx_curve_e = 34;
#[doc = " Secp384r1"]
pub const cx_curve_e_CX_CURVE_SECP384R1: cx_curve_e = 35;
#[doc = " Secp521r1"]
pub const cx_curve_e_CX_CURVE_SECP521R1: cx_curve_e = 36;
#[doc = " BrainpoolP256t1"]
pub const cx_curve_e_CX_CURVE_BrainPoolP256T1: cx_curve_e = 49;
#[doc = " BrainpoolP256r1"]
pub const cx_curve_e_CX_CURVE_BrainPoolP256R1: cx_curve_e = 50;
#[doc = " BrainpoolP320t1"]
pub const cx_curve_e_CX_CURVE_BrainPoolP320T1: cx_curve_e = 51;
#[doc = " BrainpoolP320r1"]
pub const cx_curve_e_CX_CURVE_BrainPoolP320R1: cx_curve_e = 52;
#[doc = " BrainpoolP384t1"]
pub const cx_curve_e_CX_CURVE_BrainPoolP384T1: cx_curve_e = 53;
#[doc = " Brainpool384r1"]
pub const cx_curve_e_CX_CURVE_BrainPoolP384R1: cx_curve_e = 54;
#[doc = " BrainpoolP512t1"]
pub const cx_curve_e_CX_CURVE_BrainPoolP512T1: cx_curve_e = 55;
#[doc = " BrainpoolP512r1"]
pub const cx_curve_e_CX_CURVE_BrainPoolP512R1: cx_curve_e = 56;
#[doc = " BLS12-381 G1"]
pub const cx_curve_e_CX_CURVE_BLS12_381_G1: cx_curve_e = 57;
#[doc = " ANSSI FRP256"]
pub const cx_curve_e_CX_CURVE_FRP256V1: cx_curve_e = 65;
#[doc = " Stark"]
pub const cx_curve_e_CX_CURVE_Stark256: cx_curve_e = 81;
#[doc = " High limit (not included) of Weierstrass curve ID"]
pub const cx_curve_e_CX_CURVE_WEIERSTRASS_END: cx_curve_e = 111;
#[doc = " Low limit (not included) of  Twisted Edwards curve ID"]
pub const cx_curve_e_CX_CURVE_TWISTED_EDWARDS_START: cx_curve_e = 112;
#[doc = " Ed25519"]
pub const cx_curve_e_CX_CURVE_Ed25519: cx_curve_e = 113;
#[doc = " Ed448"]
pub const cx_curve_e_CX_CURVE_Ed448: cx_curve_e = 114;
#[doc = " High limit (not included) of Twisted Edwards curve ID"]
pub const cx_curve_e_CX_CURVE_TWISTED_EDWARDS_END: cx_curve_e = 127;
#[doc = " Low limit (not included) of Montgomery curve ID"]
pub const cx_curve_e_CX_CURVE_MONTGOMERY_START: cx_curve_e = 128;
#[doc = " Curve25519"]
pub const cx_curve_e_CX_CURVE_Curve25519: cx_curve_e = 129;
#[doc = " Curve448"]
pub const cx_curve_e_CX_CURVE_Curve448: cx_curve_e = 130;
#[doc = " High limit (not included) of Montgomery curve ID"]
pub const cx_curve_e_CX_CURVE_MONTGOMERY_END: cx_curve_e = 143;
#[doc = " List of supported elliptic curves"]
pub type cx_curve_e = cty::c_uint;
#[doc = " List of supported elliptic curves"]
pub use self::cx_curve_e as cx_curve_t;
#[doc = " @brief   Weierstrass curve defined by **y^3 = x^2 + a*x + b over GF(p)**.\n\n @details See #CX_CURVE_HEADER for the structure members."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_curve_weierstrass_s {
    pub curve: cx_curve_t,
    pub bit_size: cty::c_uint,
    pub length: cty::c_uint,
    pub a: *const u8,
    pub b: *const u8,
    pub p: *const u8,
    pub Gx: *const u8,
    pub Gy: *const u8,
    pub n: *const u8,
    pub h: *const u8,
    pub Hn: *const u8,
    pub Hp: *const u8,
}
#[test]
fn bindgen_test_layout_cx_curve_weierstrass_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_curve_weierstrass_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_curve_weierstrass_s>(),
        48usize,
        concat!("Size of: ", stringify!(cx_curve_weierstrass_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_curve_weierstrass_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_curve_weierstrass_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(bit_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Gx) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(Gx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Gy) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(Gy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Hn) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(Hn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Hp) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_weierstrass_s),
            "::",
            stringify!(Hp)
        )
    );
}
impl Default for cx_curve_weierstrass_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief   Weierstrass curve defined by **y^3 = x^2 + a*x + b over GF(p)**.\n\n @details See #CX_CURVE_HEADER for the structure members."]
pub type cx_curve_weierstrass_t = cx_curve_weierstrass_s;
#[doc = " @brief   Twisted Edwards curve defined by **a*x^2 + y^2 = 1 + d*x2*y2 over\n GF(q)**.\n\n @details See #CX_CURVE_HEADER for the structure members."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_curve_twisted_edwards_s {
    pub curve: cx_curve_t,
    pub bit_size: cty::c_uint,
    pub length: cty::c_uint,
    pub a: *const u8,
    pub b: *const u8,
    pub p: *const u8,
    pub Gx: *const u8,
    pub Gy: *const u8,
    pub n: *const u8,
    pub h: *const u8,
    pub Hn: *const u8,
    pub Hp: *const u8,
}
#[test]
fn bindgen_test_layout_cx_curve_twisted_edwards_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_curve_twisted_edwards_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_curve_twisted_edwards_s>(),
        48usize,
        concat!("Size of: ", stringify!(cx_curve_twisted_edwards_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_curve_twisted_edwards_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_curve_twisted_edwards_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(bit_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Gx) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(Gx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Gy) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(Gy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Hn) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(Hn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Hp) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_twisted_edwards_s),
            "::",
            stringify!(Hp)
        )
    );
}
impl Default for cx_curve_twisted_edwards_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief   Twisted Edwards curve defined by **a*x^2 + y^2 = 1 + d*x2*y2 over\n GF(q)**.\n\n @details See #CX_CURVE_HEADER for the structure members."]
pub type cx_curve_twisted_edwards_t = cx_curve_twisted_edwards_s;
#[doc = " @brief   Montgomery curve defined by **B*y^2= x^3 + A*x^2 + x over GF(q)**.\n\n @details See #CX_CURVE_HEADER for the structure members."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_curve_montgomery_s {
    pub curve: cx_curve_t,
    pub bit_size: cty::c_uint,
    pub length: cty::c_uint,
    pub a: *const u8,
    pub b: *const u8,
    pub p: *const u8,
    pub Gx: *const u8,
    pub Gy: *const u8,
    pub n: *const u8,
    pub h: *const u8,
    pub Hn: *const u8,
    pub Hp: *const u8,
}
#[test]
fn bindgen_test_layout_cx_curve_montgomery_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_curve_montgomery_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_curve_montgomery_s>(),
        48usize,
        concat!("Size of: ", stringify!(cx_curve_montgomery_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_curve_montgomery_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_curve_montgomery_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(bit_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Gx) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(Gx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Gy) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(Gy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Hn) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(Hn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Hp) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_montgomery_s),
            "::",
            stringify!(Hp)
        )
    );
}
impl Default for cx_curve_montgomery_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief   Montgomery curve defined by **B*y^2= x^3 + A*x^2 + x over GF(q)**.\n\n @details See #CX_CURVE_HEADER for the structure members."]
pub type cx_curve_montgomery_t = cx_curve_montgomery_s;
#[doc = " @brief   Abstract type for elliptic curve domain.\n\n @details See #CX_CURVE_HEADER for the structure members."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_curve_domain_s {
    pub curve: cx_curve_t,
    pub bit_size: cty::c_uint,
    pub length: cty::c_uint,
    pub a: *const u8,
    pub b: *const u8,
    pub p: *const u8,
    pub Gx: *const u8,
    pub Gy: *const u8,
    pub n: *const u8,
    pub h: *const u8,
    pub Hn: *const u8,
    pub Hp: *const u8,
}
#[test]
fn bindgen_test_layout_cx_curve_domain_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_curve_domain_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_curve_domain_s>(),
        48usize,
        concat!("Size of: ", stringify!(cx_curve_domain_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_curve_domain_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_curve_domain_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bit_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(bit_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).a) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(a)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).b) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Gx) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(Gx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Gy) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(Gy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).n) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(n)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Hn) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(Hn)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).Hp) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_curve_domain_s),
            "::",
            stringify!(Hp)
        )
    );
}
impl Default for cx_curve_domain_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief   Abstract type for elliptic curve domain.\n\n @details See #CX_CURVE_HEADER for the structure members."]
pub type cx_curve_domain_t = cx_curve_domain_s;
#[doc = " @brief Elliptic curve point."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ec_point_s {
    #[doc = "< Point's curve"]
    pub curve: cx_curve_t,
    #[doc = "< x-coordinate in affine representation"]
    pub x: cx_bn_t,
    #[doc = "< y-coordinate in affine representation"]
    pub y: cx_bn_t,
    #[doc = "< z-coordinate = 1 in affine representation"]
    pub z: cx_bn_t,
}
#[test]
fn bindgen_test_layout_cx_ec_point_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_ec_point_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_ec_point_s>(),
        16usize,
        concat!("Size of: ", stringify!(cx_ec_point_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ec_point_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ec_point_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ec_point_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ec_point_s),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ec_point_s),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).z) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ec_point_s),
            "::",
            stringify!(z)
        )
    );
}
impl Default for cx_ec_point_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Elliptic curve point."]
pub type cx_ecpoint_t = cx_ec_point_s;
#[doc = "< No parameter"]
pub const cx_curve_dom_param_s_CX_CURVE_PARAM_NONE: cx_curve_dom_param_s = 0;
#[doc = "< First coefficient of the curve"]
pub const cx_curve_dom_param_s_CX_CURVE_PARAM_A: cx_curve_dom_param_s = 1;
#[doc = "< Second coefficient of the curve"]
pub const cx_curve_dom_param_s_CX_CURVE_PARAM_B: cx_curve_dom_param_s = 2;
#[doc = "< Curve field"]
pub const cx_curve_dom_param_s_CX_CURVE_PARAM_Field: cx_curve_dom_param_s = 3;
#[doc = "< x-coordinate of the curve's generator"]
pub const cx_curve_dom_param_s_CX_CURVE_PARAM_Gx: cx_curve_dom_param_s = 4;
#[doc = "< y-coordinate of the curve's generator"]
pub const cx_curve_dom_param_s_CX_CURVE_PARAM_Gy: cx_curve_dom_param_s = 5;
#[doc = "< Order of the generator"]
pub const cx_curve_dom_param_s_CX_CURVE_PARAM_Order: cx_curve_dom_param_s = 6;
#[doc = "< Cofactor"]
pub const cx_curve_dom_param_s_CX_CURVE_PARAM_Cofactor: cx_curve_dom_param_s = 7;
#[doc = " @brief Identifiers of the domain parameters."]
pub type cx_curve_dom_param_s = cty::c_uint;
#[doc = " @brief Identifiers of the domain parameters."]
pub use self::cx_curve_dom_param_s as cx_curve_dom_param_t;
extern "C" {
    #[doc = " @brief   Return the bit length of each parameter of the curve.\n\n @param[in] curve   Curve identifier.\n\n @param[out] length Bit length of each parameter.\n\n @return            Error code:\n                    - CX_OK on success\n                    - CX_EC_INVALID_CURVE"]
    pub fn cx_ecdomain_size(curve: cx_curve_t, length: *mut usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Return the byte length of each parameter of the curve.\n\n @param[in]  cv     Curve identifier.\n\n @param[out] length Byte length of each parameter.\n\n @return            Error code:\n                    - CX_OK on success\n                    - CX_EC_INVALID_CURVE"]
    pub fn cx_ecdomain_parameters_length(cv: cx_curve_t, length: *mut usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Get a specific parameter of the curve.\n\n @param[in]  cv    Curve identifier.\n\n @param[in]  id    Parameter identifier.\n\n @param[out] p     Buffer where to store the parameter.\n\n @param[in]  p_len Length of the buffer.\n\n @return           Error code:\n                   - CX_OK on success\n                   - CX_EC_INVALID_CURVE\n                   - CX_INVALID_PARAMETER"]
    pub fn cx_ecdomain_parameter(
        cv: cx_curve_t,
        id: cx_curve_dom_param_t,
        p: *mut u8,
        p_len: u32,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Store a specific parameter of the curve as a BN.\n\n @param[in]  cv Curve identifier.\n\n @param[in]  id Parameter identifier.\n\n @param[out] p  BN where to store the parameter.\n\n @return        Error code:\n                - CX_OK on success\n                - CX_EC_INVALID_CURVE\n                - CX_NOT_LOCKED\n                - CX_INVALID_PARAMETER\n                - CX_INVALID_PARAMETER_SIZE"]
    pub fn cx_ecdomain_parameter_bn(
        cv: cx_curve_t,
        id: cx_curve_dom_param_t,
        p: cx_bn_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Get the generator of the curve.\n\n @param[in] cv   Curve identifier.\n\n @param[out] Gx  Buffer to store the x-coordinate of the generator.\n\n @param[out] Gy  Buffer to store the y-coordinate of the generator.\n\n @param[in]  len Byte length of each coordinate.\n\n @return         Error code:\n                 - CX_OK on success\n                 - CX_EC_INVALID_CURVE\n                 - CX_INVALID_PARAMETER"]
    pub fn cx_ecdomain_generator(cv: cx_curve_t, Gx: *mut u8, Gy: *mut u8, len: usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Get the generator of the curve and store it in the point structure.\n\n @param[in]  cv Curve identifier.\n\n @param[out] P  Pointer to the structure where to store the generator.\n\n @return        Error code:\n                - CX_OK on success\n                - CX_EC_INVALID_CURVE\n                - CX_NOT_LOCKED\n                - CX_INVALID_PARAMETER\n                - CX_INVALID_PARAMETER_SIZE\n                - CX_EC_INVALID_POINT"]
    pub fn cx_ecdomain_generator_bn(cv: cx_curve_t, P: *mut cx_ecpoint_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Allocate memory for a point on the curve.\n\n @param[in] P  Pointer to a point.\n\n @param[in] cv Curve on which the point is defined.\n\n @return       Error code:\n               - CX_OK on success\n               - CX_EC_INVALID_CURVE\n               - CX_NOT_LOCKED\n               - CX_INVALID_PARAMETER\n               - CX_MEMORY_FULL"]
    pub fn cx_ecpoint_alloc(P: *mut cx_ecpoint_t, cv: cx_curve_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Destroy a point on the curve.\n\n @param[in] P Pointer to the point to destroy. If the pointer is NULL,\n              nothing is done.\n\n @return      Error code:\n              - CX_OK on success\n              - CX_NOT_LOCKED\n              - CX_INVALID_PARAMETER\n              - CX_INTERNAL_ERROR"]
    pub fn cx_ecpoint_destroy(P: *mut cx_ecpoint_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Initialize a point on the curve.\n\n @param[in] P     Pointer to the point to initialize.\n\n @param[in] x     x-coordinate of the point. This must belong to the curve\n field.\n\n @param[in] x_len Length of the x-coordinate. This must be at most equal to\n the curve's domain number of bytes.\n\n @param[in] y     y-coordinate of the point. This must belong to the curve\n field.\n\n @param[in] y_len Length of the y-coordinate. This must be at most equal to\n the curve's domain number of bytes.\n\n @return          Error code:\n                  - CX_OK on success\n                  - CX_NOT_LOCKED\n                  - CX_INVALID_PARAMETER\n                  - CX_EC_INVALID_CURVE"]
    pub fn cx_ecpoint_init(
        P: *mut cx_ecpoint_t,
        x: *const u8,
        x_len: usize,
        y: *const u8,
        y_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Initialize a point on the curve with the BN indexes of the\n coordinates.\n\n @param[in] P Pointer to the point to initialize.\n\n @param[in] x BN index of the x-coordinate. The coordinate must\n              belong to the base field.\n\n @param[in] y BN index of the y-coordinate. The coordinate must\n              belong to the base field.\n\n @return      Error code:\n              - CX_OK on success\n              - CX_NOT_LOCKED\n              - CX_INVALID_PARAMETER\n              - CX_EC_INVALID_CURVE"]
    pub fn cx_ecpoint_init_bn(P: *mut cx_ecpoint_t, x: cx_bn_t, y: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Export a point.\n\n @details Fill two distinct buffers with the x-coordinate and the y-coordinate\n          of the point. If the point is not in affine representation, it will\n          be normalized first.\n\n @param[in]  P     Pointer to the point to export.\n\n @param[out] x     Buffer for the x-coordinate.\n\n @param[in]  x_len Length of the *x* buffer.\n\n @param[out] y     Buffer for the y-coordinate.\n\n @param[in]  y_len Length of the *y* buffer.\n\n @return           Error code:\n                   - CX_OK on success\n                   - CX_NOT_LOCKED\n                   - CX_INVALID_PARAMETER\n                   - CX_EC_INVALID_CURVE\n                   - CX_EC_INFINITE_POINT\n                   - CX_MEMORY_FULL"]
    pub fn cx_ecpoint_export(
        P: *const cx_ecpoint_t,
        x: *mut u8,
        x_len: usize,
        y: *mut u8,
        y_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Export a point using BN indexes of the coordinates.\n\n @param[in]  P Pointer to the point to export.\n\n @param[out] x Pointer to the BN index of the x-coordinate.\n\n @param[out] y Pointer to the BN index of the y-coordinate.\n\n @return       Error code:\n               - CX_OK on success\n               - CX_NOT_LOCKED\n               - CX_INVALID_PARAMETER\n               - CX_EC_INVALID_CURVE\n               - CX_EC_INFINITE_POINT\n               - CX_MEMORY_FULL"]
    pub fn cx_ecpoint_export_bn(
        P: *const cx_ecpoint_t,
        x: *mut cx_bn_t,
        y: *mut cx_bn_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Compute the compressed form of a point.\n\n @details The compressed form depends on the curve type.\n          For a Weierstrass or a Montgomery curve, the\n          compressed form consists of the x-coordinate and\n          a prefix. For a Twisted Edwards curve the compressed\n          form consists of a y-coordinate and a prefix.\n\n @param[in]  P Pointer to the point to be compressed.\n\n @param[out] xy_compressed     Buffer to hold the compressed\n                               coordinate.\n\n @param[in]  xy_compressed_len Length of the compressed coordinate in bytes.\n                               This should be equal to twice of the length of\n one coordinate plus one byte for the prefix.\n\n @param[out] sign              Pointer to the sign of the hidden coordinate:\n                               correspond to the least significant bit of the\n                               y-coordinate for a Weierstrass or Montgomery\n curve and of the x-coordinate for a Twisted Edwards curve.\n\n @return                       Error code:\n                               - CX_OK on success\n                               - CX_NOT_LOCKED\n                               - CX_INVALID_PARAMETER\n                               - CX_EC_INVALID_CURVE\n                               - CX_EC_INFINITE_POINT\n                               - CX_MEMORY_FULL"]
    pub fn cx_ecpoint_compress(
        P: *const cx_ecpoint_t,
        xy_compressed: *mut u8,
        xy_compressed_len: usize,
        sign: *mut u32,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Compute the affine coordinates of a point given its compressed form.\n\n @param[out] P Pointer to the point.\n\n @param[in]  xy_compressed     Pointer to the buffer holding the compressed\n                               coordinate.\n\n @param[in]  xy_compressed_len Length of the compressed coordinate in bytes.\n                               This should be equal to twice of the length of\n one coordinate plus one byte for the prefix.\n\n @param[in]  sign              Sign of the coordinate to recover.\n\n @return                       Error code:\n                               - CX_OK on success\n                               - CX_NOT_LOCKED\n                               - CX_INVALID_PARAMETER\n                               - CX_EC_INVALID_CURVE\n                               - CX_MEMORY_FULL\n                               - CX_NO_RESIDUE\n"]
    pub fn cx_ecpoint_decompress(
        P: *mut cx_ecpoint_t,
        xy_compressed: *const u8,
        xy_compressed_len: usize,
        sign: u32,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Add two points on a curve.\n\n @details Each point should not be the point at infinity.\n          If one of the point is the point at infinity then\n          the function returns a CX_EC_INFINITE_POINT error.\n\n @param[out] R Pointer to the result point.\n\n @param[in]  P Pointer to the first point to add.\n               The point must be on the curve.\n\n @param[in]  Q Pointer to the second point to add.\n               The point must be on the curve.\n\n @return       Error code:\n               - CX_OK on success\n               - CX_NOT_LOCKED\n               - CX_INVALID_PARAMETER\n               - CX_EC_INVALID_CURVE\n               - CX_EC_INVALID_POINT\n               - CX_EC_INFINITE_POINT\n               - CX_MEMORY_FULL"]
    pub fn cx_ecpoint_add(
        R: *mut cx_ecpoint_t,
        P: *const cx_ecpoint_t,
        Q: *const cx_ecpoint_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Compute the opposite of a point.\n\n @details The point should not be the point at infinity,\n          otherwise the function returns a CX_EC_INFINITE_POINT\n          error.\n\n @param[in, out] P Pointer to a point of the curve.\n                   and will hold the result.\n\n @return           Error code:\n                   - CX_OK on success\n                   - CX_NOT_LOCKED\n                   - CX_INVALID_PARAMETER\n                   - CX_EC_INVALID_CURVE\n                   - CX_EC_INVALID_POINT\n                   - CX_MEMORY_FULL\n                   - CX_EC_INFINITE_POINT"]
    pub fn cx_ecpoint_neg(P: *mut cx_ecpoint_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform a secure scalar multiplication.\n\n @param[in, out] P     Pointer to a point on a curve. This will hold the\n result.\n\n @param[in]      k     Pointer to the scalar. The scalar is an integer at\n least equal to 0 and at most equal to the order of the curve minus 1.\n\n @param[in]      k_len Length of the scalar. This should be equal to the\n domain length.\n\n @return               Error code:\n                       - CX_OK on success\n                       - CX_NOT_LOCKED\n                       - CX_INVALID_PARAMETER\n                       - CX_EC_INVALID_POINT\n                       - CX_EC_INVALID_CURVE\n                       - CX_EC_INFINITE_POINT\n                       - CX_MEMORY_FULL"]
    pub fn cx_ecpoint_rnd_scalarmul(P: *mut cx_ecpoint_t, k: *const u8, k_len: usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform a secure scalar multiplication given the BN index of the\n scalar.\n\n @param[in, out] P    Pointer to a point on a curve. This will hold the\n result.\n\n @param[in]      bn_k BN index of the scalar. The scalar is an integer at\n least equal to 0 and at most equal to the order of the curve minus 1.\n\n @return           Error code:\n                   - CX_OK on success\n                   - CX_NOT_LOCKED\n                   - CX_INVALID_PARAMETER\n                   - CX_EC_INVALID_POINT\n                   - CX_EC_INVALID_CURVE\n                   - CX_EC_INFINITE_POINT\n                   - CX_MEMORY_FULL"]
    pub fn cx_ecpoint_rnd_scalarmul_bn(P: *mut cx_ecpoint_t, bn_k: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform a secure scalar multiplication with a fixed scalar length.\n\n @param[in, out] P     Pointer to a point on a curve. This will hold the\n result.\n\n @param[in]      k     Pointer to the scalar. The scalar is an integer at\n least equal to 0 and at most equal to the order of the curve minus 1.\n\n @param[in]      k_len Length of the scalar. This should be equal to the\n domain length.\n\n @return               Error code:\n                       - CX_OK on success\n                       - CX_NOT_LOCKED\n                       - CX_INVALID_PARAMETER\n                       - CX_EC_INVALID_POINT\n                       - CX_EC_INVALID_CURVE\n                       - CX_EC_INFINITE_POINT\n                       - CX_MEMORY_FULL"]
    pub fn cx_ecpoint_rnd_fixed_scalarmul(
        P: *mut cx_ecpoint_t,
        k: *const u8,
        k_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform a scalar multiplication.\n\n @details This should be called only for non critical purposes.\n\n @param[in, out] P      Pointer to a point on a curve. This will hold the\n result.\n\n @param[in]      k      Pointer to the scalar. The scalar is an integer at\n least equal to 0 and at most equal to the order of the curve minus 1.\n\n @param[in]      k_len  Length of the scalar.\n\n @return                Error code:\n                        - CX_OK on success\n                        - CX_NOT_LOCKED\n                        - CX_INVALID_PARAMETER\n                        - CX_EC_INVALID_POINT\n                        - CX_EC_INVALID_CURVE\n                        - CX_EC_INFINITE_POINT\n                        - CX_MEMORY_FULL"]
    pub fn cx_ecpoint_scalarmul(P: *mut cx_ecpoint_t, k: *const u8, k_len: usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform a scalar multiplication given the BN index of the scalar.\n\n @details This should be called only for non critical purposes.\n\n @param[in, out] P    Pointer to a point on a curve. This will hold the\n result.\n\n @param[in]      bn_k BN index of the scalar. The scalar is an integer at\n least equal to 0 and at most equal to the order of the curve minus 1.\n\n @return              Error code:\n                      - CX_OK on success\n                      - CX_NOT_LOCKED\n                      - CX_INVALID_PARAMETER\n                      - CX_EC_INVALID_POINT\n                      - CX_EC_INVALID_CURVE\n                      - CX_EC_INFINITE_POINT\n                      - CX_MEMORY_FULL"]
    pub fn cx_ecpoint_scalarmul_bn(P: *mut cx_ecpoint_t, bn_k: cx_bn_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform a double scalar multiplication.\n\n @details This implements the Straus-Shamir algorithm for computing **R = [k]P\n + [r]Q**. This should be used only for non-secret computations.\n\n @param[out] R     Pointer to the result.\n\n @param[in]  P     Pointer to the first point.\n\n @param[in]  Q     Pointer to the second point.\n\n @param[in]  k     Pointer to the first scalar.\n\n @param[in]  k_len Length of the first scalar.\n\n @param[in]  r     Pointer to the second scalar.\n\n @param[in]  r_len Length of the second scalar.\n\n @return           Error code:\n                   - CX_OK on success\n                   - CX_NOT_LOCKED\n                   - CX_INVALID_PARAMETER\n                   - CX_EC_INVALID_POINT\n                   - CX_EC_INVALID_CURVE\n                   - CX_MEMORY_FULL\n                   - CX_EC_INFINITE_POINT"]
    pub fn cx_ecpoint_double_scalarmul(
        R: *mut cx_ecpoint_t,
        P: *mut cx_ecpoint_t,
        Q: *mut cx_ecpoint_t,
        k: *const u8,
        k_len: usize,
        r: *const u8,
        r_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform a double scalar multiplication given the BN indexes of the\n scalars.\n\n @details This implements the Straus-Shamir algorithm for computing **R = [k]P\n + [r]Q**. This should be used only for non-secret computations.\n\n @param[out] R     Pointer to the result.\n\n @param[in]  P     Pointer to the first point.\n\n @param[in]  Q     Pointer to the second point.\n\n @param[in]  bn_k  BN index of the first scalar.\n\n @param[in]  bn_r  BN index of the second scalar.\n\n @return           Error code:\n                  - CX_OK on success\n                  - CX_NOT_LOCKED\n                  - CX_INVALID_PARAMETER\n                  - CX_EC_INVALID_POINT\n                  - CX_EC_INVALID_CURVE\n                  - CX_MEMORY_FULL\n                  - CX_EC_INFINITE_POINT"]
    pub fn cx_ecpoint_double_scalarmul_bn(
        R: *mut cx_ecpoint_t,
        P: *mut cx_ecpoint_t,
        Q: *mut cx_ecpoint_t,
        bn_k: cx_bn_t,
        bn_r: cx_bn_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Compare two points on the same curve.\n\n @param[in]  P        First point to compare.\n\n @param[in]  Q        Second point to compare.\n\n @param[out] is_equal Boolean which indicates whether the two points are equal\n or not:\n                      - 1 if the points are equal\n                      - 0 otherwise\n\n @return              Error code:\n                      - CX_OK on success\n                      - CX_NOT_LOCKED\n                      - CX_INVALID_PARAMETER\n                      - CX_EC_INVALID_CURVE\n                      - CX_EC_INFINITE_POINT\n                      - CX_MEMORY_FULL"]
    pub fn cx_ecpoint_cmp(
        P: *const cx_ecpoint_t,
        Q: *const cx_ecpoint_t,
        is_equal: *mut bool,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Check if a given point is on the curve.\n\n @param[in]  R           Pointer to the point to check.\n\n @param[out] is_on_curve Boolean which indicates whether the point is on the\n curve or not:\n                         - 1 if the point is on the curve\n                         - 0 otherwise\n\n @return                 Error code:\n                         - CX_OK on success\n                         - CX_NOT_LOCKED\n                         - CX_INVALID_PARAMETER\n                         - CX_EC_INVALID_CURVE\n                         - CX_EC_INFINITE_POINT\n                         - CX_MEMORY_FULL"]
    pub fn cx_ecpoint_is_on_curve(R: *const cx_ecpoint_t, is_on_curve: *mut bool) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Check if a given point is the point at infinity.\n\n @details The point at infinity has a z-coordinate equal to 0.\n\n @param[in]  R              Pointer to the point to check.\n\n @param[out] is_at_infinity Boolean which indicates whether the point is at\n infinity or not:\n                            - 1 if the point is at infinity\n                            - 0 otherwise\n\n @return                    Error code:\n                            - CX_OK on success\n                            - CX_NOT_LOCKED\n                            - CX_INVALID_PARAMETER\n                            - CX_EC_INVALID_CURVE"]
    pub fn cx_ecpoint_is_at_infinity(R: *const cx_ecpoint_t, is_at_infinity: *mut bool)
        -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Get random data from the True Random Number Generation.\n\n @param[out] buf  Buffer where to store the random data.\n\n @param[in]  size Size of the random data in bytes.\n"]
    pub fn cx_trng_get_random_data(buf: *mut u8, size: usize);
}
extern "C" {
    pub fn cx_trng_selftest();
}
extern "C" {
    pub fn cx_trng_init();
}
pub type uint64bits_t = u64;
pub const generic_identifiers_ERR_GEN_ID_01: generic_identifiers = 1;
pub const generic_identifiers_ERR_GEN_ID_02: generic_identifiers = 2;
pub const generic_identifiers_ERR_GEN_ID_03: generic_identifiers = 3;
pub const generic_identifiers_ERR_GEN_ID_04: generic_identifiers = 4;
pub const generic_identifiers_ERR_GEN_ID_05: generic_identifiers = 5;
pub const generic_identifiers_ERR_GEN_ID_06: generic_identifiers = 6;
pub const generic_identifiers_ERR_GEN_ID_07: generic_identifiers = 7;
pub const generic_identifiers_ERR_GEN_ID_08: generic_identifiers = 8;
pub const generic_identifiers_ERR_GEN_ID_09: generic_identifiers = 9;
pub const generic_identifiers_ERR_GEN_ID_0A: generic_identifiers = 10;
pub const generic_identifiers_ERR_GEN_ID_0B: generic_identifiers = 11;
pub const generic_identifiers_ERR_GEN_ID_0C: generic_identifiers = 12;
pub const generic_identifiers_ERR_GEN_ID_0D: generic_identifiers = 13;
pub const generic_identifiers_ERR_GEN_ID_0E: generic_identifiers = 14;
pub const generic_identifiers_ERR_GEN_ID_0F: generic_identifiers = 15;
pub const generic_identifiers_ERR_GEN_ID_10: generic_identifiers = 16;
pub const generic_identifiers_ERR_GEN_ID_11: generic_identifiers = 17;
pub const generic_identifiers_ERR_GEN_ID_12: generic_identifiers = 18;
pub const generic_identifiers_ERR_GEN_ID_13: generic_identifiers = 19;
pub const generic_identifiers_ERR_GEN_ID_14: generic_identifiers = 20;
pub const generic_identifiers_ERR_GEN_ID_15: generic_identifiers = 21;
pub const generic_identifiers_ERR_GEN_ID_16: generic_identifiers = 22;
pub const generic_identifiers_ERR_GEN_ID_17: generic_identifiers = 23;
pub const generic_identifiers_ERR_GEN_ID_18: generic_identifiers = 24;
pub const generic_identifiers_ERR_GEN_ID_19: generic_identifiers = 25;
pub const generic_identifiers_ERR_GEN_ID_1A: generic_identifiers = 26;
pub const generic_identifiers_ERR_GEN_ID_1B: generic_identifiers = 27;
pub const generic_identifiers_ERR_GEN_ID_1C: generic_identifiers = 28;
pub const generic_identifiers_ERR_GEN_ID_1D: generic_identifiers = 29;
pub const generic_identifiers_ERR_GEN_ID_1E: generic_identifiers = 30;
pub const generic_identifiers_ERR_GEN_ID_1F: generic_identifiers = 31;
pub const generic_identifiers_ERR_GEN_ID_20: generic_identifiers = 32;
pub const generic_identifiers_ERR_GEN_ID_21: generic_identifiers = 33;
pub const generic_identifiers_ERR_GEN_ID_22: generic_identifiers = 34;
pub const generic_identifiers_ERR_GEN_ID_23: generic_identifiers = 35;
pub const generic_identifiers_ERR_GEN_ID_24: generic_identifiers = 36;
pub const generic_identifiers_ERR_GEN_ID_25: generic_identifiers = 37;
pub const generic_identifiers_ERR_GEN_ID_26: generic_identifiers = 38;
pub const generic_identifiers_ERR_GEN_ID_27: generic_identifiers = 39;
pub const generic_identifiers_ERR_GEN_ID_28: generic_identifiers = 40;
pub const generic_identifiers_ERR_GEN_ID_29: generic_identifiers = 41;
pub const generic_identifiers_ERR_GEN_ID_2A: generic_identifiers = 42;
pub const generic_identifiers_ERR_GEN_ID_2B: generic_identifiers = 43;
pub type generic_identifiers = cty::c_uint;
pub type exception_t = cty::c_ushort;
pub type try_context_t = try_context_s;
pub type jmp_buf = [cty::c_uint; 10usize];
extern "C" {
    pub fn longjmp(__jmpb: *mut cty::c_uint, __retval: cty::c_int) -> !;
}
extern "C" {
    pub fn setjmp(__jmpb: *mut cty::c_uint) -> cty::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct try_context_s {
    pub jmp_buf: jmp_buf,
    pub previous: *mut try_context_t,
    pub ex: exception_t,
}
#[test]
fn bindgen_test_layout_try_context_s() {
    const UNINIT: ::core::mem::MaybeUninit<try_context_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<try_context_s>(),
        48usize,
        concat!("Size of: ", stringify!(try_context_s))
    );
    assert_eq!(
        ::core::mem::align_of::<try_context_s>(),
        4usize,
        concat!("Alignment of ", stringify!(try_context_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).jmp_buf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(try_context_s),
            "::",
            stringify!(jmp_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).previous) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(try_context_s),
            "::",
            stringify!(previous)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ex) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(try_context_s),
            "::",
            stringify!(ex)
        )
    );
}
impl Default for try_context_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn try_context_get() -> *mut try_context_t;
}
extern "C" {
    pub fn try_context_set(context: *mut try_context_t) -> *mut try_context_t;
}
extern "C" {
    pub fn os_longjmp(exception: cty::c_uint) -> !;
}
extern "C" {
    pub fn os_parse_bertlv(
        mem: *mut cty::c_uchar,
        mem_len: cty::c_uint,
        tlv_instance_offset: *mut cty::c_uint,
        tag: cty::c_uint,
        offset: cty::c_uint,
        buffer: *mut *mut cty::c_void,
        maxlength: cty::c_uint,
    ) -> cty::c_uint;
}
#[doc = "< No message digest algorithm"]
pub const cx_md_e_CX_NONE: cx_md_e = 0;
#[doc = "< RIPEMD160 digest"]
pub const cx_md_e_CX_RIPEMD160: cx_md_e = 1;
#[doc = "< SHA224 digest"]
pub const cx_md_e_CX_SHA224: cx_md_e = 2;
#[doc = "< SHA256 digest"]
pub const cx_md_e_CX_SHA256: cx_md_e = 3;
#[doc = "< SHA384 digest"]
pub const cx_md_e_CX_SHA384: cx_md_e = 4;
#[doc = "< SHA512 digest"]
pub const cx_md_e_CX_SHA512: cx_md_e = 5;
#[doc = "< Keccak (pre-SHA3) digest"]
pub const cx_md_e_CX_KECCAK: cx_md_e = 6;
#[doc = "< SHA3 Digest"]
pub const cx_md_e_CX_SHA3: cx_md_e = 7;
#[doc = "< Groestl digest"]
pub const cx_md_e_CX_GROESTL: cx_md_e = 8;
#[doc = "< Blake digest"]
pub const cx_md_e_CX_BLAKE2B: cx_md_e = 9;
#[doc = "< SHAKE-128 digest"]
pub const cx_md_e_CX_SHAKE128: cx_md_e = 10;
#[doc = "< SHAKE-256 digest"]
pub const cx_md_e_CX_SHAKE256: cx_md_e = 11;
#[doc = "< SHA3-256 digest"]
pub const cx_md_e_CX_SHA3_256: cx_md_e = 12;
#[doc = "< SHA3-512 digest"]
pub const cx_md_e_CX_SHA3_512: cx_md_e = 13;
#[doc = " Message digest algorithm identifiers."]
pub type cx_md_e = cty::c_uint;
#[doc = " Message digest algorithm identifiers."]
pub use self::cx_md_e as cx_md_t;
#[doc = " @brief Common message digest context, used as abstract type."]
pub type cx_hash_t = cx_hash_header_s;
#[doc = " @brief Hash description."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_hash_info_t {
    #[doc = "< Message digest algorithm identifier"]
    pub md_type: cx_md_t,
    #[doc = "< Output size"]
    pub output_size: usize,
    #[doc = "< Block size"]
    pub block_size: usize,
    #[doc = "< Pointer to the initialization function"]
    pub init_func: ::core::option::Option<unsafe extern "C" fn(ctx: *mut cx_hash_t) -> cx_err_t>,
    #[doc = "< Pointer to the update function"]
    pub update_func: ::core::option::Option<
        unsafe extern "C" fn(ctx: *mut cx_hash_t, data: *const u8, len: usize) -> cx_err_t,
    >,
    #[doc = "< Pointer to the final function"]
    pub finish_func: ::core::option::Option<
        unsafe extern "C" fn(ctx: *mut cx_hash_t, digest: *mut u8) -> cx_err_t,
    >,
    #[doc = "< Pointer to the initialization function for extendable output"]
    pub init_ex_func: ::core::option::Option<
        unsafe extern "C" fn(ctx: *mut cx_hash_t, output_size: usize) -> cx_err_t,
    >,
    #[doc = "< Pointer to the output size function"]
    pub output_size_func:
        ::core::option::Option<unsafe extern "C" fn(ctx: *const cx_hash_t) -> usize>,
}
#[test]
fn bindgen_test_layout_cx_hash_info_t() {
    const UNINIT: ::core::mem::MaybeUninit<cx_hash_info_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_hash_info_t>(),
        32usize,
        concat!("Size of: ", stringify!(cx_hash_info_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_hash_info_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_hash_info_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).md_type) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_info_t),
            "::",
            stringify!(md_type)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).output_size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_info_t),
            "::",
            stringify!(output_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_info_t),
            "::",
            stringify!(block_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init_func) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_info_t),
            "::",
            stringify!(init_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).update_func) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_info_t),
            "::",
            stringify!(update_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).finish_func) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_info_t),
            "::",
            stringify!(finish_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init_ex_func) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_info_t),
            "::",
            stringify!(init_ex_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).output_size_func) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_info_t),
            "::",
            stringify!(output_size_func)
        )
    );
}
impl Default for cx_hash_info_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief Common message digest context, used as abstract type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_hash_header_s {
    #[doc = "< Hash description"]
    pub info: *const cx_hash_info_t,
    #[doc = "< Number of already processed blocks"]
    pub counter: u32,
}
#[test]
fn bindgen_test_layout_cx_hash_header_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_hash_header_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_hash_header_s>(),
        8usize,
        concat!("Size of: ", stringify!(cx_hash_header_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_hash_header_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_hash_header_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).info) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_header_s),
            "::",
            stringify!(info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).counter) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hash_header_s),
            "::",
            stringify!(counter)
        )
    );
}
impl Default for cx_hash_header_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub fn cx_hash_get_size(ctx: *const cx_hash_t) -> usize;
}
extern "C" {
    #[doc = " @brief   Hash data according to the specified algorithm.\n\n @param[in]  hash    Pointer to the hash context.\n                     Shall be in RAM.\n                     Should be called with a cast.\n\n @param[in]  mode    Crypto flag. Supported flag: CX_LAST. If set:\n                       - the structure is not modified after finishing\n                       - if out is not NULL, the message digest is stored in out\n                       - the context is NOT automatically re-initialized.\n\n @param[in]  in      Input data to be hashed.\n\n @param[in]  len     Length of the input data.\n\n @param[out] out     Buffer where to store the message digest:\n                       - NULL (ignored) if CX_LAST is NOT set\n                       - message digest if CX_LAST is set\n\n @param[out] out_len The size of the output buffer or 0 if out is NULL.\n                     If buffer is too small to store the hash a exception is returned.\n\n @return             Error code:\n                     - CX_OK on success\n                     - INVALID_PARAMETER\n                     - CX_INVALID_PARAMETER"]
    pub fn cx_hash_no_throw(
        hash: *mut cx_hash_t,
        mode: u32,
        in_: *const u8,
        len: usize,
        out: *mut u8,
        out_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Initialize a hash context.\n\n @param[out] hash    Pointer to the context to be initialized.\n                     The context shall be in RAM.\n\n @param[in]  hash_id Message digest algorithm identifier.\n\n @return             Error code:\n                     - CX_OK on success\n                     - CX_INVALID_PARAMETER"]
    pub fn cx_hash_init(hash: *mut cx_hash_t, hash_id: cx_md_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Initialize a hash context.\n\n @details Initialize a hash context with a chosen output length\n          (typically for eXtendable Output Functions (XOF)).\n\n @param[out] hash        Pointer to the context to be initialized.\n                         The context shall be in RAM.\n\n @param [in] hash_id     Hash algorithm identifier. Typically:\n                           - CX_BLAKE2B\n                           - CX_GROESTL\n                           - CX_SHAKE128\n                           - CX_SHAKE256\n\n @param [in] output_size Length of the output.\n\n @return                 Error code:\n                         - CX_OK on success\n                         - CX_INVALID_PARAMETER"]
    pub fn cx_hash_init_ex(hash: *mut cx_hash_t, hash_id: cx_md_t, output_size: usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Add more data to hash.\n\n @details A call to this function is equivalent to:\n          *cx_hash_no_throw(hash, 0, in, in_len, NULL, 0)*.\n\n @param[out] hash   Pointer to the hash context.\n\n @param[in]  in     Input data to add to the context.\n\n @param[in]  in_len Length of the input data.\n\n @return            Error code:\n                    - CX_OK on success\n                    - CX_INVALID_PARAMETER\n                    - INVALID_PARAMETER"]
    pub fn cx_hash_update(hash: *mut cx_hash_t, in_: *const u8, in_len: usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Finalize the hash.\n\n @details A call to this function is equivalent to:\n          *cx_hash_no_throw(hash, CX_LAST, NULL, 0, out, out_len)*.\n\n @param[in]  hash   Pointer to the hash context.\n\n @param[out] digest The message digest.\n\n @return            Error code:\n                    - CX_OK on success"]
    pub fn cx_hash_final(hash: *mut cx_hash_t, digest: *mut u8) -> cx_err_t;
}
#[doc = " @brief RIPEMD-160 context."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ripemd160_s {
    #[doc = "< See #cx_hash_header_s"]
    pub header: cx_hash_header_s,
    #[doc = "< Pending partial block length"]
    pub blen: usize,
    #[doc = "< Pending partial block"]
    pub block: [u8; 64usize],
    #[doc = "< Current digest state"]
    pub acc: [u8; 20usize],
}
#[test]
fn bindgen_test_layout_cx_ripemd160_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_ripemd160_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_ripemd160_s>(),
        96usize,
        concat!("Size of: ", stringify!(cx_ripemd160_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ripemd160_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ripemd160_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ripemd160_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blen) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ripemd160_s),
            "::",
            stringify!(blen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ripemd160_s),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).acc) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ripemd160_s),
            "::",
            stringify!(acc)
        )
    );
}
impl Default for cx_ripemd160_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief RIPEMD-160 context."]
pub type cx_ripemd160_t = cx_ripemd160_s;
extern "C" {
    #[doc = " @brief   Initialize a RIPEMD-160 context.\n\n @param[out] hash Pointer to the context.\n                  The context shall be in RAM.\n\n @return          Error code:\n                  - CX_OK on success"]
    pub fn cx_ripemd160_init_no_throw(hash: *mut cx_ripemd160_t) -> cx_err_t;
}
#[doc = " @brief SHA-224 and SHA-256 context"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_sha256_s {
    #[doc = "< @copydoc cx_ripemd160_s::header"]
    pub header: cx_hash_header_s,
    #[doc = "< @copydoc cx_ripemd160_s::blen"]
    pub blen: usize,
    #[doc = "< @copydoc cx_ripemd160_s::block"]
    pub block: [u8; 64usize],
    #[doc = "< @copydoc cx_ripemd160_s::acc"]
    pub acc: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_cx_sha256_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_sha256_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_sha256_s>(),
        108usize,
        concat!("Size of: ", stringify!(cx_sha256_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_sha256_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_sha256_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha256_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blen) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha256_s),
            "::",
            stringify!(blen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha256_s),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).acc) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha256_s),
            "::",
            stringify!(acc)
        )
    );
}
impl Default for cx_sha256_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief SHA-224 and SHA-256 context"]
pub type cx_sha256_t = cx_sha256_s;
extern "C" {
    #[doc = " @brief   Initialize a SHA-256 context.\n\n @param[out] hash Pointer to the context.\n                  The context shall be in RAM.\n\n @return          Error code:\n                  - CX_OK on success"]
    pub fn cx_sha256_init_no_throw(hash: *mut cx_sha256_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Compute a one shot SHA-256 digest.\n\n @param[in]  in      Input data.\n\n @param[in]  len     Length of the input data.\n\n @param[out] out     Buffer where to store the digest.\n\n @param[in]  out_len Length of the output.\n                     This is actually 256 bits.\n"]
    pub fn cx_hash_sha256(in_: *const u8, len: usize, out: *mut u8, out_len: usize) -> usize;
}
#[doc = " @brief SHA-384 and SHA-512 context"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_sha512_s {
    #[doc = "< @copydoc cx_ripemd160_s::header"]
    pub header: cx_hash_header_s,
    #[doc = "< @copydoc cx_ripemd160_s::blen"]
    pub blen: usize,
    #[doc = "< @copydoc cx_ripemd160_s::block"]
    pub block: [u8; 128usize],
    #[doc = "< @copydoc cx_ripemd160_s::acc"]
    pub acc: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_cx_sha512_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_sha512_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_sha512_s>(),
        204usize,
        concat!("Size of: ", stringify!(cx_sha512_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_sha512_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_sha512_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha512_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blen) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha512_s),
            "::",
            stringify!(blen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha512_s),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).acc) as usize - ptr as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha512_s),
            "::",
            stringify!(acc)
        )
    );
}
impl Default for cx_sha512_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief SHA-384 and SHA-512 context"]
pub type cx_sha512_t = cx_sha512_s;
extern "C" {
    #[doc = " @brief   Initialize a SHA-384 context.\n\n @param[out] hash Pointer to the context.\n                  The context shall be in RAM.\n\n @return          Error code:\n                  - CX_OK on success"]
    pub fn cx_sha384_init_no_throw(hash: *mut cx_sha512_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Initialize a SHA-512 context.\n\n @param[out] hash Pointer to the context.\n                  The context shall be in RAM.\n\n @return          Error code:\n                  - CX_OK on success"]
    pub fn cx_sha512_init_no_throw(hash: *mut cx_sha512_t) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Compute a one shot SHA-512 digest.\n\n @param[in]  in      Input data.\n\n @param[in]  in_len  Length of the input data.\n\n @param[out] out     Buffer where to store the output.\n\n @param[out] out_len Length of the output.\n                     This is actually 512 bits."]
    pub fn cx_hash_sha512(in_: *const u8, in_len: usize, out: *mut u8, out_len: usize) -> usize;
}
#[doc = " @brief KECCAK, SHA3 and SHA3-XOF context"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_sha3_s {
    #[doc = "< @copydoc cx_ripemd160_s::header"]
    pub header: cx_hash_header_s,
    #[doc = "< Output digest size"]
    pub output_size: usize,
    #[doc = "< Input block size"]
    pub block_size: usize,
    #[doc = "< @copydoc cx_ripemd160_s::blen"]
    pub blen: usize,
    #[doc = "< @copydoc cx_ripemd160_s::block"]
    pub block: [u8; 200usize],
    #[doc = "< @copydoc cx_ripemd160_s::acc"]
    pub acc: [uint64bits_t; 25usize],
}
#[test]
fn bindgen_test_layout_cx_sha3_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_sha3_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_sha3_s>(),
        424usize,
        concat!("Size of: ", stringify!(cx_sha3_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_sha3_s>(),
        8usize,
        concat!("Alignment of ", stringify!(cx_sha3_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha3_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).output_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha3_s),
            "::",
            stringify!(output_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block_size) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha3_s),
            "::",
            stringify!(block_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).blen) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha3_s),
            "::",
            stringify!(blen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).block) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha3_s),
            "::",
            stringify!(block)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).acc) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_sha3_s),
            "::",
            stringify!(acc)
        )
    );
}
impl Default for cx_sha3_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief KECCAK, SHA3 and SHA3-XOF context"]
pub type cx_sha3_t = cx_sha3_s;
extern "C" {
    #[doc = " @brief   Initialize a SHA3 context.\n\n @details Supported output sizes in bits:\n            - 224\n            - 256\n            - 384\n            - 512\n\n @param[out] hash Pointer to the SHA3 context.\n                  The context shall be in RAM.\n\n @param[in]  size Length of the hash output in bits.\n\n @return          Error code:\n                  - CX_OK on success\n                  - CX_INVALID_PARAMETER"]
    pub fn cx_sha3_init_no_throw(hash: *mut cx_sha3_t, size: usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief Initialize a KECCAK context.\n\n @details Supported output sizes in bits:\n            - 224\n            - 256\n            - 384\n            - 512\n\n\n @param[out] hash  Pointer to the KECCAK context.\n                   The context shall be in RAM.\n\n @param[in]  size  Length of the hash output in bits.\n\n @return           Error code:\n                   - CX_OK on success\n                   - CX_INVALID_PARAMETER"]
    pub fn cx_keccak_init_no_throw(hash: *mut cx_sha3_t, size: usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Initialize a SHA3-XOF context.\n\n @details SHAKE128 is a SHA3-XOF (Extendable Output Function\n          based on SHA3) with a 128-bit security.\n          Supported output sizes in bits:\n            - 256\n            - 512\n\n @param[out] hash      Pointer to the context.\n                       The context shall be in RAM.\n\n @param[in]  out_size  Length of the output in bits.\n\n @return               Error code:\n                       - CX_OK on success\n                       - CX_INVALID_PARAMETER"]
    pub fn cx_shake128_init_no_throw(hash: *mut cx_sha3_t, out_size: usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Initialize a SHA3-XOF context.\n\n @details SHAKE256 is a SHA3-XOF (Extendable Output Function\n          based on SHA3) with a 256-bit security.\n          Supported output sizes in bits:\n            - 256\n            - 512\n\n @param[out] hash      Pointer to the context.\n                       The context shall be in RAM.\n\n @param[in]  out_size  Length of the output in bits.\n\n @return               Error code:\n                       - CX_OK on success\n                       - CX_INVALID_PARAMETER"]
    pub fn cx_shake256_init_no_throw(hash: *mut cx_sha3_t, out_size: usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Initialize a SHA3-XOF context.\n\n @details This can be used to initialize either SHAKE128\n          or SHAKE256.\n          Supported output sizes in bits:\n            - 256\n            - 512\n\n @param[out] hash         Pointer to the context.\n                          The context shall be in RAM.\n\n @param[in]  size         Length of SHA3 digest in bits.\n\n @param[in]  out_length   Length of the output in bytes.\n\n @return                  Error code:\n                          - CX_OK on success\n                          - CX_INVALID_PARAMETER"]
    pub fn cx_sha3_xof_init_no_throw(
        hash: *mut cx_sha3_t,
        size: usize,
        out_length: usize,
    ) -> cx_err_t;
}
#[doc = "< Size of a block"]
pub const blake2b_constant_BLAKE2B_BLOCKBYTES: blake2b_constant = 128;
#[doc = "< Size of the output"]
pub const blake2b_constant_BLAKE2B_OUTBYTES: blake2b_constant = 64;
#[doc = "< Size of the key"]
pub const blake2b_constant_BLAKE2B_KEYBYTES: blake2b_constant = 64;
#[doc = "< Size of the salt"]
pub const blake2b_constant_BLAKE2B_SALTBYTES: blake2b_constant = 16;
#[doc = "< Size of the personalization string"]
pub const blake2b_constant_BLAKE2B_PERSONALBYTES: blake2b_constant = 16;
#[doc = "  @private BLAKE2b constants"]
pub type blake2b_constant = cty::c_uint;
#[doc = "  @private BLAKE2b state members"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct blake2b_state__ {
    #[doc = "< Internal state of the hash"]
    pub h: [u64; 8usize],
    #[doc = "< Message byte offset at the end of the current block"]
    pub t: [u64; 2usize],
    #[doc = "< Flag indicating the last block"]
    pub f: [u64; 2usize],
    #[doc = "< Buffer for the processed data"]
    pub buf: [u8; 128usize],
    #[doc = "< Length of the buffer"]
    pub buflen: usize,
    #[doc = "< Length of the output"]
    pub outlen: usize,
    #[doc = "< Last node"]
    pub last_node: u8,
}
#[test]
fn bindgen_test_layout_blake2b_state__() {
    const UNINIT: ::core::mem::MaybeUninit<blake2b_state__> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<blake2b_state__>(),
        240usize,
        concat!("Size of: ", stringify!(blake2b_state__))
    );
    assert_eq!(
        ::core::mem::align_of::<blake2b_state__>(),
        8usize,
        concat!("Alignment of ", stringify!(blake2b_state__))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state__),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).t) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state__),
            "::",
            stringify!(t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state__),
            "::",
            stringify!(f)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buf) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state__),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).buflen) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state__),
            "::",
            stringify!(buflen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).outlen) as usize - ptr as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state__),
            "::",
            stringify!(outlen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).last_node) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(blake2b_state__),
            "::",
            stringify!(last_node)
        )
    );
}
impl Default for blake2b_state__ {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = "  @private BLAKE2b state members"]
pub type blake2b_state = blake2b_state__;
#[doc = " @brief BLAKE2b context"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_blake2b_s {
    #[doc = "< @copydoc cx_ripemd160_s::header"]
    pub header: cx_hash_header_s,
    #[doc = "< Output digest size"]
    pub output_size: usize,
    #[doc = "< BLAKE2B state"]
    pub ctx: blake2b_state__,
}
#[test]
fn bindgen_test_layout_cx_blake2b_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_blake2b_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_blake2b_s>(),
        256usize,
        concat!("Size of: ", stringify!(cx_blake2b_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_blake2b_s>(),
        8usize,
        concat!("Alignment of ", stringify!(cx_blake2b_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).header) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_blake2b_s),
            "::",
            stringify!(header)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).output_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_blake2b_s),
            "::",
            stringify!(output_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ctx) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_blake2b_s),
            "::",
            stringify!(ctx)
        )
    );
}
impl Default for cx_blake2b_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief BLAKE2b context"]
pub type cx_blake2b_t = cx_blake2b_s;
extern "C" {
    #[doc = " @brief   Initialize BLAKE2b message digest context.\n\n @param[out] hash    Pointer to the BLAKE2b context to initialize.\n                     The context shall be in RAM.\n\n @param[in]  out_len Digest size in bits.\n\n @return             Error code:\n                     - CX_OK\n                     - CX_INVALID_PARAMETER"]
    pub fn cx_blake2b_init_no_throw(hash: *mut cx_blake2b_t, out_len: usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Initialize BLAKE2b message digest context with\n          salt and personnalization string.\n\n @param[out] hash     Pointer to the BLAKE2b context to initialize.\n                      The context shall be in RAM.\n\n @param[in] out_len   Digest size in bits.\n\n @param[in] salt      Pointer to a salt (optional).\n\n @param[in] salt_len  Length of the salt.\n\n @param[in] perso     Pointer to a personalization string (optional).\n\n @param[in] perso_len Length of the personalization string.\n\n @return              Error code:\n                      - CX_OK on success\n                      - CX_INVALID_PARAMETER"]
    pub fn cx_blake2b_init2_no_throw(
        hash: *mut cx_blake2b_t,
        out_len: usize,
        salt: *mut u8,
        salt_len: usize,
        perso: *mut u8,
        perso_len: usize,
    ) -> cx_err_t;
}
#[doc = " @brief HMAC context, abstract type"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_hmac_t {
    #[doc = "< Key"]
    pub key: [u8; 128usize],
    #[doc = "< Hash context"]
    pub hash_ctx: cx_hash_t,
}
#[test]
fn bindgen_test_layout_cx_hmac_t() {
    const UNINIT: ::core::mem::MaybeUninit<cx_hmac_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_hmac_t>(),
        136usize,
        concat!("Size of: ", stringify!(cx_hmac_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_hmac_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_hmac_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hmac_t),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hash_ctx) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hmac_t),
            "::",
            stringify!(hash_ctx)
        )
    );
}
impl Default for cx_hmac_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " @brief HMAC context, concrete type for RIPEMD160"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_hmac_ripemd160_t {
    #[doc = "< Key"]
    pub key: [u8; 128usize],
    #[doc = "< Hash context"]
    pub hash_ctx: cx_ripemd160_t,
}
#[test]
fn bindgen_test_layout_cx_hmac_ripemd160_t() {
    const UNINIT: ::core::mem::MaybeUninit<cx_hmac_ripemd160_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_hmac_ripemd160_t>(),
        224usize,
        concat!("Size of: ", stringify!(cx_hmac_ripemd160_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_hmac_ripemd160_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_hmac_ripemd160_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hmac_ripemd160_t),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hash_ctx) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hmac_ripemd160_t),
            "::",
            stringify!(hash_ctx)
        )
    );
}
impl Default for cx_hmac_ripemd160_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief   Initialize a HMAC-RIPEMD160 context.\n\n @param[out] hmac    Pointer to the HMAC context.\n                     The context shall be in RAM.\n\n @param[in]  key     Pointer to the HMAC key value.\n                     If a key has been set, passing\n                     NULL pointeur will reinitialize\n                     the context with the previously set key.\n\n @param [in] key_len Length of the key.\n                     The key length shall be less than 64 bytes.\n\n @return             Error code:\n                     - CX_OK on success\n                     - CX_INVALID_PARAMETER"]
    pub fn cx_hmac_ripemd160_init_no_throw(
        hmac: *mut cx_hmac_ripemd160_t,
        key: *const u8,
        key_len: usize,
    ) -> cx_err_t;
}
#[doc = " @brief HMAC context, concrete type for SHA-224/SHA-256"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_hmac_sha256_t {
    #[doc = "< Key"]
    pub key: [u8; 128usize],
    #[doc = "< Hash context"]
    pub hash_ctx: cx_sha256_t,
}
#[test]
fn bindgen_test_layout_cx_hmac_sha256_t() {
    const UNINIT: ::core::mem::MaybeUninit<cx_hmac_sha256_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_hmac_sha256_t>(),
        236usize,
        concat!("Size of: ", stringify!(cx_hmac_sha256_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_hmac_sha256_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_hmac_sha256_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hmac_sha256_t),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hash_ctx) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hmac_sha256_t),
            "::",
            stringify!(hash_ctx)
        )
    );
}
impl Default for cx_hmac_sha256_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief   Initialize a HMAC-SHA256 context.\n\n @param[out] hmac    Pointer to the HMAC context.\n                     The context shall be in RAM.\n\n @param[in]  key     Pointer to the HMAC key value.\n                     If a key has been set, passing\n                     NULL pointeur will reinitialize\n                     the context with the previously set key.\n\n @param [in] key_len Length of the key.\n                     The key length shall be less than 64 bytes.\n\n @return             Error code:\n                     - CX_OK on success\n                     - CX_INVALID_PARAMETER"]
    pub fn cx_hmac_sha256_init_no_throw(
        hmac: *mut cx_hmac_sha256_t,
        key: *const u8,
        key_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Compute a HMAC value using SHA256.\n\n @param[in]  key     HMAC key value.\n\n @param[in]  key_len Length of the HMAC key.\n\n @param[in]  in      Input data.\n\n @param[in]  len     Length of the input data.\n\n @param[out] mac     Computed HMAC value.\n\n @param[in]  mac_len Size of the output buffer.\n                     The buffer size must be larger\n                     than the length of the HMAC value.\n\n @return             Length of the HMAC value."]
    pub fn cx_hmac_sha256(
        key: *const u8,
        key_len: usize,
        in_: *const u8,
        len: usize,
        mac: *mut u8,
        mac_len: usize,
    ) -> usize;
}
#[doc = " @brief HMAC context, concrete type for SHA-384/SHA-512"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_hmac_sha512_t {
    #[doc = "< Key"]
    pub key: [u8; 128usize],
    #[doc = "< Hash context"]
    pub hash_ctx: cx_sha512_t,
}
#[test]
fn bindgen_test_layout_cx_hmac_sha512_t() {
    const UNINIT: ::core::mem::MaybeUninit<cx_hmac_sha512_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_hmac_sha512_t>(),
        332usize,
        concat!("Size of: ", stringify!(cx_hmac_sha512_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_hmac_sha512_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_hmac_sha512_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).key) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hmac_sha512_t),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).hash_ctx) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_hmac_sha512_t),
            "::",
            stringify!(hash_ctx)
        )
    );
}
impl Default for cx_hmac_sha512_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    #[doc = " @brief   Initialize a HMAC-SHA512 context.\n\n @param[out] hmac    Pointer to the context.\n                     The context shall be in RAM.\n\n @param[in]  key     Pointer to the HMAC key value.\n                     If a key has been set, passing\n                     NULL pointeur will reinitialize\n                     the context with the previously set key.\n\n @param[in]  key_len Length of the key.\n                     The key length shall be less than 128 bytes.\n\n @return             Error code:\n                     - CX_OK on success\n                     - CX_INVALID_PARAMETER"]
    pub fn cx_hmac_sha512_init_no_throw(
        hmac: *mut cx_hmac_sha512_t,
        key: *const u8,
        key_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Compute a HMAC value using SHA512.\n\n @param[in]  key     HMAC key value.\n\n @param[in]  key_len Length of the HMAC key.\n\n @param[in]  in      Input data.\n\n @param[in]  len     Length of the input data.\n\n @param[out] mac     Computed HMAC value.\n\n @param[in]  mac_len Size of the output buffer.\n                     The buffer size must be larger\n                     than the length of the HMAC value.\n\n @return             Length of the HMAC value."]
    pub fn cx_hmac_sha512(
        key: *const u8,
        key_len: usize,
        in_: *const u8,
        len: usize,
        mac: *mut u8,
        mac_len: usize,
    ) -> usize;
}
extern "C" {
    #[doc = " @brief   Compute a HMAC value according to the specified\n          hash function.\n\n @param[in]  hmac    Pointer to the HMAC context.\n                     The context shall be initialized with\n                     one of the initialization functions.\n                     The context shall be in RAM.\n                     The function shall be called with the cast\n                     (cx_hmac_t *).\n\n @param[in]  mode    Crypto mode flags. Supported flags:\n                       - CX_LAST\n                       - CX_NO_REINIT\n                     If CX_LAST is set and CX_NO_REINIT is not set, the context is\n                     reinitialized.\n\n @param[in]  in      Input data to add to the context.\n\n @param[in]  len     Length of the input data.\n\n @param[out] mac     Pointer to the computed HMAC or NULL pointer (if CX_LAST is not set).\n\n @param[in]  mac_len Length of the output buffer if not NULL, 0 otherwise.\n                     The buffer size must be larger\n                     than the length of the HMAC value.\n\n @return             Error code:\n                     - CX_OK on success\n                     - CX_INVALID_PARAMETER"]
    pub fn cx_hmac_no_throw(
        hmac: *mut cx_hmac_t,
        mode: u32,
        in_: *const u8,
        len: usize,
        mac: *mut u8,
        mac_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Initialize a HMAC context.\n\n @param[out] hmac    Pointer to the context.\n                     The context shall be in RAM.\n\n @param[in]  hash_id The message digest algorithm identifier\n\n @param[in]  key     Pointer to the HMAC key value.\n                     If a key has been set, passing\n                     NULL pointeur will reinitialize\n                     the context with the previously set key.\n\n @param[in]  key_len Length of the key.\n                     The key length shall be less than 128 bytes.\n\n @return             Error code:\n                     - CX_OK on success\n                     - CX_INVALID_PARAMETER"]
    pub fn cx_hmac_init(
        hmac: *mut cx_hmac_t,
        hash_id: cx_md_t,
        key: *const u8,
        key_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Add more data to compute the HMAC.\n\n @details A call to this function is equivalent to:\n          *cx_hmac_no_throw(hmac, 0, in, in_len, NULL, 0)*.\n\n @param[out] hmac   Pointer to the HMAC context.\n\n @param[in]  in     Input data to add to the context.\n\n @param[in]  in_len Length of the input data.\n\n @return            Error code:\n                    - CX_OK on success\n                    - CX_INVALID_PARAMETER\n                    - INVALID_PARAMETER"]
    pub fn cx_hmac_update(hmac: *mut cx_hmac_t, in_: *const u8, in_len: usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Finalize the HMAC algorithm.\n\n @details A call to this function is\n          equivalent to *cx_hmac_no_throw(hash, CX_LAST, NULL, 0, out, out_len)*.\n\n @param[in]  ctx     Pointer to the HMAC context.\n @param[out] out     Computed HMAC value is CX_LAST is set.\n\n @param[in]  out_len Length of the output (the most significant bytes).\n\n @return             Error code:\n                     - CX_OK on success"]
    pub fn cx_hmac_final(ctx: *mut cx_hmac_t, out: *mut u8, out_len: *mut usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief Compare two integers represented as byte arrays.\n\n @param[in]  a      Pointer to the first integer.\n\n @param[in]  b      Pointer to the second integer.\n\n @param[in]  length Number of bytes taken into account for the comparison.\n\n @param[out] diff   Result of the comparison:\n                    - 0 if a and b are identical\n                    - < 0 if a is less than b\n                    - > 0 if a is greater than b\n\n @return            Error code:\n                    - CX_OK on success\n                    - CX_NOT_UNLOCKED\n                    - CX_INVALID_PARAMETER_SIZE\n                    - CX_NOT_LOCKED\n                    - CX_MEMORY_FULL\n                    - CX_INVALID_PARAMETER"]
    pub fn cx_math_cmp_no_throw(
        a: *const u8,
        b: *const u8,
        length: usize,
        diff: *mut cty::c_int,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief Add two integers represented as byte arrays.\n\n @param[out] r   Buffer for the result.\n\n @param[in]  a   Pointer to the first integer.\n\n @param[in]  b   Pointer to the second integer.\n\n @param[in]  len Number of bytes taken into account for the addition.\n\n @return         Error code:\n                 - CX_OK on success\n                 - CX_NOT_UNLOCKED\n                 - CX_INVALID_PARAMETER_SIZE\n                 - CX_NOT_LOCKED\n                 - CX_MEMORY_FULL\n                 - CX_INVALID_PARAMETER"]
    pub fn cx_math_add_no_throw(r: *mut u8, a: *const u8, b: *const u8, len: usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief Subtract two integers represented as byte arrays.\n\n @param[out] r   Buffer for the result.\n\n @param[in]  a   Pointer to the first integer.\n\n @param[in]  b   Pointer to the second integer.\n\n @param[in]  len Number of bytes taken into account for the subtraction.\n\n @return         Error code:\n                 - CX_OK on success\n                 - CX_NOT_UNLOCKED\n                 - CX_INVALID_PARAMETER_SIZE\n                 - CX_NOT_LOCKED\n                 - CX_MEMORY_FULL\n                 - CX_INVALID_PARAMETER"]
    pub fn cx_math_sub_no_throw(r: *mut u8, a: *const u8, b: *const u8, len: usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief Multiply two integers represented as byte arrays.\n\n @param[out] r   Buffer for the result.\n\n @param[in]  a   Pointer to the first integer.\n\n @param[in]  b   Pointer to the second integer.\n\n @param[in]  len Number of bytes taken into account for the multiplication.\n\n @return         Error code:\n                 - CX_OK on success\n                 - CX_NOT_UNLOCKED\n                 - CX_INVALID_PARAMETER_SIZE\n                 - CX_NOT_LOCKED\n                 - CX_MEMORY_FULL\n                 - CX_INVALID_PARAMETER"]
    pub fn cx_math_mult_no_throw(r: *mut u8, a: *const u8, b: *const u8, len: usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief Modular addition of two integers represented as byte arrays.\n\n @param[out] r   Buffer for the result.\n\n @param[in]  a   Pointer to the first integer.\n                 This must be strictly smaller than the modulus.\n\n @param[in]  b   Pointer to the second integer.\n                 This must be strictly smaller than the modulus.\n\n @param[in]  m   Modulus\n\n @param[in]  len Number of bytes taken into account for the operation.\n\n @return         Error code:\n                 - CX_OK on success\n                 - CX_NOT_UNLOCKED\n                 - CX_INVALID_PARAMETER_SIZE\n                 - CX_NOT_LOCKED\n                 - CX_MEMORY_FULL\n                 - CX_INVALID_PARAMETER"]
    pub fn cx_math_addm_no_throw(
        r: *mut u8,
        a: *const u8,
        b: *const u8,
        m: *const u8,
        len: usize,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief Modular subtraction of two integers represented as byte arrays.\n\n @param[out] r   Buffer for the result.\n\n @param[in]  a   Pointer to the first integer.\n                 This must be strictly smaller than the modulus.\n\n @param[in]  b   Pointer to the second integer.\n                 This must be strictly smaller than the modulus.\n\n @param[in]  m   Modulus\n\n @param[in]  len Number of bytes taken into account for the operation.\n\n @return         Error code:\n                 - CX_OK on success\n                 - CX_NOT_UNLOCKED\n                 - CX_INVALID_PARAMETER_SIZE\n                 - CX_NOT_LOCKED\n                 - CX_MEMORY_FULL\n                 - CX_INVALID_PARAMETER"]
    pub fn cx_math_subm_no_throw(
        r: *mut u8,
        a: *const u8,
        b: *const u8,
        m: *const u8,
        len: usize,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief Modular multiplication of two integers represented as byte arrays.\n\n @param[out] r   Buffer for the result.\n\n @param[in]  a   Pointer to the first integer.\n\n @param[in]  b   Pointer to the second integer.\n                 This must be strictly smaller than the modulus.\n\n @param[in]  m   Modulus\n\n @param[in]  len Number of bytes taken into account for the operation.\n\n @return         Error code:\n                 - CX_OK on success\n                 - CX_NOT_UNLOCKED\n                 - CX_INVALID_PARAMETER_SIZE\n                 - CX_NOT_LOCKED\n                 - CX_MEMORY_FULL\n                 - CX_INVALID_PARAMETER\n                 - CX_INVALID_PARAMETER_VALUE"]
    pub fn cx_math_multm_no_throw(
        r: *mut u8,
        a: *const u8,
        b: *const u8,
        m: *const u8,
        len: usize,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Modulo operation.\n\n @details Compute the remainder of the division of v by m. Store the result in v.\n\n @param[in,out] v     Pointer to the dividend and buffer for the result.\n\n @param[in]     len_v Number of bytes of the dividend.\n\n @param[in]     m     Modulus.\n\n @param[in]     len_m Number of bytes of the modulus.\n\n @return              Error code:\n                      - CX_OK on success\n                      - CX_NOT_UNLOCKED\n                      - CX_INVALID_PARAMETER_SIZE\n                      - CX_NOT_LOCKED\n                      - CX_MEMORY_FULL\n                      - CX_INVALID_PARAMETER"]
    pub fn cx_math_modm_no_throw(v: *mut u8, len_v: usize, m: *const u8, len_m: usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Modular exponentiation.\n\n @details Compute the result of **a^e mod m**.\n\n @param[out] r     Buffer for the result.\n\n @param[in]  a     Pointer to an integer.\n\n @param[in]  e     Pointer to the exponent.\n\n @param[in]  len_e Number of bytes of the exponent.\n\n @param[in]  m     Modulus\n\n @param[in]  len   Number of bytes of the result.\n\n @return           Error code:\n                   - CX_OK on success\n                   - CX_NOT_UNLOCKED\n                   - CX_INVALID_PARAMETER_SIZE\n                   - CX_NOT_LOCKED\n                   - CX_MEMORY_FULL\n                   - CX_INVALID_PARAMETER"]
    pub fn cx_math_powm_no_throw(
        r: *mut u8,
        a: *const u8,
        e: *const u8,
        len_e: usize,
        m: *const u8,
        len: usize,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Modular inverse with a prime modulus.\n\n @details Compute the result of **a^(-1) mod m**, for a prime *m*.\n\n @param[out] r   Buffer for the result.\n\n @param[in]  a   Pointer to the integer.\n\n @param[in]  m   Modulus. Must be a prime number.\n\n @param[in]  len Number of bytes of the result.\n\n @return         Error code:\n                 - CX_OK on success\n                 - CX_NOT_UNLOCKED\n                 - CX_INVALID_PARAMETER_SIZE\n                 - CX_NOT_LOCKED\n                 - CX_MEMORY_FULL\n                 - CX_INVALID_PARAMETER"]
    pub fn cx_math_invprimem_no_throw(
        r: *mut u8,
        a: *const u8,
        m: *const u8,
        len: usize,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Modular inverse.\n\n @details Compute the result of **a^(-1) mod m**. *a* must be invertible modulo *m*,\n          i.e. the greatest common divisor of *a* and *n* is 1.\n\n @param[out] r   Buffer for the result.\n\n @param[in]  a   Pointer to the integer.\n\n @param[in]  m   Modulus.\n\n @param[in]  len Number of bytes of the result.\n\n @return         Error code:\n                 - CX_OK on success\n                 - CX_NOT_UNLOCKED\n                 - CX_INVALID_PARAMETER_SIZE\n                 - CX_NOT_LOCKED\n                 - CX_MEMORY_FULL\n                 - CX_INVALID_PARAMETER"]
    pub fn cx_math_invintm_no_throw(r: *mut u8, a: u32, m: *const u8, len: usize) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief Check whether a number is probable prime.\n\n @param[in]  r     Pointer to an integer.\n\n @param[in]  len   Number of bytes of the integer.\n\n @param[out] prime Bool indicating whether r is prime or not:\n                   - 0 : not prime\n                   - 1 : prime\n\n @return           Error code:\n                   - CX_OK on success\n                   - CX_NOT_UNLOCKED\n                   - CX_INVALID_PARAMETER_SIZE\n                   - CX_NOT_LOCKED\n                   - CX_MEMORY_FULL\n                   - CX_INVALID_PARAMETER"]
    pub fn cx_math_is_prime_no_throw(r: *const u8, len: usize, prime: *mut bool) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief Compute the next prime after a given number.\n\n @param[in] r   Pointer to the integer and buffer for the result.\n\n @param[in] len Number of bytes of the integer.\n\n @return        Error code:\n                - CX_OK on success\n                - CX_NOT_UNLOCKED\n                - CX_INVALID_PARAMETER_SIZE\n                - CX_MEMORY_FULL\n                - CX_NOT_LOCKED\n                - CX_INVALID_PARAMETER\n                - CX_INTERNAL_ERROR\n                - CX_OVERFLOW"]
    pub fn cx_math_next_prime_no_throw(r: *mut u8, len: u32) -> cx_err_t;
}
#[doc = " Elliptic Curve public key"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_public_key_s {
    #[doc = "< Curve identifier"]
    pub curve: cx_curve_t,
    #[doc = "< Public key length in bytes"]
    pub W_len: usize,
    #[doc = "< Public key value starting at offset 0"]
    pub W: [u8; 1usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_public_key_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_ecfp_public_key_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_public_key_s>(),
        12usize,
        concat!("Size of: ", stringify!(cx_ecfp_public_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_public_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_public_key_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_public_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).W_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_public_key_s),
            "::",
            stringify!(W_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).W) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_public_key_s),
            "::",
            stringify!(W)
        )
    );
}
impl Default for cx_ecfp_public_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Elliptic Curve private key"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_private_key_s {
    #[doc = "< Curve identifier"]
    pub curve: cx_curve_t,
    #[doc = "< Private key length in bytes"]
    pub d_len: usize,
    #[doc = "< Private key value starting at offset 0"]
    pub d: [u8; 1usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_private_key_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_ecfp_private_key_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_private_key_s>(),
        12usize,
        concat!("Size of: ", stringify!(cx_ecfp_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_private_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_private_key_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_private_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_private_key_s),
            "::",
            stringify!(d_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_private_key_s),
            "::",
            stringify!(d)
        )
    );
}
impl Default for cx_ecfp_private_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Up to 256-bit Elliptic Curve public key"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_256_public_key_s {
    #[doc = "< Curve identifier"]
    pub curve: cx_curve_t,
    #[doc = "< Public key length in bytes"]
    pub W_len: usize,
    #[doc = "< Public key value starting at offset 0"]
    pub W: [u8; 65usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_256_public_key_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_ecfp_256_public_key_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_256_public_key_s>(),
        76usize,
        concat!("Size of: ", stringify!(cx_ecfp_256_public_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_256_public_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_256_public_key_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_public_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).W_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_public_key_s),
            "::",
            stringify!(W_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).W) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_public_key_s),
            "::",
            stringify!(W)
        )
    );
}
impl Default for cx_ecfp_256_public_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Up to 256-bit Elliptic Curve private key"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_256_private_key_s {
    #[doc = "< Curve identifier"]
    pub curve: cx_curve_t,
    #[doc = "< Private key length in bytes"]
    pub d_len: usize,
    #[doc = "< Private key value starting at offset 0"]
    pub d: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_256_private_key_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_ecfp_256_private_key_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_256_private_key_s>(),
        40usize,
        concat!("Size of: ", stringify!(cx_ecfp_256_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_256_private_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_256_private_key_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_private_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_private_key_s),
            "::",
            stringify!(d_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_private_key_s),
            "::",
            stringify!(d)
        )
    );
}
impl Default for cx_ecfp_256_private_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Up to 256-bit Elliptic Curve extended private key"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_256_extended_private_key_s {
    #[doc = "< Curve identifier"]
    pub curve: cx_curve_t,
    #[doc = "< Public key length in bytes"]
    pub d_len: usize,
    #[doc = "< Public key value starting at offset 0"]
    pub d: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_256_extended_private_key_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_ecfp_256_extended_private_key_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_256_extended_private_key_s>(),
        72usize,
        concat!("Size of: ", stringify!(cx_ecfp_256_extended_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_256_extended_private_key_s>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cx_ecfp_256_extended_private_key_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_extended_private_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_extended_private_key_s),
            "::",
            stringify!(d_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_256_extended_private_key_s),
            "::",
            stringify!(d)
        )
    );
}
impl Default for cx_ecfp_256_extended_private_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Up to 256-bit Elliptic Curve public key"]
pub type cx_ecfp_256_public_key_t = cx_ecfp_256_public_key_s;
#[doc = " Up to 256-bit Elliptic Curve private key"]
pub type cx_ecfp_256_private_key_t = cx_ecfp_256_private_key_s;
#[doc = " Up to 256-bit Elliptic Curve extended private key"]
pub type cx_ecfp_256_extended_private_key_t = cx_ecfp_256_extended_private_key_s;
#[doc = " Up to 256-bit Elliptic Curve public key"]
pub type cx_ecfp_public_key_t = cx_ecfp_256_public_key_s;
#[doc = " Up to 256-bit Elliptic Curve private key"]
pub type cx_ecfp_private_key_t = cx_ecfp_256_private_key_s;
#[doc = " Up to 384-bit Elliptic Curve public key"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_384_public_key_s {
    #[doc = "< Curve identifier"]
    pub curve: cx_curve_t,
    #[doc = "< Public key length in bytes"]
    pub W_len: usize,
    #[doc = "< Public key value starting at offset 0"]
    pub W: [u8; 97usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_384_public_key_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_ecfp_384_public_key_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_384_public_key_s>(),
        108usize,
        concat!("Size of: ", stringify!(cx_ecfp_384_public_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_384_public_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_384_public_key_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_384_public_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).W_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_384_public_key_s),
            "::",
            stringify!(W_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).W) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_384_public_key_s),
            "::",
            stringify!(W)
        )
    );
}
impl Default for cx_ecfp_384_public_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Up to 384-bit Elliptic Curve private key"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_384_private_key_s {
    #[doc = "< Curve identifier"]
    pub curve: cx_curve_t,
    #[doc = "< Private key length in bytes"]
    pub d_len: usize,
    #[doc = "< Private key value starting at offset 0"]
    pub d: [u8; 48usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_384_private_key_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_ecfp_384_private_key_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_384_private_key_s>(),
        56usize,
        concat!("Size of: ", stringify!(cx_ecfp_384_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_384_private_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_384_private_key_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_384_private_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_384_private_key_s),
            "::",
            stringify!(d_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_384_private_key_s),
            "::",
            stringify!(d)
        )
    );
}
impl Default for cx_ecfp_384_private_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Up to 384-bit Elliptic Curve private key"]
pub type cx_ecfp_384_private_key_t = cx_ecfp_384_private_key_s;
#[doc = " Up to 384-bit Elliptic Curve public key"]
pub type cx_ecfp_384_public_key_t = cx_ecfp_384_public_key_s;
#[doc = " Up to 512-bit Elliptic Curve public key"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_512_public_key_s {
    #[doc = "< Curve identifier"]
    pub curve: cx_curve_t,
    #[doc = "< Public key length in bytes"]
    pub W_len: usize,
    #[doc = "< Public key value starting at offset 0"]
    pub W: [u8; 129usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_512_public_key_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_ecfp_512_public_key_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_512_public_key_s>(),
        140usize,
        concat!("Size of: ", stringify!(cx_ecfp_512_public_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_512_public_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_512_public_key_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_public_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).W_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_public_key_s),
            "::",
            stringify!(W_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).W) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_public_key_s),
            "::",
            stringify!(W)
        )
    );
}
impl Default for cx_ecfp_512_public_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Up to 512-bit Elliptic Curve private key"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_512_private_key_s {
    #[doc = "< Curve identifier"]
    pub curve: cx_curve_t,
    #[doc = "< Private key length in bytes"]
    pub d_len: usize,
    #[doc = "< Private key value starting at offset 0"]
    pub d: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_512_private_key_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_ecfp_512_private_key_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_512_private_key_s>(),
        72usize,
        concat!("Size of: ", stringify!(cx_ecfp_512_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_512_private_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_512_private_key_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_private_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_private_key_s),
            "::",
            stringify!(d_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_private_key_s),
            "::",
            stringify!(d)
        )
    );
}
impl Default for cx_ecfp_512_private_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Up to 512-bit Elliptic Curve extended private key"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_512_extented_private_key_s {
    #[doc = "< Curve identifier"]
    pub curve: cx_curve_t,
    #[doc = "< Private key length in bytes"]
    pub d_len: usize,
    #[doc = "< Private key value starting at offset 0"]
    pub d: [u8; 128usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_512_extented_private_key_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_ecfp_512_extented_private_key_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_512_extented_private_key_s>(),
        136usize,
        concat!("Size of: ", stringify!(cx_ecfp_512_extented_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_512_extented_private_key_s>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(cx_ecfp_512_extented_private_key_s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_extented_private_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_extented_private_key_s),
            "::",
            stringify!(d_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_512_extented_private_key_s),
            "::",
            stringify!(d)
        )
    );
}
impl Default for cx_ecfp_512_extented_private_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Up to 512-bit Elliptic Curve public key"]
pub type cx_ecfp_512_public_key_t = cx_ecfp_512_public_key_s;
#[doc = " Up to 512-bit Elliptic Curve private key"]
pub type cx_ecfp_512_private_key_t = cx_ecfp_512_private_key_s;
#[doc = " Up to 512-bit Elliptic Curve extended private key"]
pub type cx_ecfp_512_extented_private_key_t = cx_ecfp_512_extented_private_key_s;
#[doc = " Up to 640-bit Elliptic Curve public key"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_640_public_key_s {
    #[doc = "< Curve identifier"]
    pub curve: cx_curve_t,
    #[doc = "< Public key length in bytes"]
    pub W_len: usize,
    #[doc = "< Public key value starting at offset 0"]
    pub W: [u8; 161usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_640_public_key_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_ecfp_640_public_key_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_640_public_key_s>(),
        172usize,
        concat!("Size of: ", stringify!(cx_ecfp_640_public_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_640_public_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_640_public_key_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_640_public_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).W_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_640_public_key_s),
            "::",
            stringify!(W_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).W) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_640_public_key_s),
            "::",
            stringify!(W)
        )
    );
}
impl Default for cx_ecfp_640_public_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Up to 640-bit Elliptic Curve private key"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cx_ecfp_640_private_key_s {
    #[doc = "< Curve identifier"]
    pub curve: cx_curve_t,
    #[doc = "< Private key length in bytes"]
    pub d_len: usize,
    #[doc = "< Private key value starting at offset 0"]
    pub d: [u8; 80usize],
}
#[test]
fn bindgen_test_layout_cx_ecfp_640_private_key_s() {
    const UNINIT: ::core::mem::MaybeUninit<cx_ecfp_640_private_key_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<cx_ecfp_640_private_key_s>(),
        88usize,
        concat!("Size of: ", stringify!(cx_ecfp_640_private_key_s))
    );
    assert_eq!(
        ::core::mem::align_of::<cx_ecfp_640_private_key_s>(),
        4usize,
        concat!("Alignment of ", stringify!(cx_ecfp_640_private_key_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).curve) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_640_private_key_s),
            "::",
            stringify!(curve)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d_len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_640_private_key_s),
            "::",
            stringify!(d_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cx_ecfp_640_private_key_s),
            "::",
            stringify!(d)
        )
    );
}
impl Default for cx_ecfp_640_private_key_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Up to 640-bit Elliptic Curve public key"]
pub type cx_ecfp_640_public_key_t = cx_ecfp_640_public_key_s;
#[doc = " Up to 640-bit Elliptic Curve private key"]
pub type cx_ecfp_640_private_key_t = cx_ecfp_640_private_key_s;
extern "C" {
    #[doc = " @brief   Add two points of an elliptic curve.\n\n @param[in]  curve Curve identifier.\n\n @param[out] R     Resulting point encoded as **04 || x || y**.\n\n @param[in]  P     First operand: point on curve encoded as **04 || x || y**:\n                   *x* and *y* are encoded as big endian raw values\n                   and have a binary length equal to curve domain size.\n\n @param[in]  Q     Second operand: point on curve encoded as **04 || x || y**.\n\n @return           Error code:\n                   - CX_OK on success\n                   - CX_EC_INVALID_CURVE\n                   - CX_NOT_UNLOCKED\n                   - CX_INVALID_PARAMETER_SIZE\n                   - CX_EC_INVALID_CURVE\n                   - CX_MEMORY_FULL\n                   - CX_NOT_LOCKED\n                   - CX_INVALID_PARAMETER\n                   - CX_EC_INVALID_POINT\n                   - CX_EC_INFINITE_POINT"]
    pub fn cx_ecfp_add_point_no_throw(
        curve: cx_curve_t,
        R: *mut u8,
        P: *const u8,
        Q: *const u8,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Perform a scalar multiplication over an elliptic curve.\n\n @param[in]      curve Curve identifier.\n\n @param[in, out] P     Point on curve encoded as **04 || x || y**:\n                       x and y are encoded as big endian raw values\n                       and have a binary length equal to curve domain size.\n                       This is also used for the result.\n\n @param[in]      k     Scalar encoded as big endian integer.\n\n @param[in]      k_len Length of the scalar. This should be equal to\n                       the curve domain length.\n\n @return               Error code:\n                       - CX_OK on success\n                       - CX_EC_INVALID_CURVE\n                       - CX_NOT_UNLOCKED\n                       - CX_EC_INVALID_CURVE\n                       - CX_MEMORY_FULL\n                       - CX_NOT_LOCKED\n                       - CX_INVALID_PARAMETER\n                       - CX_EC_INFINITE_POINT"]
    pub fn cx_ecfp_scalar_mult_no_throw(
        curve: cx_curve_t,
        P: *mut u8,
        k: *const u8,
        k_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Initialize a public key.\n\n @param[in]  curve   Curve identifier.\n\n @param[in]  rawkey  Pointer to a raw key value or NULL pointer\n                     The value shall be the public point encoded as:\n                      - **04 || x || y** for Weiertrass curves\n                      - **04 || x || y**  or **02 || y** (plus sign) for Twisted Edward curves\n                      - **04 || x || y**  or **02 || x** for Montgomery curves\n\n                     where *x* and *y* are encoded as big endian raw values and have a\n                     binary length equal to the curve domain size.\n\n @param[in]  key_len Length of the key.\n\n @param[out] key     Public key to initialize.\n\n @return             Error code:\n                     - CX_OK on success\n                     - CX_EC_INVALID_CURVE\n                     - INVALID_PARAMETER"]
    pub fn cx_ecfp_init_public_key_no_throw(
        curve: cx_curve_t,
        rawkey: *const u8,
        key_len: usize,
        key: *mut cx_ecfp_public_key_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Initialize a private key.\n\n @details The key can be stored in non-volatile memory and\n          used for ECDSA or ECDH processing.\n\n @param[in]  curve   Curve identifier.\n\n @param[in]  rawkey  Pointer to a raw key value or NULL pointer.\n                     The value shall be in big endian order.\n\n @param[in]  key_len Length of the key.\n\n @param[out] pvkey   Private key to initialize.\n\n @return             Error code:\n                     - CX_OK on success\n                     - CX_EC_INVALID_CURVE\n                     - CX_INVALID_PARAMETER"]
    pub fn cx_ecfp_init_private_key_no_throw(
        curve: cx_curve_t,
        rawkey: *const u8,
        key_len: usize,
        pvkey: *mut cx_ecfp_private_key_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Generate a key pair with SHA-512 hash function.\n\n @param[in]  curve       Curve identifier.\n\n @param[out] pubkey      Generated public key.\n\n @param[out] privkey     Generated private key.\n\n @param[in]  keepprivate If set, the private key is the one initialized\n                         with #cx_ecfp_init_private_key_no_throw. Otherwise,\n                         a new private key is generated.\n\n @return                 Error code:\n                         - CX_OK on success\n                         - CX_EC_INVALID_CURVE\n                         - CX_NOT_UNLOCKED\n                         - CX_INVALID_PARAMETER_SIZE\n                         - CX_MEMORY_FULL\n                         - CX_NOT_LOCKED\n                         - CX_INVALID_PARAMETER\n                         - CX_INTERNAL_ERROR\n                         - CX_EC_INVALID_POINT\n                         - CX_EC_INFINITE_POINT"]
    pub fn cx_ecfp_generate_pair_no_throw(
        curve: cx_curve_t,
        pubkey: *mut cx_ecfp_public_key_t,
        privkey: *mut cx_ecfp_private_key_t,
        keepprivate: bool,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Generate a key pair.\n\n @param[in]  curve       Curve identifier.\n\n @param[out] pubkey      Generated public key.\n\n @param[out] privkey     Generated private key.\n\n @param[in]  keepprivate If set, the private key is the one initialized with\n                         #cx_ecfp_init_private_key_no_throw.\n                         Otherwise, a new private key is generated.\n\n @param[in]  hashID      Message digest algorithm identifer.\n\n @return                 Error code:\n                         - CX_OK on success\n                         - CX_EC_INVALID_CURVE\n                         - CX_NOT_UNLOCKED\n                         - CX_INVALID_PARAMETER_SIZE\n                         - CX_MEMORY_FULL\n                         - CX_NOT_LOCKED\n                         - CX_INVALID_PARAMETER\n                         - CX_INTERNAL_ERROR\n                         - CX_EC_INVALID_POINT\n                         - CX_EC_INFINITE_POINT"]
    pub fn cx_ecfp_generate_pair2_no_throw(
        curve: cx_curve_t,
        pubkey: *mut cx_ecfp_public_key_t,
        privkey: *mut cx_ecfp_private_key_t,
        keepprivate: bool,
        hashID: cx_md_t,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Retrieve an EDDSA public key.\n\n @details Retrieve (a,h) = (Kr, Kl), such that (Kr, Kl) = Hash(pv_key)\n          as specified in <a href=\"https://tools.ietf.org/html/rfc8032\"> RFC8032 </a>.\n\n @param[in]  pvkey  A private key fully initialized with #cx_ecfp_init_private_key_no_throw.\n\n @param[in]  hashID Message digest algorithm identifier used to compute the input data.\n                    SHA512, SHA3 and Keccak are supported.\n\n @param[out] pukey  Key container for retrieving the public key A.\n\n @param[out] a      Private scalar such that A = a.B.\n\n @param[in]  a_len  Length of the scalar a.\n\n @param[out] h      Signature prefix.\n\n @param[in]  h_len  Length of the prefix h.\n\n @return            Error code:\n                    - CX_OK on success\n                    - CX_EC_INVALID_CURVE\n                    - CX_NOT_UNLOCKED\n                    - CX_INVALID_PARAMETER_SIZE\n                    - CX_INVALID_PARAMETER\n                    - CX_NOT_LOCKED\n                    - CX_MEMORY_FULL\n                    - CX_EC_INVALID_POINT\n                    - CX_EC_INFINITE_POINT\n                    - CX_INTERNAL_ERROR\n"]
    pub fn cx_eddsa_get_public_key_no_throw(
        pvkey: *const cx_ecfp_private_key_t,
        hashID: cx_md_t,
        pukey: *mut cx_ecfp_public_key_t,
        a: *mut u8,
        a_len: usize,
        h: *mut u8,
        h_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Compress a point according to <a href=\"https://tools.ietf.org/html/rfc8032\"> RFC8032 </a>.\n\n @param[in]      curve Curve identifier. The curve must be\n                       a Twisted Edwards curve.\n\n @param[in, out] p     Pointer to the point to compress.\n\n @param[in]      p_len Length of the point buffer.\n\n @return               Error code:\n                       - CX_OK on success\n                       - CX_EC_INVALID_CURVE\n                       - CX_NOT_UNLOCKED\n                       - CX_INVALID_PARAMETER_SIZE\n                       - CX_EC_INVALID_CURVE\n                       - CX_MEMORY_FULL\n                       - CX_NOT_LOCKED\n                       - CX_INVALID_PARAMETER\n                       - CX_EC_INFINITE_POINT"]
    pub fn cx_edwards_compress_point_no_throw(
        curve: cx_curve_t,
        p: *mut u8,
        p_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Decompress a point according to <a href=\"https://tools.ietf.org/html/rfc8032\"> RFC8032 </a>.\n\n @param[in]      curve Curve identifier. The curve must be\n                       a Twisted Edwards curve.\n\n @param[in, out] p     Pointer to the point to decompress.\n\n @param[in]      p_len Length of the point buffer.\n\n @return               Error code:\n                       - CX_OK on success\n                       - CX_EC_INVALID_CURVE\n                       - CX_NOT_UNLOCKED\n                       - CX_INVALID_PARAMETER_SIZE\n                       - CX_EC_INVALID_CURVE\n                       - CX_MEMORY_FULL\n                       - CX_NOT_LOCKED\n                       - CX_INVALID_PARAMETER\n                       - CX_EC_INFINITE_POINT\n                       - CX_NO_RESIDUE\n                       - INVALID_PARAMETER"]
    pub fn cx_edwards_decompress_point_no_throw(
        curve: cx_curve_t,
        p: *mut u8,
        p_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Sign a message digest according to ECDSA specification\n\n @param[in]  pvkey    Private key.\n                      Shall be initialized with #cx_ecfp_init_private_key_no_throw.\n\n @param[in]  mode     Crypto mode flags.\n                      Supported flags:\n                        - CX_RND_TRNG\n                        - CX_RND_RFC6979\n\n @param[in]  hashID   Message digest algorithm identifer.\n                      This parameter is mandatory with the flag CX_RND_RFC6979.\n\n @param[in]  hash     Digest of the message to be signed.\n                      The length of *hash* must be shorter than the curve domain size.\n\n @param[in]  hash_len Length of the digest in octets.\n\n @param[out] sig      Buffer where to store the signature.\n                      The signature is encoded in TLV:  **30 || L || 02 || Lr || r || 02 || Ls || s**\n\n @param[in]  sig_len  Length of the buffer in octets.\n\n @param[out] info     Set with CX_ECCINFO_PARITY_ODD if the y-coordinate is odd when computing **[k].G**.\n\n @return              Error code:\n                      - CX_OK on success\n                      - CX_EC_INVALID_CURVE\n                      - CX_INVALID_PARAMETER\n                      - CX_INTERNAL_ERROR\n                      - CX_NOT_UNLOCKED\n                      - CX_INVALID_PARAMETER_SIZE\n                      - CX_MEMORY_FULL\n                      - CX_NOT_LOCKED\n                      - CX_EC_INVALID_POINT\n                      - CX_EC_INFINITE_POINT\n                      - CX_INVALID_PARAMETER_VALUE"]
    pub fn cx_ecdsa_sign_no_throw(
        pvkey: *const cx_ecfp_private_key_t,
        mode: u32,
        hashID: cx_md_t,
        hash: *const u8,
        hash_len: usize,
        sig: *mut u8,
        sig_len: *mut usize,
        info: *mut u32,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Verify an ECDSA signature according to ECDSA specification.\n\n @param[in] pukey    Private key initialized with #cx_ecfp_init_public_key_no_throw.\n\n @param[in] hash     Digest of the message to be verified.\n                     The length of *hash* must be smaller than the group order size.\n                     Otherwise it is truncated.\n\n @param[in] hash_len Length of the digest in octets.\n\n @param[in] sig      Pointer to the signature encoded in TLV: **30 || L || 02 || Lr || r || 02 || Ls || s**\n\n @param[in] sig_len  Length of the signature in octets.\n\n @return             1 if the signature is verified, 0 otherwise."]
    pub fn cx_ecdsa_verify_no_throw(
        pukey: *const cx_ecfp_public_key_t,
        hash: *const u8,
        hash_len: usize,
        sig: *const u8,
        sig_len: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief   Sign a message digest.\n\n @details Sign a message digest according to the EDDSA specification\n          <a href=\"https://tools.ietf.org/html/rfc8032\"> RFC8032 </a>.\n\n @param[in]  pvkey    Private key.\n                      This shall be initialized with #cx_ecfp_init_private_key_no_throw.\n\n @param[in]  hashID   Message digest agorithm identifier.\n                      Algorithms supported:\n                        - SHA512\n                        - SHA3\n                        - Keccak\n\n @param[in]  hash     Pointer to the message digest.\n\n @param[in]  hash_len Length of the digest.\n\n @param[out] sig      Buffer where to store the signature.\n\n @param[in]  sig_len  Length of the signature.\n\n @return              Error code:\n                      - CX_OK on success\n                      - CX_EC_INVALID_CURVE\n                      - CX_INVALID_PARAMETER\n                      - INVALID_PARAMETER\n                      - CX_NOT_UNLOCKED\n                      - CX_INVALID_PARAMETER_SIZE\n                      - CX_MEMORY_FULL\n                      - CX_NOT_LOCKED\n                      - CX_INVALID_PARAMETER_SIZE\n                      - CX_EC_INVALID_POINT\n                      - CX_EC_INFINITE_POINT\n                      - CX_INTERNAL_ERROR\n                      - CX_INVALID_PARAMETER_VALUE"]
    pub fn cx_eddsa_sign_no_throw(
        pvkey: *const cx_ecfp_private_key_t,
        hashID: cx_md_t,
        hash: *const u8,
        hash_len: usize,
        sig: *mut u8,
        sig_len: usize,
    ) -> cx_err_t;
}
extern "C" {
    #[doc = " @brief   Verify a signature.\n\n @details Verify a signature according to the specification\n          <a href=\"https://tools.ietf.org/html/rfc8032\"> RFC8032 </a>.\n\n @param[in]  pukey    Public key.\n                      This shall be initialized with #cx_ecfp_init_public_key_no_throw.\n\n @param[in]  hashID   Message digest agorithm identifier.\n                      Algorithms supported:\n                        - SHA512\n                        - SHA3\n                        - Keccak\n\n @param[in]  hash     Pointer to the message digest.\n\n @param[in]  hash_len Length of the digest.\n\n @param[out] sig      Pointer to the signature.\n\n @param[in]  sig_len  Length of the signature.\n\n @return              1 if the signature is verified, otherwise 0."]
    pub fn cx_eddsa_verify_no_throw(
        pukey: *const cx_ecfp_public_key_t,
        hashID: cx_md_t,
        hash: *const u8,
        hash_len: usize,
        sig: *const u8,
        sig_len: usize,
    ) -> bool;
}
extern "C" {
    #[doc = " @brief   Encode the curve point coordinates.\n\n @param[in] coord A pointer to the point coordinates in the form x|y.\n\n @param[in] len   Length of the coordinates.\n\n @param[in] sign  Sign of the x-coordinate.\n"]
    pub fn cx_encode_coord(coord: *mut u8, len: cty::c_int, sign: cty::c_int);
}
extern "C" {
    #[doc = " @brief   Decode the curve point coordinates.\n\n @param[in] coord A pointer to the point encoded coordinates.\n\n @param[in] len   Length of the encoded coordinates.\n\n @return Sign of the x-coordinate."]
    pub fn cx_decode_coord(coord: *mut u8, len: cty::c_int) -> cty::c_int;
}
pub const bagl_components_type_e__BAGL_NONE: bagl_components_type_e_ = 0;
pub const bagl_components_type_e__BAGL_BUTTON: bagl_components_type_e_ = 1;
pub const bagl_components_type_e__BAGL_LABEL: bagl_components_type_e_ = 2;
pub const bagl_components_type_e__BAGL_RECTANGLE: bagl_components_type_e_ = 3;
pub const bagl_components_type_e__BAGL_LINE: bagl_components_type_e_ = 4;
pub const bagl_components_type_e__BAGL_ICON: bagl_components_type_e_ = 5;
pub const bagl_components_type_e__BAGL_CIRCLE: bagl_components_type_e_ = 6;
pub const bagl_components_type_e__BAGL_LABELINE: bagl_components_type_e_ = 7;
pub const bagl_components_type_e__BAGL_FLAG_TOUCHABLE: bagl_components_type_e_ = 128;
pub type bagl_components_type_e_ = cty::c_uint;
pub use self::bagl_components_type_e_ as bagl_components_type_e;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bagl_component_t {
    pub type_: bagl_components_type_e,
    pub userid: cty::c_uchar,
    pub x: cty::c_short,
    pub y: cty::c_short,
    pub width: cty::c_ushort,
    pub height: cty::c_ushort,
    pub stroke: cty::c_uchar,
    pub radius: cty::c_uchar,
    pub fill: cty::c_uchar,
    pub fgcolor: cty::c_uint,
    pub bgcolor: cty::c_uint,
    pub font_id: cty::c_ushort,
    pub icon_id: cty::c_uchar,
}
#[test]
fn bindgen_test_layout_bagl_component_t() {
    const UNINIT: ::core::mem::MaybeUninit<bagl_component_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bagl_component_t>(),
        32usize,
        concat!("Size of: ", stringify!(bagl_component_t))
    );
    assert_eq!(
        ::core::mem::align_of::<bagl_component_t>(),
        4usize,
        concat!("Alignment of ", stringify!(bagl_component_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_component_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).userid) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_component_t),
            "::",
            stringify!(userid)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_component_t),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_component_t),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_component_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_component_t),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stroke) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_component_t),
            "::",
            stringify!(stroke)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).radius) as usize - ptr as usize },
        15usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_component_t),
            "::",
            stringify!(radius)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fill) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_component_t),
            "::",
            stringify!(fill)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fgcolor) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_component_t),
            "::",
            stringify!(fgcolor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bgcolor) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_component_t),
            "::",
            stringify!(bgcolor)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).font_id) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_component_t),
            "::",
            stringify!(font_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).icon_id) as usize - ptr as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_component_t),
            "::",
            stringify!(icon_id)
        )
    );
}
impl Default for bagl_component_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " helper structure to help handling icons"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bagl_icon_details_s {
    pub width: cty::c_uint,
    pub height: cty::c_uint,
    pub bpp: cty::c_uint,
    pub colors: *const cty::c_uint,
    pub bitmap: *const cty::c_uchar,
}
#[test]
fn bindgen_test_layout_bagl_icon_details_s() {
    const UNINIT: ::core::mem::MaybeUninit<bagl_icon_details_s> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bagl_icon_details_s>(),
        20usize,
        concat!("Size of: ", stringify!(bagl_icon_details_s))
    );
    assert_eq!(
        ::core::mem::align_of::<bagl_icon_details_s>(),
        4usize,
        concat!("Alignment of ", stringify!(bagl_icon_details_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_icon_details_s),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_icon_details_s),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bpp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_icon_details_s),
            "::",
            stringify!(bpp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).colors) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_icon_details_s),
            "::",
            stringify!(colors)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitmap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_icon_details_s),
            "::",
            stringify!(bitmap)
        )
    );
}
impl Default for bagl_icon_details_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " helper structure to help handling icons"]
pub type bagl_icon_details_t = bagl_icon_details_s;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bagl_font_character_t {
    pub char_width: cty::c_uchar,
    pub bitmap_byte_count: cty::c_uchar,
    pub bitmap_offset: cty::c_ushort,
}
#[test]
fn bindgen_test_layout_bagl_font_character_t() {
    const UNINIT: ::core::mem::MaybeUninit<bagl_font_character_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bagl_font_character_t>(),
        4usize,
        concat!("Size of: ", stringify!(bagl_font_character_t))
    );
    assert_eq!(
        ::core::mem::align_of::<bagl_font_character_t>(),
        2usize,
        concat!("Alignment of ", stringify!(bagl_font_character_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).char_width) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_font_character_t),
            "::",
            stringify!(char_width)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitmap_byte_count) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_font_character_t),
            "::",
            stringify!(bitmap_byte_count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitmap_offset) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_font_character_t),
            "::",
            stringify!(bitmap_offset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bagl_font_t {
    pub font_id: cty::c_uint,
    pub bpp: cty::c_uchar,
    pub char_height: cty::c_uchar,
    pub baseline_height: cty::c_uchar,
    pub char_kerning: cty::c_uchar,
    pub first_char: cty::c_ushort,
    pub last_char: cty::c_ushort,
    pub characters: *const bagl_font_character_t,
    pub bitmap: *const cty::c_uchar,
}
#[test]
fn bindgen_test_layout_bagl_font_t() {
    const UNINIT: ::core::mem::MaybeUninit<bagl_font_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bagl_font_t>(),
        20usize,
        concat!("Size of: ", stringify!(bagl_font_t))
    );
    assert_eq!(
        ::core::mem::align_of::<bagl_font_t>(),
        4usize,
        concat!("Alignment of ", stringify!(bagl_font_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).font_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_font_t),
            "::",
            stringify!(font_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bpp) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_font_t),
            "::",
            stringify!(bpp)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).char_height) as usize - ptr as usize },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_font_t),
            "::",
            stringify!(char_height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).baseline_height) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_font_t),
            "::",
            stringify!(baseline_height)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).char_kerning) as usize - ptr as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_font_t),
            "::",
            stringify!(char_kerning)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).first_char) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_font_t),
            "::",
            stringify!(first_char)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).last_char) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_font_t),
            "::",
            stringify!(last_char)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).characters) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_font_t),
            "::",
            stringify!(characters)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).bitmap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_font_t),
            "::",
            stringify!(bitmap)
        )
    );
}
impl Default for bagl_font_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static C_bagl_fonts: [*const bagl_font_t; 0usize];
}
extern "C" {
    pub static C_bagl_fonts_count: cty::c_uint;
}
pub const bagl_font_id_e_BAGL_FONT_LUCIDA_CONSOLE_8PX: bagl_font_id_e = 0;
pub const bagl_font_id_e_BAGL_FONT_OPEN_SANS_LIGHT_16_22PX: bagl_font_id_e = 1;
pub const bagl_font_id_e_BAGL_FONT_OPEN_SANS_REGULAR_8_11PX: bagl_font_id_e = 2;
pub const bagl_font_id_e_BAGL_FONT_OPEN_SANS_REGULAR_10_13PX: bagl_font_id_e = 3;
pub const bagl_font_id_e_BAGL_FONT_OPEN_SANS_REGULAR_11_14PX: bagl_font_id_e = 4;
pub const bagl_font_id_e_BAGL_FONT_OPEN_SANS_REGULAR_13_18PX: bagl_font_id_e = 5;
pub const bagl_font_id_e_BAGL_FONT_OPEN_SANS_REGULAR_22_30PX: bagl_font_id_e = 6;
pub const bagl_font_id_e_BAGL_FONT_OPEN_SANS_SEMIBOLD_8_11PX: bagl_font_id_e = 7;
pub const bagl_font_id_e_BAGL_FONT_OPEN_SANS_EXTRABOLD_11px: bagl_font_id_e = 8;
pub const bagl_font_id_e_BAGL_FONT_OPEN_SANS_LIGHT_16px: bagl_font_id_e = 9;
pub const bagl_font_id_e_BAGL_FONT_OPEN_SANS_REGULAR_11px: bagl_font_id_e = 10;
pub const bagl_font_id_e_BAGL_FONT_OPEN_SANS_SEMIBOLD_10_13PX: bagl_font_id_e = 11;
pub const bagl_font_id_e_BAGL_FONT_OPEN_SANS_SEMIBOLD_11_16PX: bagl_font_id_e = 12;
pub const bagl_font_id_e_BAGL_FONT_OPEN_SANS_SEMIBOLD_13_18PX: bagl_font_id_e = 13;
pub const bagl_font_id_e_BAGL_FONT_SYMBOLS_0: bagl_font_id_e = 14;
pub const bagl_font_id_e_BAGL_FONT_SYMBOLS_1: bagl_font_id_e = 15;
pub const bagl_font_id_e_BAGL_FONT_LAST: bagl_font_id_e = 16;
pub type bagl_font_id_e = cty::c_uint;
pub const bagl_glyph_e_BAGL_GLYPH_NOGLYPH: bagl_glyph_e = 0;
pub const bagl_glyph_e_BAGL_GLYPH_LOGO_LEDGER_100: bagl_glyph_e = 1;
pub const bagl_glyph_e_BAGL_GLYPH_LOGO_LEDGER_BLUE_120: bagl_glyph_e = 2;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_GEARS_50: bagl_glyph_e = 3;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_CLEAR_16: bagl_glyph_e = 4;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_BACKSPACE_20: bagl_glyph_e = 5;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_CHECK: bagl_glyph_e = 6;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_CROSS: bagl_glyph_e = 7;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_CHECK_BADGE: bagl_glyph_e = 8;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_LEFT: bagl_glyph_e = 9;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_RIGHT: bagl_glyph_e = 10;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_UP: bagl_glyph_e = 11;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_DOWN: bagl_glyph_e = 12;
pub const bagl_glyph_e_BAGL_GLYPH_LOGO_LEDGER_MINI: bagl_glyph_e = 13;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_CROSS_BADGE: bagl_glyph_e = 14;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_DASHBOARD_BADGE: bagl_glyph_e = 15;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_PLUS: bagl_glyph_e = 16;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_LESS: bagl_glyph_e = 17;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_TOGGLE_ON: bagl_glyph_e = 18;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_TOGGLE_OFF: bagl_glyph_e = 19;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_LOADING_BADGE: bagl_glyph_e = 20;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_COG_BADGE: bagl_glyph_e = 21;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_WARNING_BADGE: bagl_glyph_e = 22;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_DOWNLOAD_BADGE: bagl_glyph_e = 23;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_TRANSACTION_BADGE: bagl_glyph_e = 24;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_BITCOIN_BADGE: bagl_glyph_e = 25;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_ETHEREUM_BADGE: bagl_glyph_e = 26;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_EYE_BADGE: bagl_glyph_e = 27;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_PEOPLE_BADGE: bagl_glyph_e = 28;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_LOCK_BADGE: bagl_glyph_e = 29;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_BLUE_CABLE: bagl_glyph_e = 30;
pub const bagl_glyph_e_BAGL_GLYPH_TEXT_WELCOME: bagl_glyph_e = 31;
pub const bagl_glyph_e_BAGL_GLYPH_LOGO_LEDGER_BOOT: bagl_glyph_e = 32;
pub const bagl_glyph_e_BAGL_GLYPH_BATT_LEFT: bagl_glyph_e = 33;
pub const bagl_glyph_e_BAGL_GLYPH_BATT_RIGHT: bagl_glyph_e = 34;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_LIGHTNING: bagl_glyph_e = 35;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_PLUG: bagl_glyph_e = 36;
pub const bagl_glyph_e_BAGL_GLYPH_BADGE_DOWNLOAD_BLUE: bagl_glyph_e = 37;
pub const bagl_glyph_e_BAGL_GLYPH_BADGE_WARNING_BLUE: bagl_glyph_e = 38;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_LOADER_BLUE: bagl_glyph_e = 39;
pub const bagl_glyph_e_BAGL_GLYPH_BADGE_CHECKMARK_BLUE: bagl_glyph_e = 40;
pub const bagl_glyph_e_BAGL_GLYPH_BADGE_WRENCH_BLUE: bagl_glyph_e = 41;
pub const bagl_glyph_e_BAGL_GLYPH_BADGE_ERROR_BLUE: bagl_glyph_e = 42;
pub const bagl_glyph_e_BAGL_GLYPH_BADGE_POWER_BLUE: bagl_glyph_e = 43;
pub const bagl_glyph_e_BAGL_GLYPH_BADGE_CRITICAL_BLUE: bagl_glyph_e = 44;
pub const bagl_glyph_e_BAGL_GLYPH_BADGE_ASSISTANCE_BLUE: bagl_glyph_e = 45;
pub const bagl_glyph_e_BAGL_GLYPH_BADGE_LOCK_BLUE: bagl_glyph_e = 46;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_CHECKMARK_BLUE: bagl_glyph_e = 47;
pub const bagl_glyph_e_BAGL_GLYPH_APP_FIRMWARE_BLUE: bagl_glyph_e = 48;
pub const bagl_glyph_e_BAGL_GLYPH_BADGE_BLUE: bagl_glyph_e = 49;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_BRIGHTNESS_LOW_BLUE: bagl_glyph_e = 50;
pub const bagl_glyph_e_BAGL_GLYPH_ICON_BRIGHTNESS_HIGH_BLUE: bagl_glyph_e = 51;
pub type bagl_glyph_e = cty::c_uint;
extern "C" {
    pub fn bagl_compute_line_width(
        font_id: cty::c_ushort,
        width: cty::c_ushort,
        text: *const cty::c_void,
        text_length: cty::c_uchar,
        text_encoding: cty::c_uchar,
    ) -> cty::c_ushort;
}
extern "C" {
    pub fn bagl_draw_string(
        font_id: cty::c_ushort,
        color1: cty::c_uint,
        color0: cty::c_uint,
        x: cty::c_int,
        y: cty::c_int,
        width: cty::c_uint,
        height: cty::c_uint,
        text: *const cty::c_void,
        text_length: cty::c_uint,
        text_encoding: cty::c_uchar,
    ) -> cty::c_int;
}
extern "C" {
    pub fn bagl_draw_bg(color: cty::c_uint);
}
extern "C" {
    pub fn bagl_draw_with_context(
        component: *const bagl_component_t,
        text: *const cty::c_void,
        text_length: cty::c_ushort,
        text_encoding: cty::c_uchar,
    );
}
extern "C" {
    pub fn bagl_draw(component: *const bagl_component_t);
}
extern "C" {
    pub fn bagl_draw_glyph(
        component: *const bagl_component_t,
        icon_details: *const bagl_icon_details_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bagl_animated_s {
    pub c: bagl_component_t,
    pub text: *mut cty::c_void,
    pub text_length: cty::c_ushort,
    pub text_encoding: cty::c_uchar,
    pub current_char_idx: cty::c_uint,
    pub current_x: cty::c_uint,
    pub next_ms: cty::c_uint,
}
#[test]
fn bindgen_test_layout_bagl_animated_s() {
    const UNINIT: ::core::mem::MaybeUninit<bagl_animated_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bagl_animated_s>(),
        52usize,
        concat!("Size of: ", stringify!(bagl_animated_s))
    );
    assert_eq!(
        ::core::mem::align_of::<bagl_animated_s>(),
        4usize,
        concat!("Alignment of ", stringify!(bagl_animated_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).c) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_animated_s),
            "::",
            stringify!(c)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).text) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_animated_s),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).text_length) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_animated_s),
            "::",
            stringify!(text_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).text_encoding) as usize - ptr as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_animated_s),
            "::",
            stringify!(text_encoding)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).current_char_idx) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_animated_s),
            "::",
            stringify!(current_char_idx)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).current_x) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_animated_s),
            "::",
            stringify!(current_x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next_ms) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(bagl_animated_s),
            "::",
            stringify!(next_ms)
        )
    );
}
impl Default for bagl_animated_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type bagl_animated_t = bagl_animated_s;
extern "C" {
    pub fn bagl_animate(
        anim: *mut bagl_animated_t,
        timestamp_ms: cty::c_uint,
        interval_ms: cty::c_uint,
    );
}
extern "C" {
    pub fn bagl_hal_draw_bitmap_within_rect(
        x: cty::c_int,
        y: cty::c_int,
        width: cty::c_uint,
        height: cty::c_uint,
        color_count: cty::c_uint,
        colors: *const cty::c_uint,
        bit_per_pixel: cty::c_uint,
        bitmap: *const cty::c_uchar,
        bitmap_length_bits: cty::c_uint,
    );
}
extern "C" {
    pub fn bagl_hal_draw_bitmap_continue(
        bit_per_pixel: cty::c_uint,
        bitmap: *const cty::c_uchar,
        bitmap_length_bits: cty::c_uint,
    );
}
extern "C" {
    pub fn bagl_hal_draw_rect(
        color: cty::c_uint,
        x: cty::c_int,
        y: cty::c_int,
        width: cty::c_uint,
        height: cty::c_uint,
    );
}
extern "C" {
    pub fn bagl_action(component: *const bagl_component_t, event_kind: cty::c_uchar);
}
extern "C" {
    pub fn os_endorsement_get_code_hash(buffer: *mut cty::c_uchar) -> cty::c_uint;
}
extern "C" {
    pub fn os_endorsement_get_public_key(
        index: cty::c_uchar,
        buffer: *mut cty::c_uchar,
    ) -> cty::c_uint;
}
extern "C" {
    pub fn os_endorsement_get_public_key_certificate(
        index: cty::c_uchar,
        buffer: *mut cty::c_uchar,
    ) -> cty::c_uint;
}
extern "C" {
    pub fn os_endorsement_key1_get_app_secret(buffer: *mut cty::c_uchar) -> cty::c_uint;
}
extern "C" {
    pub fn os_endorsement_key1_sign_data(
        src: *mut cty::c_uchar,
        srcLength: cty::c_uint,
        signature: *mut cty::c_uchar,
    ) -> cty::c_uint;
}
extern "C" {
    pub fn os_endorsement_key2_derive_sign_data(
        src: *mut cty::c_uchar,
        srcLength: cty::c_uint,
        signature: *mut cty::c_uchar,
    ) -> cty::c_uint;
}
extern "C" {
    pub fn halt();
}
pub type bolos_bool_t = cty::c_char;
pub type bolos_task_status_t = cty::c_uchar;
pub const task_unsecure_id_e_TASK_BOLOS: task_unsecure_id_e = 0;
pub const task_unsecure_id_e_TASK_SYSCALL: task_unsecure_id_e = 1;
pub const task_unsecure_id_e_TASK_USERTASKS_START: task_unsecure_id_e = 2;
pub const task_unsecure_id_e_TASK_USER: task_unsecure_id_e = 2;
pub const task_unsecure_id_e_TASK_SUBTASKS_START: task_unsecure_id_e = 3;
pub const task_unsecure_id_e_TASK_SUBTASK_0: task_unsecure_id_e = 3;
pub const task_unsecure_id_e_TASK_BOLOS_UX: task_unsecure_id_e = 4;
pub const task_unsecure_id_e_TASK_MAXCOUNT: task_unsecure_id_e = 5;
pub type task_unsecure_id_e = cty::c_uint;
extern "C" {
    pub fn os_sched_exec(app_idx: cty::c_uint);
}
extern "C" {
    pub fn os_sched_exit(exit_code: bolos_task_status_t);
}
extern "C" {
    pub fn os_sched_is_running(task_idx: cty::c_uint) -> bolos_bool_t;
}
extern "C" {
    #[doc = " Retrieve the last status issued by a task using either yield or exit."]
    pub fn os_sched_last_status(task_idx: cty::c_uint) -> bolos_task_status_t;
}
extern "C" {
    #[doc = " Current task is yielding the process to another task.\n Meta call for task_switch with 'the enxt' task idx.\n @param status is the current task status"]
    pub fn os_sched_yield(status: bolos_task_status_t);
}
extern "C" {
    #[doc = " Perform task switching\n @param task_idx is the task index to switch to\n @param status of the currently executed task\n @return the status of the previously running task"]
    pub fn os_sched_switch(task_idx: cty::c_uint, status: bolos_task_status_t);
}
extern "C" {
    #[doc = " Function that returns the currently running task identifier."]
    pub fn os_sched_current_task() -> cty::c_uint;
}
extern "C" {
    #[doc = " Create a new task with the given parameters and return its task identifier.\n The newly created task is chrooted in the given nvram/ram1/ram2 segments\n and its task pointer is set at the end of ram1 segment.\n The task is bound to the currently running application.\n The task identifiers are not garanteed to be the same after a power cycle.\n At least valid main, nvram segment, ram0 segment and stack segment must be\n provided with.\n @param main The main function address to start the task with.\n @param nvram The nvram segment address start\n @param nvram_length The nvram segment length\n @param ram0 /ram0_length the first RAM segment description\n @param stack /stack_length the task's stack RAM segment description"]
    pub fn os_sched_create(
        main: *mut cty::c_void,
        nvram: *mut cty::c_void,
        nvram_length: cty::c_uint,
        ram0: *mut cty::c_void,
        ram0_length: cty::c_uint,
        stack: *mut cty::c_void,
        stack_length: cty::c_uint,
    ) -> cty::c_uint;
}
extern "C" {
    pub fn os_sched_kill(taskidx: cty::c_uint);
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct bolos_ux_asynch_callback_t {
    pub asynchmodal_end_callback:
        ::core::option::Option<unsafe extern "C" fn(ux_status: cty::c_uint)>,
}
#[test]
fn bindgen_test_layout_bolos_ux_asynch_callback_t() {
    const UNINIT: ::core::mem::MaybeUninit<bolos_ux_asynch_callback_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_asynch_callback_t>(),
        4usize,
        concat!("Size of: ", stringify!(bolos_ux_asynch_callback_t))
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_asynch_callback_t>(),
        4usize,
        concat!("Alignment of ", stringify!(bolos_ux_asynch_callback_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).asynchmodal_end_callback) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_asynch_callback_t),
            "::",
            stringify!(asynchmodal_end_callback)
        )
    );
}
extern "C" {
    pub static mut G_io_asynch_ux_callback: bolos_ux_asynch_callback_t;
}
extern "C" {
    pub fn os_flags() -> cty::c_uint;
}
extern "C" {
    pub fn os_version(version: *mut cty::c_uchar, maxlength: cty::c_uint) -> cty::c_uint;
}
extern "C" {
    pub fn os_serial(serial: *mut cty::c_uchar, maxlength: cty::c_uint) -> cty::c_uint;
}
extern "C" {
    pub fn os_seph_features() -> cty::c_uint;
}
extern "C" {
    pub fn os_seph_version(version: *mut cty::c_uchar, maxlength: cty::c_uint) -> cty::c_uint;
}
extern "C" {
    pub fn os_bootloader_version(version: *mut cty::c_uchar, maxlength: cty::c_uint)
        -> cty::c_uint;
}
extern "C" {
    pub fn os_get_sn(buffer: *mut cty::c_uchar) -> cty::c_uint;
}
extern "C" {
    pub fn get_api_level() -> cty::c_uint;
}
extern "C" {
    pub static mut G_io_apdu_buffer: [cty::c_uchar; 260usize];
}
extern "C" {
    pub fn io_exchange(channel_and_flags: cty::c_uchar, tx_len: cty::c_ushort) -> cty::c_ushort;
}
pub const io_apdu_media_t_IO_APDU_MEDIA_NONE: io_apdu_media_t = 0;
pub const io_apdu_media_t_IO_APDU_MEDIA_USB_HID: io_apdu_media_t = 1;
pub const io_apdu_media_t_IO_APDU_MEDIA_BLE: io_apdu_media_t = 2;
pub const io_apdu_media_t_IO_APDU_MEDIA_NFC: io_apdu_media_t = 3;
pub const io_apdu_media_t_IO_APDU_MEDIA_USB_CCID: io_apdu_media_t = 4;
pub const io_apdu_media_t_IO_APDU_MEDIA_USB_WEBUSB: io_apdu_media_t = 5;
pub const io_apdu_media_t_IO_APDU_MEDIA_RAW: io_apdu_media_t = 6;
pub const io_apdu_media_t_IO_APDU_MEDIA_U2F: io_apdu_media_t = 7;
pub type io_apdu_media_t = cty::c_uint;
extern "C" {
    pub static mut G_io_usb_ep_buffer: [cty::c_uchar; 64usize];
}
extern "C" {
    #[doc = " Return 1 when the event has been processed, 0 else"]
    pub fn io_event(channel: cty::c_uchar) -> cty::c_uchar;
}
extern "C" {
    #[doc = " Library call function.\n call_parameters[0] = library name string pointer (const)\n call_parameters[1] = library call identifier (0 = init, ...)\n call_parameters[2+] = called function parameters"]
    pub fn os_lib_call(call_parameters: *mut cty::c_uint);
}
extern "C" {
    pub fn os_lib_end();
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct meminfo_s {
    pub free_nvram_size: cty::c_uint,
    pub appMemory: cty::c_uint,
    pub systemSize: cty::c_uint,
    pub slots: cty::c_uint,
}
#[test]
fn bindgen_test_layout_meminfo_s() {
    const UNINIT: ::core::mem::MaybeUninit<meminfo_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<meminfo_s>(),
        16usize,
        concat!("Size of: ", stringify!(meminfo_s))
    );
    assert_eq!(
        ::core::mem::align_of::<meminfo_s>(),
        4usize,
        concat!("Alignment of ", stringify!(meminfo_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).free_nvram_size) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(meminfo_s),
            "::",
            stringify!(free_nvram_size)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).appMemory) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(meminfo_s),
            "::",
            stringify!(appMemory)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).systemSize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(meminfo_s),
            "::",
            stringify!(systemSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).slots) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(meminfo_s),
            "::",
            stringify!(slots)
        )
    );
}
pub type meminfo_t = meminfo_s;
extern "C" {
    pub fn os_get_memory_info(meminfo: *mut meminfo_t);
}
extern "C" {
    pub fn nvm_write(dst_adr: *mut cty::c_void, src_adr: *mut cty::c_void, src_len: cty::c_uint);
}
extern "C" {
    pub fn nvm_erase(dst_adr: *mut cty::c_void, len: cty::c_uint);
}
extern "C" {
    pub fn nvm_write_page(page_adr: cty::c_uint);
}
extern "C" {
    pub fn nvm_erase_page(page_adr: cty::c_uint);
}
extern "C" {
    pub fn os_perso_erase_all();
}
extern "C" {
    pub fn pic(linked_address: *mut cty::c_void) -> *mut cty::c_void;
}
extern "C" {
    pub fn pic_internal(link_address: *mut cty::c_void) -> *mut cty::c_void;
}
extern "C" {
    pub fn os_perso_set_pin(identity: cty::c_uint, pin: *mut cty::c_uchar, length: cty::c_uint);
}
extern "C" {
    pub fn os_perso_set_current_identity_pin(pin: *mut cty::c_uchar, length: cty::c_uint);
}
extern "C" {
    pub fn os_global_pin_is_validated() -> bolos_bool_t;
}
extern "C" {
    #[doc = " Validating the pin also setup the identity linked with this pin (normal or\n alternate)\n @return BOLOS_UX_OK if pin validated"]
    pub fn os_global_pin_check(
        pin_buffer: *mut cty::c_uchar,
        pin_length: cty::c_uchar,
    ) -> bolos_bool_t;
}
extern "C" {
    pub fn os_global_pin_invalidate();
}
extern "C" {
    pub fn os_global_pin_retries() -> cty::c_uint;
}
pub type va_list = u32;
pub type __gnuc_va_list = u32;
pub type wint_t = cty::c_int;
pub type __blkcnt_t = cty::c_long;
pub type __blksize_t = cty::c_long;
pub type __fsblkcnt_t = __uint64_t;
pub type __fsfilcnt_t = __uint32_t;
pub type _off_t = cty::c_long;
pub type __pid_t = cty::c_int;
pub type __dev_t = cty::c_short;
pub type __uid_t = cty::c_ushort;
pub type __gid_t = cty::c_ushort;
pub type __id_t = __uint32_t;
pub type __ino_t = cty::c_ushort;
pub type __mode_t = __uint32_t;
pub type _off64_t = cty::c_longlong;
pub type __off_t = _off_t;
pub type __loff_t = _off64_t;
pub type __key_t = cty::c_long;
pub type _fpos_t = cty::c_long;
pub type __size_t = cty::c_uint;
pub type _ssize_t = cty::c_int;
pub type __ssize_t = _ssize_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _mbstate_t {
    pub __count: cty::c_int,
    pub __value: _mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _mbstate_t__bindgen_ty_1 {
    pub __wch: wint_t,
    pub __wchb: [cty::c_uchar; 4usize],
}
#[test]
fn bindgen_test_layout__mbstate_t__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_mbstate_t__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(_mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(_mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wch) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__wchb) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
impl Default for _mbstate_t__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__mbstate_t() {
    const UNINIT: ::core::mem::MaybeUninit<_mbstate_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(_mbstate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_mbstate_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
impl Default for _mbstate_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type _iconv_t = *mut cty::c_void;
pub type __clock_t = cty::c_ulong;
pub type __time_t = __int_least64_t;
pub type __clockid_t = cty::c_ulong;
pub type __timer_t = cty::c_ulong;
pub type __sa_family_t = __uint8_t;
pub type __socklen_t = __uint32_t;
pub type __nl_item = cty::c_int;
pub type __nlink_t = cty::c_ushort;
pub type __suseconds_t = cty::c_long;
pub type __useconds_t = cty::c_ulong;
pub type __va_list = u32;
pub type __ULong = cty::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __lock {
    _unused: [u8; 0],
}
pub type _LOCK_T = *mut __lock;
extern "C" {
    pub fn __retarget_lock_init(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_init_recursive(lock: *mut _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_close(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_close_recursive(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_acquire(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_acquire_recursive(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_try_acquire(lock: _LOCK_T) -> cty::c_int;
}
extern "C" {
    pub fn __retarget_lock_try_acquire_recursive(lock: _LOCK_T) -> cty::c_int;
}
extern "C" {
    pub fn __retarget_lock_release(lock: _LOCK_T);
}
extern "C" {
    pub fn __retarget_lock_release_recursive(lock: _LOCK_T);
}
pub type _flock_t = _LOCK_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Bigint {
    pub _next: *mut _Bigint,
    pub _k: cty::c_int,
    pub _maxwds: cty::c_int,
    pub _sign: cty::c_int,
    pub _wds: cty::c_int,
    pub _x: [__ULong; 1usize],
}
#[test]
fn bindgen_test_layout__Bigint() {
    const UNINIT: ::core::mem::MaybeUninit<_Bigint> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_Bigint>(),
        24usize,
        concat!("Size of: ", stringify!(_Bigint))
    );
    assert_eq!(
        ::core::mem::align_of::<_Bigint>(),
        4usize,
        concat!("Alignment of ", stringify!(_Bigint))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._k) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_k)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._maxwds) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_maxwds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._sign) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_sign)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._wds) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_wds)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._x) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_Bigint),
            "::",
            stringify!(_x)
        )
    );
}
impl Default for _Bigint {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __tm {
    pub __tm_sec: cty::c_int,
    pub __tm_min: cty::c_int,
    pub __tm_hour: cty::c_int,
    pub __tm_mday: cty::c_int,
    pub __tm_mon: cty::c_int,
    pub __tm_year: cty::c_int,
    pub __tm_wday: cty::c_int,
    pub __tm_yday: cty::c_int,
    pub __tm_isdst: cty::c_int,
}
#[test]
fn bindgen_test_layout___tm() {
    const UNINIT: ::core::mem::MaybeUninit<__tm> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__tm>(),
        36usize,
        concat!("Size of: ", stringify!(__tm))
    );
    assert_eq!(
        ::core::mem::align_of::<__tm>(),
        4usize,
        concat!("Alignment of ", stringify!(__tm))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_min)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_year)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__tm),
            "::",
            stringify!(__tm_isdst)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _on_exit_args {
    pub _fnargs: [*mut cty::c_void; 32usize],
    pub _dso_handle: [*mut cty::c_void; 32usize],
    pub _fntypes: __ULong,
    pub _is_cxa: __ULong,
}
#[test]
fn bindgen_test_layout__on_exit_args() {
    const UNINIT: ::core::mem::MaybeUninit<_on_exit_args> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_on_exit_args>(),
        264usize,
        concat!("Size of: ", stringify!(_on_exit_args))
    );
    assert_eq!(
        ::core::mem::align_of::<_on_exit_args>(),
        4usize,
        concat!("Alignment of ", stringify!(_on_exit_args))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._fnargs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_fnargs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._dso_handle) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_dso_handle)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._fntypes) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_fntypes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._is_cxa) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(_on_exit_args),
            "::",
            stringify!(_is_cxa)
        )
    );
}
impl Default for _on_exit_args {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _atexit {
    pub _next: *mut _atexit,
    pub _ind: cty::c_int,
    pub _fns: [::core::option::Option<unsafe extern "C" fn()>; 32usize],
    pub _on_exit_args: _on_exit_args,
}
#[test]
fn bindgen_test_layout__atexit() {
    const UNINIT: ::core::mem::MaybeUninit<_atexit> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_atexit>(),
        400usize,
        concat!("Size of: ", stringify!(_atexit))
    );
    assert_eq!(
        ::core::mem::align_of::<_atexit>(),
        4usize,
        concat!("Alignment of ", stringify!(_atexit))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._ind) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_ind)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._fns) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_fns)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._on_exit_args) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_atexit),
            "::",
            stringify!(_on_exit_args)
        )
    );
}
impl Default for _atexit {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sbuf {
    pub _base: *mut cty::c_uchar,
    pub _size: cty::c_int,
}
#[test]
fn bindgen_test_layout___sbuf() {
    const UNINIT: ::core::mem::MaybeUninit<__sbuf> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__sbuf>(),
        8usize,
        concat!("Size of: ", stringify!(__sbuf))
    );
    assert_eq!(
        ::core::mem::align_of::<__sbuf>(),
        4usize,
        concat!("Alignment of ", stringify!(__sbuf))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._base) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_base)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._size) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sbuf),
            "::",
            stringify!(_size)
        )
    );
}
impl Default for __sbuf {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sFILE {
    pub _p: *mut cty::c_uchar,
    pub _r: cty::c_int,
    pub _w: cty::c_int,
    pub _flags: cty::c_short,
    pub _file: cty::c_short,
    pub _bf: __sbuf,
    pub _lbfsize: cty::c_int,
    pub _cookie: *mut cty::c_void,
    pub _read: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut cty::c_void,
            arg3: *mut cty::c_char,
            arg4: cty::c_int,
        ) -> cty::c_int,
    >,
    pub _write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut cty::c_void,
            arg3: *const cty::c_char,
            arg4: cty::c_int,
        ) -> cty::c_int,
    >,
    pub _seek: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut _reent,
            arg2: *mut cty::c_void,
            arg3: _fpos_t,
            arg4: cty::c_int,
        ) -> _fpos_t,
    >,
    pub _close: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut _reent, arg2: *mut cty::c_void) -> cty::c_int,
    >,
    pub _ub: __sbuf,
    pub _up: *mut cty::c_uchar,
    pub _ur: cty::c_int,
    pub _ubuf: [cty::c_uchar; 3usize],
    pub _nbuf: [cty::c_uchar; 1usize],
    pub _lb: __sbuf,
    pub _blksize: cty::c_int,
    pub _offset: _off_t,
    pub _data: *mut _reent,
    pub _lock: _flock_t,
    pub _mbstate: _mbstate_t,
    pub _flags2: cty::c_int,
}
#[test]
fn bindgen_test_layout___sFILE() {
    const UNINIT: ::core::mem::MaybeUninit<__sFILE> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<__sFILE>(),
        104usize,
        concat!("Size of: ", stringify!(__sFILE))
    );
    assert_eq!(
        ::core::mem::align_of::<__sFILE>(),
        4usize,
        concat!("Alignment of ", stringify!(__sFILE))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_p)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._r) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_r)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._w) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_w)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._file) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_file)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._bf) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_bf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._lbfsize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lbfsize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._cookie) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_cookie)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._read) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_read)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._write) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_write)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._seek) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_seek)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._close) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_close)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._ub) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ub)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._up) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_up)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._ur) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ur)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._ubuf) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_ubuf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._nbuf) as usize - ptr as usize },
        67usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_nbuf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._lb) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lb)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._blksize) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_blksize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._offset) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._data) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._lock) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mbstate) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_mbstate)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._flags2) as usize - ptr as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(__sFILE),
            "::",
            stringify!(_flags2)
        )
    );
}
impl Default for __sFILE {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type __FILE = __sFILE;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _glue {
    pub _next: *mut _glue,
    pub _niobs: cty::c_int,
    pub _iobs: *mut __FILE,
}
#[test]
fn bindgen_test_layout__glue() {
    const UNINIT: ::core::mem::MaybeUninit<_glue> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_glue>(),
        12usize,
        concat!("Size of: ", stringify!(_glue))
    );
    assert_eq!(
        ::core::mem::align_of::<_glue>(),
        4usize,
        concat!("Alignment of ", stringify!(_glue))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._next) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._niobs) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_niobs)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._iobs) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_glue),
            "::",
            stringify!(_iobs)
        )
    );
}
impl Default for _glue {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _rand48 {
    pub _seed: [cty::c_ushort; 3usize],
    pub _mult: [cty::c_ushort; 3usize],
    pub _add: cty::c_ushort,
}
#[test]
fn bindgen_test_layout__rand48() {
    const UNINIT: ::core::mem::MaybeUninit<_rand48> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_rand48>(),
        14usize,
        concat!("Size of: ", stringify!(_rand48))
    );
    assert_eq!(
        ::core::mem::align_of::<_rand48>(),
        2usize,
        concat!("Alignment of ", stringify!(_rand48))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._seed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_seed)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mult) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_mult)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._add) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_rand48),
            "::",
            stringify!(_add)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent {
    pub _errno: cty::c_int,
    pub _stdin: *mut __FILE,
    pub _stdout: *mut __FILE,
    pub _stderr: *mut __FILE,
    pub _inc: cty::c_int,
    pub _emergency: [cty::c_char; 25usize],
    pub _unspecified_locale_info: cty::c_int,
    pub _locale: *mut __locale_t,
    pub __sdidinit: cty::c_int,
    pub __cleanup: ::core::option::Option<unsafe extern "C" fn(arg1: *mut _reent)>,
    pub _result: *mut _Bigint,
    pub _result_k: cty::c_int,
    pub _p5s: *mut _Bigint,
    pub _freelist: *mut *mut _Bigint,
    pub _cvtlen: cty::c_int,
    pub _cvtbuf: *mut cty::c_char,
    pub _new: _reent__bindgen_ty_1,
    pub _atexit: *mut _atexit,
    pub _atexit0: _atexit,
    pub _sig_func: *mut ::core::option::Option<unsafe extern "C" fn(arg1: cty::c_int)>,
    pub __sglue: _glue,
    pub __sf: [__FILE; 3usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union _reent__bindgen_ty_1 {
    pub _reent: _reent__bindgen_ty_1__bindgen_ty_1,
    pub _unused: _reent__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_1 {
    pub _unused_rand: cty::c_uint,
    pub _strtok_last: *mut cty::c_char,
    pub _asctime_buf: [cty::c_char; 26usize],
    pub _localtime_buf: __tm,
    pub _gamma_signgam: cty::c_int,
    pub _rand_next: cty::c_ulonglong,
    pub _r48: _rand48,
    pub _mblen_state: _mbstate_t,
    pub _mbtowc_state: _mbstate_t,
    pub _wctomb_state: _mbstate_t,
    pub _l64a_buf: [cty::c_char; 8usize],
    pub _signal_buf: [cty::c_char; 24usize],
    pub _getdate_err: cty::c_int,
    pub _mbrlen_state: _mbstate_t,
    pub _mbrtowc_state: _mbstate_t,
    pub _mbsrtowcs_state: _mbstate_t,
    pub _wcrtomb_state: _mbstate_t,
    pub _wcsrtombs_state: _mbstate_t,
    pub _h_errno: cty::c_int,
}
#[test]
fn bindgen_test_layout__reent__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_reent__bindgen_ty_1__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_reent__bindgen_ty_1__bindgen_ty_1>(),
        208usize,
        concat!("Size of: ", stringify!(_reent__bindgen_ty_1__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._unused_rand) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_unused_rand)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._strtok_last) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_strtok_last)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._asctime_buf) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_asctime_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._localtime_buf) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_localtime_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._gamma_signgam) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_gamma_signgam)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._rand_next) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_rand_next)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._r48) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_r48)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mblen_state) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mblen_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mbtowc_state) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbtowc_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._wctomb_state) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_wctomb_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._l64a_buf) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_l64a_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._signal_buf) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_signal_buf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._getdate_err) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_getdate_err)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mbrlen_state) as usize - ptr as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbrlen_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mbrtowc_state) as usize - ptr as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbrtowc_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._mbsrtowcs_state) as usize - ptr as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_mbsrtowcs_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._wcrtomb_state) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_wcrtomb_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._wcsrtombs_state) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_wcsrtombs_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._h_errno) as usize - ptr as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(_h_errno)
        )
    );
}
impl Default for _reent__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _reent__bindgen_ty_1__bindgen_ty_2 {
    pub _nextf: [*mut cty::c_uchar; 30usize],
    pub _nmalloc: [cty::c_uint; 30usize],
}
#[test]
fn bindgen_test_layout__reent__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::core::mem::MaybeUninit<_reent__bindgen_ty_1__bindgen_ty_2> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_reent__bindgen_ty_1__bindgen_ty_2>(),
        240usize,
        concat!("Size of: ", stringify!(_reent__bindgen_ty_1__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent__bindgen_ty_1__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._nextf) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_nextf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._nmalloc) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(_nmalloc)
        )
    );
}
impl Default for _reent__bindgen_ty_1__bindgen_ty_2 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__reent__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<_reent__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_reent__bindgen_ty_1>(),
        240usize,
        concat!("Size of: ", stringify!(_reent__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(_reent__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._reent) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1),
            "::",
            stringify!(_reent)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent__bindgen_ty_1),
            "::",
            stringify!(_unused)
        )
    );
}
impl Default for _reent__bindgen_ty_1 {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[test]
fn bindgen_test_layout__reent() {
    const UNINIT: ::core::mem::MaybeUninit<_reent> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_reent>(),
        1064usize,
        concat!("Size of: ", stringify!(_reent))
    );
    assert_eq!(
        ::core::mem::align_of::<_reent>(),
        8usize,
        concat!("Alignment of ", stringify!(_reent))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._errno) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_errno)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._stdin) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stdin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._stdout) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stdout)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._stderr) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_stderr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._inc) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_inc)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._emergency) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_emergency)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._unspecified_locale_info) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_unspecified_locale_info)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._locale) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_locale)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sdidinit) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__sdidinit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__cleanup) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__cleanup)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._result) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_result)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._result_k) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_result_k)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._p5s) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_p5s)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._freelist) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_freelist)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._cvtlen) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_cvtlen)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._cvtbuf) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_cvtbuf)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._new) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_new)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._atexit) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_atexit)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._atexit0) as usize - ptr as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_atexit0)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr)._sig_func) as usize - ptr as usize },
        732usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(_sig_func)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sglue) as usize - ptr as usize },
        736usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__sglue)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).__sf) as usize - ptr as usize },
        748usize,
        concat!(
            "Offset of field: ",
            stringify!(_reent),
            "::",
            stringify!(__sf)
        )
    );
}
impl Default for _reent {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
extern "C" {
    pub static mut _impure_ptr: *mut _reent;
}
extern "C" {
    pub static _global_impure_ptr: *mut _reent;
}
extern "C" {
    pub fn _reclaim_reent(arg1: *mut _reent);
}
pub type u_int8_t = __uint8_t;
pub type u_int16_t = __uint16_t;
pub type u_int32_t = __uint32_t;
pub type u_int64_t = __uint64_t;
pub type register_t = __intptr_t;
pub type __sigset_t = cty::c_ulong;
pub type suseconds_t = __suseconds_t;
pub type time_t = __int_least64_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::core::mem::MaybeUninit<timeval> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::core::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: cty::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::core::mem::MaybeUninit<timespec> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::core::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    const UNINIT: ::core::mem::MaybeUninit<itimerspec> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::core::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).it_interval) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).it_value) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
pub type sigset_t = __sigset_t;
pub type fd_mask = cty::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _types_fd_set {
    pub fds_bits: [fd_mask; 2usize],
}
#[test]
fn bindgen_test_layout__types_fd_set() {
    const UNINIT: ::core::mem::MaybeUninit<_types_fd_set> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_types_fd_set>(),
        8usize,
        concat!("Size of: ", stringify!(_types_fd_set))
    );
    assert_eq!(
        ::core::mem::align_of::<_types_fd_set>(),
        4usize,
        concat!("Alignment of ", stringify!(_types_fd_set))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fds_bits) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_types_fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
extern "C" {
    pub fn select(
        __n: cty::c_int,
        __readfds: *mut _types_fd_set,
        __writefds: *mut _types_fd_set,
        __exceptfds: *mut _types_fd_set,
        __timeout: *mut timeval,
    ) -> cty::c_int;
}
extern "C" {
    pub fn pselect(
        __n: cty::c_int,
        __readfds: *mut _types_fd_set,
        __writefds: *mut _types_fd_set,
        __exceptfds: *mut _types_fd_set,
        __timeout: *const timespec,
        __set: *const sigset_t,
    ) -> cty::c_int;
}
pub type in_addr_t = __uint32_t;
pub type in_port_t = __uint16_t;
pub type u_register_t = __uintptr_t;
pub type u_char = cty::c_uchar;
pub type u_short = cty::c_ushort;
pub type u_int = cty::c_uint;
pub type u_long = cty::c_ulong;
pub type ushort = cty::c_ushort;
pub type uint = cty::c_uint;
pub type ulong = cty::c_ulong;
pub type blkcnt_t = __blkcnt_t;
pub type blksize_t = __blksize_t;
pub type clock_t = cty::c_ulong;
pub type daddr_t = cty::c_long;
pub type caddr_t = *mut cty::c_char;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
pub type id_t = __id_t;
pub type ino_t = __ino_t;
pub type off_t = __off_t;
pub type dev_t = __dev_t;
pub type uid_t = __uid_t;
pub type gid_t = __gid_t;
pub type pid_t = __pid_t;
pub type key_t = __key_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
pub type useconds_t = __useconds_t;
pub type sbintime_t = __int64_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sched_param {
    pub sched_priority: cty::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    const UNINIT: ::core::mem::MaybeUninit<sched_param> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::core::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sched_priority) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
}
pub type pthread_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_attr_t {
    pub is_initialized: cty::c_int,
    pub stackaddr: *mut cty::c_void,
    pub stacksize: cty::c_int,
    pub contentionscope: cty::c_int,
    pub inheritsched: cty::c_int,
    pub schedpolicy: cty::c_int,
    pub schedparam: sched_param,
    pub detachstate: cty::c_int,
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_attr_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_attr_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_attr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_initialized) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(is_initialized)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stackaddr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(stackaddr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).stacksize) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(stacksize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).contentionscope) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(contentionscope)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).inheritsched) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(inheritsched)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).schedpolicy) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(schedpolicy)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).schedparam) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(schedparam)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).detachstate) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(detachstate)
        )
    );
}
impl Default for pthread_attr_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type pthread_mutex_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pthread_mutexattr_t {
    pub is_initialized: cty::c_int,
    pub recursive: cty::c_int,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_mutexattr_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_mutexattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_initialized) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(is_initialized)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).recursive) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(recursive)
        )
    );
}
pub type pthread_cond_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pthread_condattr_t {
    pub is_initialized: cty::c_int,
    pub clock: clock_t,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_condattr_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_condattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_initialized) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(is_initialized)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).clock) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(clock)
        )
    );
}
pub type pthread_key_t = __uint32_t;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct pthread_once_t {
    pub is_initialized: cty::c_int,
    pub init_executed: cty::c_int,
}
#[test]
fn bindgen_test_layout_pthread_once_t() {
    const UNINIT: ::core::mem::MaybeUninit<pthread_once_t> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<pthread_once_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_once_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_once_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_once_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).is_initialized) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_once_t),
            "::",
            stringify!(is_initialized)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).init_executed) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_once_t),
            "::",
            stringify!(init_executed)
        )
    );
}
pub type FILE = __FILE;
pub type fpos_t = _fpos_t;
extern "C" {
    pub fn ctermid(arg1: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(arg1: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn tempnam(arg1: *const cty::c_char, arg2: *const cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn fclose(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fflush(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn freopen(
        arg1: *const cty::c_char,
        arg2: *const cty::c_char,
        arg3: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(arg1: *mut FILE, arg2: *mut cty::c_char);
}
extern "C" {
    pub fn setvbuf(
        arg1: *mut FILE,
        arg2: *mut cty::c_char,
        arg3: cty::c_int,
        arg4: usize,
    ) -> cty::c_int;
}
extern "C" {
    pub fn fprintf(arg1: *mut FILE, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn fscanf(arg1: *mut FILE, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn printf(arg1: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn scanf(arg1: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn sscanf(arg1: *const cty::c_char, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn vfprintf(arg1: *mut FILE, arg2: *const cty::c_char, arg3: u32) -> cty::c_int;
}
extern "C" {
    pub fn vprintf(arg1: *const cty::c_char, arg2: u32) -> cty::c_int;
}
extern "C" {
    pub fn vsprintf(arg1: *mut cty::c_char, arg2: *const cty::c_char, arg3: u32) -> cty::c_int;
}
extern "C" {
    pub fn fgetc(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fgets(arg1: *mut cty::c_char, arg2: cty::c_int, arg3: *mut FILE) -> *mut cty::c_char;
}
extern "C" {
    pub fn fputc(arg1: cty::c_int, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fputs(arg1: *const cty::c_char, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn getc(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn getchar() -> cty::c_int;
}
extern "C" {
    pub fn gets(arg1: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn putc(arg1: cty::c_int, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn putchar(arg1: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn puts(arg1: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn ungetc(arg1: cty::c_int, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fread(
        arg1: *mut cty::c_void,
        _size: cty::c_uint,
        _n: cty::c_uint,
        arg2: *mut FILE,
    ) -> cty::c_uint;
}
extern "C" {
    pub fn fwrite(
        arg1: *const cty::c_void,
        _size: cty::c_uint,
        _n: cty::c_uint,
        arg2: *mut FILE,
    ) -> cty::c_uint;
}
extern "C" {
    pub fn fgetpos(arg1: *mut FILE, arg2: *mut fpos_t) -> cty::c_int;
}
extern "C" {
    pub fn fseek(arg1: *mut FILE, arg2: cty::c_long, arg3: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn fsetpos(arg1: *mut FILE, arg2: *const fpos_t) -> cty::c_int;
}
extern "C" {
    pub fn ftell(arg1: *mut FILE) -> cty::c_long;
}
extern "C" {
    pub fn rewind(arg1: *mut FILE);
}
extern "C" {
    pub fn clearerr(arg1: *mut FILE);
}
extern "C" {
    pub fn feof(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn ferror(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn perror(arg1: *const cty::c_char);
}
extern "C" {
    pub fn fopen(_name: *const cty::c_char, _type: *const cty::c_char) -> *mut FILE;
}
extern "C" {
    pub fn sprintf(arg1: *mut cty::c_char, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn remove(arg1: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn rename(arg1: *const cty::c_char, arg2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn fseeko(arg1: *mut FILE, arg2: off_t, arg3: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn ftello(arg1: *mut FILE) -> off_t;
}
extern "C" {
    pub fn snprintf(
        arg1: *mut cty::c_char,
        arg2: cty::c_uint,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn vsnprintf(
        arg1: *mut cty::c_char,
        arg2: cty::c_uint,
        arg3: *const cty::c_char,
        arg4: u32,
    ) -> cty::c_int;
}
extern "C" {
    pub fn vfscanf(arg1: *mut FILE, arg2: *const cty::c_char, arg3: u32) -> cty::c_int;
}
extern "C" {
    pub fn vscanf(arg1: *const cty::c_char, arg2: u32) -> cty::c_int;
}
extern "C" {
    pub fn vsscanf(arg1: *const cty::c_char, arg2: *const cty::c_char, arg3: u32) -> cty::c_int;
}
extern "C" {
    pub fn asiprintf(arg1: *mut *mut cty::c_char, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn asniprintf(
        arg1: *mut cty::c_char,
        arg2: *mut usize,
        arg3: *const cty::c_char,
        ...
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn asnprintf(
        arg1: *mut cty::c_char,
        arg2: *mut usize,
        arg3: *const cty::c_char,
        ...
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn diprintf(arg1: cty::c_int, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn fiprintf(arg1: *mut FILE, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn fiscanf(arg1: *mut FILE, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn iprintf(arg1: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn iscanf(arg1: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn siprintf(arg1: *mut cty::c_char, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn siscanf(arg1: *const cty::c_char, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn sniprintf(
        arg1: *mut cty::c_char,
        arg2: usize,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn vasiprintf(
        arg1: *mut *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn vasniprintf(
        arg1: *mut cty::c_char,
        arg2: *mut usize,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn vasnprintf(
        arg1: *mut cty::c_char,
        arg2: *mut usize,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn vdiprintf(
        arg1: cty::c_int,
        arg2: *const cty::c_char,
        arg3: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn vfiprintf(arg1: *mut FILE, arg2: *const cty::c_char, arg3: __gnuc_va_list)
        -> cty::c_int;
}
extern "C" {
    pub fn vfiscanf(arg1: *mut FILE, arg2: *const cty::c_char, arg3: __gnuc_va_list) -> cty::c_int;
}
extern "C" {
    pub fn viprintf(arg1: *const cty::c_char, arg2: __gnuc_va_list) -> cty::c_int;
}
extern "C" {
    pub fn viscanf(arg1: *const cty::c_char, arg2: __gnuc_va_list) -> cty::c_int;
}
extern "C" {
    pub fn vsiprintf(
        arg1: *mut cty::c_char,
        arg2: *const cty::c_char,
        arg3: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn vsiscanf(
        arg1: *const cty::c_char,
        arg2: *const cty::c_char,
        arg3: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn vsniprintf(
        arg1: *mut cty::c_char,
        arg2: usize,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn fdopen(arg1: cty::c_int, arg2: *const cty::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fileno(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn pclose(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn popen(arg1: *const cty::c_char, arg2: *const cty::c_char) -> *mut FILE;
}
extern "C" {
    pub fn setbuffer(arg1: *mut FILE, arg2: *mut cty::c_char, arg3: cty::c_int);
}
extern "C" {
    pub fn setlinebuf(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn getw(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn putw(arg1: cty::c_int, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn getc_unlocked(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> cty::c_int;
}
extern "C" {
    pub fn flockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn funlockfile(arg1: *mut FILE);
}
extern "C" {
    pub fn putc_unlocked(arg1: cty::c_int, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn putchar_unlocked(arg1: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn dprintf(arg1: cty::c_int, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn fmemopen(arg1: *mut cty::c_void, arg2: usize, arg3: *const cty::c_char) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(arg1: *mut *mut cty::c_char, arg2: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn vdprintf(arg1: cty::c_int, arg2: *const cty::c_char, arg3: __gnuc_va_list)
        -> cty::c_int;
}
extern "C" {
    pub fn renameat(
        arg1: cty::c_int,
        arg2: *const cty::c_char,
        arg3: cty::c_int,
        arg4: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _asiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut cty::c_char,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _asniprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: *mut usize,
        arg4: *const cty::c_char,
        ...
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn _asnprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: *mut usize,
        arg4: *const cty::c_char,
        ...
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn _asprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut cty::c_char,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _diprintf_r(
        arg1: *mut _reent,
        arg2: cty::c_int,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _dprintf_r(
        arg1: *mut _reent,
        arg2: cty::c_int,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _fclose_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _fcloseall_r(arg1: *mut _reent) -> cty::c_int;
}
extern "C" {
    pub fn _fdopen_r(arg1: *mut _reent, arg2: cty::c_int, arg3: *const cty::c_char) -> *mut FILE;
}
extern "C" {
    pub fn _fflush_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _fgetc_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _fgetc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _fgets_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: cty::c_int,
        arg4: *mut FILE,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn _fgets_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: cty::c_int,
        arg4: *mut FILE,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn _fgetpos_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *mut fpos_t) -> cty::c_int;
}
extern "C" {
    pub fn _fsetpos_r(arg1: *mut _reent, arg2: *mut FILE, arg3: *const fpos_t) -> cty::c_int;
}
extern "C" {
    pub fn _fiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _fiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _fmemopen_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_void,
        arg3: usize,
        arg4: *const cty::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fopen_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: *const cty::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _freopen_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: *const cty::c_char,
        arg4: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _fprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _fpurge_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _fputc_r(arg1: *mut _reent, arg2: cty::c_int, arg3: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _fputc_unlocked_r(arg1: *mut _reent, arg2: cty::c_int, arg3: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _fputs_r(arg1: *mut _reent, arg2: *const cty::c_char, arg3: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _fputs_unlocked_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: *mut FILE,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _fread_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fread_unlocked_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _fseek_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: cty::c_long,
        arg4: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _fseeko_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: _off_t,
        arg4: cty::c_int,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _ftell_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_long;
}
extern "C" {
    pub fn _ftello_r(arg1: *mut _reent, arg2: *mut FILE) -> _off_t;
}
extern "C" {
    pub fn _rewind_r(arg1: *mut _reent, arg2: *mut FILE);
}
extern "C" {
    pub fn _fwrite_r(
        arg1: *mut _reent,
        arg2: *const cty::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _fwrite_unlocked_r(
        arg1: *mut _reent,
        arg2: *const cty::c_void,
        _size: usize,
        _n: usize,
        arg3: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn _getc_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _getc_unlocked_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _getchar_r(arg1: *mut _reent) -> cty::c_int;
}
extern "C" {
    pub fn _getchar_unlocked_r(arg1: *mut _reent) -> cty::c_int;
}
extern "C" {
    pub fn _gets_r(arg1: *mut _reent, arg2: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn _iprintf_r(arg1: *mut _reent, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn _iscanf_r(arg1: *mut _reent, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn _open_memstream_r(
        arg1: *mut _reent,
        arg2: *mut *mut cty::c_char,
        arg3: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _perror_r(arg1: *mut _reent, arg2: *const cty::c_char);
}
extern "C" {
    pub fn _printf_r(arg1: *mut _reent, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn _putc_r(arg1: *mut _reent, arg2: cty::c_int, arg3: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _putc_unlocked_r(arg1: *mut _reent, arg2: cty::c_int, arg3: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _putchar_unlocked_r(arg1: *mut _reent, arg2: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn _putchar_r(arg1: *mut _reent, arg2: cty::c_int) -> cty::c_int;
}
extern "C" {
    pub fn _puts_r(arg1: *mut _reent, arg2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn _remove_r(arg1: *mut _reent, arg2: *const cty::c_char) -> cty::c_int;
}
extern "C" {
    pub fn _rename_r(
        arg1: *mut _reent,
        _old: *const cty::c_char,
        _new: *const cty::c_char,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _scanf_r(arg1: *mut _reent, arg2: *const cty::c_char, ...) -> cty::c_int;
}
extern "C" {
    pub fn _siprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _siscanf_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _sniprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: usize,
        arg4: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _snprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: usize,
        arg4: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _sprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _sscanf_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: *const cty::c_char,
        ...
    ) -> cty::c_int;
}
extern "C" {
    pub fn _tempnam_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: *const cty::c_char,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn _tmpfile_r(arg1: *mut _reent) -> *mut FILE;
}
extern "C" {
    pub fn _tmpnam_r(arg1: *mut _reent, arg2: *mut cty::c_char) -> *mut cty::c_char;
}
extern "C" {
    pub fn _ungetc_r(arg1: *mut _reent, arg2: cty::c_int, arg3: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn _vasiprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut cty::c_char,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vasniprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: *mut usize,
        arg4: *const cty::c_char,
        arg5: __gnuc_va_list,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn _vasnprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: *mut usize,
        arg4: *const cty::c_char,
        arg5: __gnuc_va_list,
    ) -> *mut cty::c_char;
}
extern "C" {
    pub fn _vasprintf_r(
        arg1: *mut _reent,
        arg2: *mut *mut cty::c_char,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vdiprintf_r(
        arg1: *mut _reent,
        arg2: cty::c_int,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vdprintf_r(
        arg1: *mut _reent,
        arg2: cty::c_int,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vfiprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vfiscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vfprintf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vfscanf_r(
        arg1: *mut _reent,
        arg2: *mut FILE,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _viprintf_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _viscanf_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vprintf_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vscanf_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vsiprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vsiscanf_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vsniprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: usize,
        arg4: *const cty::c_char,
        arg5: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vsnprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: usize,
        arg4: *const cty::c_char,
        arg5: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vsprintf_r(
        arg1: *mut _reent,
        arg2: *mut cty::c_char,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn _vsscanf_r(
        arg1: *mut _reent,
        arg2: *const cty::c_char,
        arg3: *const cty::c_char,
        arg4: __gnuc_va_list,
    ) -> cty::c_int;
}
extern "C" {
    pub fn fpurge(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn __getdelim(
        arg1: *mut *mut cty::c_char,
        arg2: *mut usize,
        arg3: cty::c_int,
        arg4: *mut FILE,
    ) -> isize;
}
extern "C" {
    pub fn __getline(arg1: *mut *mut cty::c_char, arg2: *mut usize, arg3: *mut FILE) -> isize;
}
extern "C" {
    pub fn clearerr_unlocked(arg1: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn ferror_unlocked(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fileno_unlocked(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fflush_unlocked(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(arg1: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fputc_unlocked(arg1: cty::c_int, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn fread_unlocked(
        arg1: *mut cty::c_void,
        _size: usize,
        _n: usize,
        arg2: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        arg1: *const cty::c_void,
        _size: usize,
        _n: usize,
        arg2: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn __srget_r(arg1: *mut _reent, arg2: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn __swbuf_r(arg1: *mut _reent, arg2: cty::c_int, arg3: *mut FILE) -> cty::c_int;
}
extern "C" {
    pub fn funopen(
        __cookie: *const cty::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut cty::c_void,
                __buf: *mut cty::c_char,
                __n: cty::c_int,
            ) -> cty::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut cty::c_void,
                __buf: *const cty::c_char,
                __n: cty::c_int,
            ) -> cty::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut cty::c_void,
                __off: fpos_t,
                __whence: cty::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(__cookie: *mut cty::c_void) -> cty::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn _funopen_r(
        arg1: *mut _reent,
        __cookie: *const cty::c_void,
        __readfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut cty::c_void,
                __buf: *mut cty::c_char,
                __n: cty::c_int,
            ) -> cty::c_int,
        >,
        __writefn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut cty::c_void,
                __buf: *const cty::c_char,
                __n: cty::c_int,
            ) -> cty::c_int,
        >,
        __seekfn: ::core::option::Option<
            unsafe extern "C" fn(
                __cookie: *mut cty::c_void,
                __off: fpos_t,
                __whence: cty::c_int,
            ) -> fpos_t,
        >,
        __closefn: ::core::option::Option<
            unsafe extern "C" fn(__cookie: *mut cty::c_void) -> cty::c_int,
        >,
    ) -> *mut FILE;
}
extern "C" {
    pub fn cx_get_random_bytes(buffer: *mut cty::c_void, len: usize) -> cx_err_t;
}
pub type appmain_t = ::core::option::Option<unsafe extern "C" fn()>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct application_s {
    pub nvram_begin: *mut cty::c_uchar,
    pub nvram_end: *mut cty::c_uchar,
    pub main: appmain_t,
    pub flags: cty::c_uint,
    pub code_length: cty::c_uint,
    pub data_length: cty::c_uint,
    pub params_length: cty::c_uint,
    pub sha256_code_data: [cty::c_uchar; 32usize],
    pub sha256_full: [cty::c_uchar; 32usize],
}
#[test]
fn bindgen_test_layout_application_s() {
    const UNINIT: ::core::mem::MaybeUninit<application_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<application_s>(),
        92usize,
        concat!("Size of: ", stringify!(application_s))
    );
    assert_eq!(
        ::core::mem::align_of::<application_s>(),
        4usize,
        concat!("Alignment of ", stringify!(application_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvram_begin) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(nvram_begin)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).nvram_end) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(nvram_end)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).main) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(main)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).code_length) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(code_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data_length) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(data_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).params_length) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(params_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sha256_code_data) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(sha256_code_data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).sha256_full) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(application_s),
            "::",
            stringify!(sha256_full)
        )
    );
}
impl Default for application_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type application_t = application_s;
extern "C" {
    #[doc = " @param appidx The application entry index in the registry (raw, not filtering\n ux or whatever). If the entry index correspond to the application being\n installed then RAM structure content is used instead of the NVRAM registry.\n @param tlvoffset The offset within the install parameters memory area, in\n bytes. Useful if tag is present multiple times. Can be null. The tlv offset\n is the offset of the tag in the install parameters area when a tag is\n matched. This way long tag can be read in multiple time without the need to\n play with the tlvoffset. Add +1 to skip to the next one when seraching for\n multiple tag occurences.\n @param tag The tag to be searched for\n @param value_offset The offset within the value for this occurence of the\n tag. The OS_REGISTRY_GET_TAG_OFFSET_COMPARE_WITH_BUFFER or\n OS_REGISTRY_GET_TAG_OFFSET_GET_LENGTH can be ORed to perform meta operation\n on the TLV occurence.\n @param buffer The user buffer for comparison or to retrieve the value of the\n tag at the given offset.\n @param maxlength Size of the buffer to be compared OR to be retrieved\n (trimmed depending the TLV effective length)."]
    pub fn os_registry_get_tag(
        app_idx: cty::c_uint,
        tlvoffset: *mut cty::c_uint,
        tag: cty::c_uint,
        value_offset: cty::c_uint,
        buffer: *mut cty::c_void,
        maxlength: cty::c_uint,
    ) -> cty::c_uint;
}
extern "C" {
    pub fn os_registry_get_current_app_tag(
        tag: cty::c_uint,
        buffer: *mut cty::c_uchar,
        maxlen: cty::c_uint,
    ) -> cty::c_uint;
}
extern "C" {
    #[doc = " This function deletes the application mentioned with its index, as well as\n all its dependees (the applications which depend on it).\n @param index The index of the the application to suppress."]
    pub fn os_registry_delete_app_and_dependees(app_idx: cty::c_uint);
}
extern "C" {
    #[doc = " This function deletes all the installed applications."]
    pub fn os_registry_delete_all_apps();
}
extern "C" {
    pub fn os_registry_count() -> cty::c_uint;
}
extern "C" {
    pub fn os_registry_get(app_idx: cty::c_uint, out_application_entry: *mut application_t);
}
extern "C" {
    #[doc = " Set the persisted seed if none yet, else override the volatile seed (in RAM)"]
    pub fn os_perso_set_seed(
        identity: cty::c_uint,
        algorithm: cty::c_uint,
        seed: *mut cty::c_uchar,
        length: cty::c_uint,
    );
}
extern "C" {
    pub fn os_perso_derive_and_set_seed(
        identity: cty::c_uchar,
        prefix: *const cty::c_char,
        prefix_length: cty::c_uint,
        passphrase: *const cty::c_char,
        passphrase_length: cty::c_uint,
        words: *const cty::c_char,
        words_length: cty::c_uint,
    );
}
extern "C" {
    pub fn os_perso_set_words(words: *const cty::c_uchar, length: cty::c_uint);
}
extern "C" {
    pub fn os_perso_finalize();
}
extern "C" {
    pub fn os_perso_isonboarded() -> bolos_bool_t;
}
extern "C" {
    pub fn os_perso_set_onboarding_status(
        kind: cty::c_uint,
        count: cty::c_uint,
        maxCount: cty::c_uint,
        isConfirming: cty::c_uint,
    );
}
extern "C" {
    pub fn os_perso_derive_node_bip32(
        curve: cx_curve_t,
        path: *const cty::c_uint,
        pathLength: cty::c_uint,
        privateKey: *mut cty::c_uchar,
        chain: *mut cty::c_uchar,
    );
}
extern "C" {
    pub fn os_perso_derive_node_with_seed_key(
        mode: cty::c_uint,
        curve: cx_curve_t,
        path: *const cty::c_uint,
        pathLength: cty::c_uint,
        privateKey: *mut cty::c_uchar,
        chain: *mut cty::c_uchar,
        seed_key: *mut cty::c_uchar,
        seed_key_length: cty::c_uint,
    );
}
extern "C" {
    pub fn os_perso_derive_eip2333(
        curve: cx_curve_t,
        path: *const cty::c_uint,
        pathLength: cty::c_uint,
        privateKey: *mut cty::c_uchar,
    );
}
pub const os_setting_e_OS_SETTING_BRIGHTNESS: os_setting_e = 0;
pub const os_setting_e_OS_SETTING_INVERT: os_setting_e = 1;
pub const os_setting_e_OS_SETTING_ROTATION: os_setting_e = 2;
pub const os_setting_e_OS_SETTING_AUTO_LOCK_DELAY: os_setting_e = 3;
pub const os_setting_e_OS_SETTING_SCREEN_LOCK_DELAY: os_setting_e = 4;
pub const os_setting_e_OS_SETTING_POWER_OFF_DELAY: os_setting_e = 5;
pub const os_setting_e_OS_SETTING_PLANEMODE: os_setting_e = 6;
pub const os_setting_e_OS_SETTING_PRIVACY_MODE: os_setting_e = 7;
pub const os_setting_e_OS_SETTING_LAST_INT: os_setting_e = 8;
pub const os_setting_e_OS_SETTING_SAVER_STRING: os_setting_e = 8;
pub const os_setting_e_OS_SETTING_DEVICENAME: os_setting_e = 9;
pub const os_setting_e_OS_SETTING_BLEMACADR: os_setting_e = 10;
pub const os_setting_e_OS_SETTING_LAST: os_setting_e = 11;
pub type os_setting_e = cty::c_uint;
pub use self::os_setting_e as os_setting_t;
extern "C" {
    #[doc = " Retrieve the value of a setting in a user specified buffer, with a max\n length, and return the effective returned length."]
    pub fn os_setting_get(
        setting_id: cty::c_uint,
        value: *mut cty::c_uchar,
        maxlen: cty::c_uint,
    ) -> cty::c_uint;
}
extern "C" {
    #[doc = " Define a setting's value from a user buffer and its length. In case of error,\n a throw is executed."]
    pub fn os_setting_set(setting_id: cty::c_uint, value: *mut cty::c_uchar, length: cty::c_uint);
}
extern "C" {
    pub fn u4be_encode(buffer: *mut cty::c_uchar, offset: cty::c_uint, value: cty::c_uint);
}
extern "C" {
    pub fn u4le_encode(buffer: *mut cty::c_uchar, offset: cty::c_uint, value: cty::c_uint);
}
extern "C" {
    pub fn os_memset4(dst: *mut cty::c_void, initval: cty::c_uint, nbintval: cty::c_uint);
}
extern "C" {
    pub fn os_xor(
        dst: *mut cty::c_void,
        src1: *mut cty::c_void,
        src2: *mut cty::c_void,
        length: cty::c_uint,
    );
}
extern "C" {
    pub fn os_secure_memcmp(
        src1: *mut cty::c_void,
        src2: *mut cty::c_void,
        length: cty::c_uint,
    ) -> cty::c_char;
}
extern "C" {
    pub fn os_memmove(
        dest: *mut cty::c_void,
        src: *const cty::c_void,
        n: usize,
    ) -> *mut cty::c_void;
}
extern "C" {
    pub fn os_memcpy(dest: *mut cty::c_void, src: *const cty::c_void, n: usize)
        -> *mut cty::c_void;
}
extern "C" {
    pub fn os_memcmp(s1: *const cty::c_void, s2: *const cty::c_void, n: usize) -> cty::c_int;
}
extern "C" {
    pub fn os_memset(s: *mut cty::c_void, c: cty::c_int, n: usize) -> *mut cty::c_void;
}
extern "C" {
    pub fn app_main();
}
extern "C" {
    pub fn os_boot();
}
extern "C" {
    #[doc = " Function takes 0 for first call. Returns 0 when timeout has occured. Returned\n value is passed as argument for next call, acting as a timeout context."]
    pub fn io_timeout(last_timeout: cty::c_ushort) -> cty::c_ushort;
}
pub const bolos_ux_e_BOLOS_UX_INITIALIZE: bolos_ux_e = 0;
pub const bolos_ux_e_BOLOS_UX_EVENT: bolos_ux_e = 1;
pub const bolos_ux_e_BOLOS_UX_KEYBOARD: bolos_ux_e = 2;
pub const bolos_ux_e_BOLOS_UX_WAKE_UP: bolos_ux_e = 3;
pub const bolos_ux_e_BOLOS_UX_VALIDATE_PIN: bolos_ux_e = 14;
pub const bolos_ux_e_BOLOS_UX_LAST_ID: bolos_ux_e = 15;
pub type bolos_ux_e = cty::c_uint;
pub use self::bolos_ux_e as bolos_ux_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bolos_ux_params_s {
    pub ux_id: bolos_ux_t,
    pub len: cty::c_uint,
}
#[test]
fn bindgen_test_layout_bolos_ux_params_s() {
    const UNINIT: ::core::mem::MaybeUninit<bolos_ux_params_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<bolos_ux_params_s>(),
        8usize,
        concat!("Size of: ", stringify!(bolos_ux_params_s))
    );
    assert_eq!(
        ::core::mem::align_of::<bolos_ux_params_s>(),
        4usize,
        concat!("Alignment of ", stringify!(bolos_ux_params_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ux_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s),
            "::",
            stringify!(ux_id)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bolos_ux_params_s),
            "::",
            stringify!(len)
        )
    );
}
impl Default for bolos_ux_params_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
pub type bolos_ux_params_t = bolos_ux_params_s;
extern "C" {
    pub fn os_ux(params: *mut bolos_ux_params_t) -> cty::c_uint;
}
extern "C" {
    pub fn os_ux_result(params: *mut bolos_ux_params_t);
}
extern "C" {
    pub fn os_ux_blocking(params: *mut bolos_ux_params_t) -> cty::c_uint;
}
extern "C" {
    pub static mut G_io_seproxyhal_spi_buffer: [cty::c_uchar; 128usize];
}
extern "C" {
    pub fn io_seph_send(buffer: *const cty::c_uchar, length: cty::c_ushort);
}
extern "C" {
    pub fn io_seph_is_status_sent() -> cty::c_uint;
}
extern "C" {
    pub fn io_seph_recv(
        buffer: *mut cty::c_uchar,
        maxlength: cty::c_ushort,
        flags: cty::c_uint,
    ) -> cty::c_ushort;
}
extern "C" {
    pub fn io_seph_init();
}
extern "C" {
    pub fn io_seproxyhal_init();
}
extern "C" {
    pub fn io_seproxyhal_init_ux();
}
extern "C" {
    pub fn io_seproxyhal_init_button();
}
extern "C" {
    pub fn io_exchange_al(channel_and_flags: cty::c_uchar, tx_len: cty::c_ushort) -> cty::c_ushort;
}
extern "C" {
    pub fn os_io_seproxyhal_get_app_name_and_version() -> cty::c_uint;
}
extern "C" {
    pub fn USB_power(enabled: cty::c_uchar);
}
extern "C" {
    pub fn io_seproxyhal_handle_usb_event();
}
extern "C" {
    pub fn io_seproxyhal_handle_usb_ep_xfer_event();
}
extern "C" {
    pub fn io_seproxyhal_get_ep_rx_size(epnum: u8) -> u16;
}
extern "C" {
    pub fn io_seproxyhal_handle_event() -> cty::c_uint;
}
extern "C" {
    pub fn io_seproxyhal_general_status();
}
extern "C" {
    pub fn os_io_seproxyhal_general_status_processing();
}
extern "C" {
    pub fn io_usb_send_apdu_data(buffer: *mut cty::c_uchar, length: cty::c_ushort);
}
extern "C" {
    pub fn io_usb_send_apdu_data_ep0x83(buffer: *mut cty::c_uchar, length: cty::c_ushort);
}
extern "C" {
    pub fn io_usb_send_ep(
        ep: cty::c_uint,
        buffer: *mut cty::c_uchar,
        length: cty::c_ushort,
        timeout: cty::c_uint,
    );
}
extern "C" {
    pub fn io_usb_ccid_reply(buffer: *mut cty::c_uchar, length: cty::c_ushort);
}
extern "C" {
    pub fn io_set_timeout(timeout: cty::c_uint);
}
pub const io_apdu_state_e_APDU_IDLE: io_apdu_state_e = 0;
pub const io_apdu_state_e_APDU_BLE: io_apdu_state_e = 1;
pub const io_apdu_state_e_APDU_BLE_WAIT_NOTIFY: io_apdu_state_e = 2;
pub const io_apdu_state_e_APDU_NFC_M24SR: io_apdu_state_e = 3;
pub const io_apdu_state_e_APDU_NFC_M24SR_SELECT: io_apdu_state_e = 4;
pub const io_apdu_state_e_APDU_NFC_M24SR_FIRST: io_apdu_state_e = 5;
pub const io_apdu_state_e_APDU_NFC_M24SR_RAPDU: io_apdu_state_e = 6;
pub const io_apdu_state_e_APDU_USB_HID: io_apdu_state_e = 7;
pub const io_apdu_state_e_APDU_USB_CCID: io_apdu_state_e = 8;
pub const io_apdu_state_e_APDU_U2F: io_apdu_state_e = 9;
pub const io_apdu_state_e_APDU_RAW: io_apdu_state_e = 10;
pub const io_apdu_state_e_APDU_USB_WEBUSB: io_apdu_state_e = 11;
pub type io_apdu_state_e = cty::c_uint;
#[doc = " Global type that enables to map memory onto the application zone instead of\n over the os for os side"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct io_seph_s {
    pub apdu_state: io_apdu_state_e,
    pub apdu_length: cty::c_ushort,
    pub io_flags: cty::c_ushort,
    pub apdu_media: io_apdu_media_t,
    pub ms: cty::c_uint,
    pub usb_ep_xfer_len: [cty::c_uchar; 7usize],
    pub usb_ep_timeouts: [io_seph_s__bindgen_ty_1; 7usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct io_seph_s__bindgen_ty_1 {
    pub timeout: cty::c_ushort,
}
#[test]
fn bindgen_test_layout_io_seph_s__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<io_seph_s__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<io_seph_s__bindgen_ty_1>(),
        2usize,
        concat!("Size of: ", stringify!(io_seph_s__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<io_seph_s__bindgen_ty_1>(),
        2usize,
        concat!("Alignment of ", stringify!(io_seph_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).timeout) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(io_seph_s__bindgen_ty_1),
            "::",
            stringify!(timeout)
        )
    );
}
#[test]
fn bindgen_test_layout_io_seph_s() {
    const UNINIT: ::core::mem::MaybeUninit<io_seph_s> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<io_seph_s>(),
        40usize,
        concat!("Size of: ", stringify!(io_seph_s))
    );
    assert_eq!(
        ::core::mem::align_of::<io_seph_s>(),
        4usize,
        concat!("Alignment of ", stringify!(io_seph_s))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).apdu_state) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(io_seph_s),
            "::",
            stringify!(apdu_state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).apdu_length) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(io_seph_s),
            "::",
            stringify!(apdu_length)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).io_flags) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(io_seph_s),
            "::",
            stringify!(io_flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).apdu_media) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(io_seph_s),
            "::",
            stringify!(apdu_media)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ms) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(io_seph_s),
            "::",
            stringify!(ms)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).usb_ep_xfer_len) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(io_seph_s),
            "::",
            stringify!(usb_ep_xfer_len)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).usb_ep_timeouts) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(io_seph_s),
            "::",
            stringify!(usb_ep_timeouts)
        )
    );
}
impl Default for io_seph_s {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " Global type that enables to map memory onto the application zone instead of\n over the os for os side"]
pub type io_seph_app_t = io_seph_s;
extern "C" {
    pub static mut G_io_app: io_seph_app_t;
}
extern "C" {
    pub fn io_seproxyhal_setup_ticker(interval_ms: cty::c_uint);
}
extern "C" {
    pub fn io_seproxyhal_power_off();
}
extern "C" {
    pub fn io_seproxyhal_se_reset();
}
extern "C" {
    pub fn io_seproxyhal_disable_io();
}
extern "C" {
    #[doc = " Function to ensure a I/O channel is not timeouting waiting for operations\n after a long time without SEPH packet exchanges"]
    pub fn io_seproxyhal_io_heartbeat();
}
extern "C" {
    pub fn os_io_seph_recv_and_process(dont_process_ux_events: cty::c_uint) -> cty::c_uint;
}
pub type io_send_t =
    ::core::option::Option<unsafe extern "C" fn(buffer: *mut cty::c_uchar, length: cty::c_ushort)>;
pub type io_recv_t = ::core::option::Option<
    unsafe extern "C" fn(buffer: *mut cty::c_uchar, maxlenth: cty::c_ushort) -> cty::c_ushort,
>;
pub const io_usb_hid_receive_status_e_IO_USB_APDU_RESET: io_usb_hid_receive_status_e = 0;
pub const io_usb_hid_receive_status_e_IO_USB_APDU_MORE_DATA: io_usb_hid_receive_status_e = 1;
pub const io_usb_hid_receive_status_e_IO_USB_APDU_RECEIVED: io_usb_hid_receive_status_e = 2;
pub type io_usb_hid_receive_status_e = cty::c_uint;
pub use self::io_usb_hid_receive_status_e as io_usb_hid_receive_status_t;
extern "C" {
    pub static mut G_io_usb_hid_total_length: cty::c_uint;
}
extern "C" {
    pub fn io_usb_hid_init();
}
extern "C" {
    #[doc = " Receive next HID transport packet, returns IO_USB_APDU_RECEIVED when a\n complete APDU has been received in the G_io_apdu_buffer To be called\n typically upon USB OUT event"]
    pub fn io_usb_hid_receive(
        sndfct: io_send_t,
        buffer: *mut cty::c_uchar,
        l: cty::c_ushort,
    ) -> io_usb_hid_receive_status_t;
}
extern "C" {
    #[doc = " Mark the last chunk transmitted as sent.\n To be called typically upon USB IN ACK event"]
    pub fn io_usb_hid_sent(sndfct: io_send_t);
}
extern "C" {
    #[doc = " Request transmission of an APDU from the G_io_apdu_buffer using the HID\n transport protocol"]
    pub fn io_usb_hid_send(sndfct: io_send_t, sndlength: cty::c_ushort);
}
